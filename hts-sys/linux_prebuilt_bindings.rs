/* automatically generated by rust-bindgen 0.60.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 36;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2usize] = b"l\0";
pub const PRId8: &[u8; 2usize] = b"d\0";
pub const PRId16: &[u8; 2usize] = b"d\0";
pub const PRId32: &[u8; 2usize] = b"d\0";
pub const PRId64: &[u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &[u8; 2usize] = b"d\0";
pub const PRIdFAST16: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &[u8; 3usize] = b"ld\0";
pub const PRIi8: &[u8; 2usize] = b"i\0";
pub const PRIi16: &[u8; 2usize] = b"i\0";
pub const PRIi32: &[u8; 2usize] = b"i\0";
pub const PRIi64: &[u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &[u8; 3usize] = b"li\0";
pub const PRIiFAST8: &[u8; 2usize] = b"i\0";
pub const PRIiFAST16: &[u8; 3usize] = b"li\0";
pub const PRIiFAST32: &[u8; 3usize] = b"li\0";
pub const PRIiFAST64: &[u8; 3usize] = b"li\0";
pub const PRIo8: &[u8; 2usize] = b"o\0";
pub const PRIo16: &[u8; 2usize] = b"o\0";
pub const PRIo32: &[u8; 2usize] = b"o\0";
pub const PRIo64: &[u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &[u8; 2usize] = b"o\0";
pub const PRIoFAST16: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &[u8; 3usize] = b"lo\0";
pub const PRIu8: &[u8; 2usize] = b"u\0";
pub const PRIu16: &[u8; 2usize] = b"u\0";
pub const PRIu32: &[u8; 2usize] = b"u\0";
pub const PRIu64: &[u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &[u8; 2usize] = b"u\0";
pub const PRIuFAST16: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &[u8; 3usize] = b"lu\0";
pub const PRIx8: &[u8; 2usize] = b"x\0";
pub const PRIx16: &[u8; 2usize] = b"x\0";
pub const PRIx32: &[u8; 2usize] = b"x\0";
pub const PRIx64: &[u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &[u8; 2usize] = b"x\0";
pub const PRIxFAST16: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &[u8; 3usize] = b"lx\0";
pub const PRIX8: &[u8; 2usize] = b"X\0";
pub const PRIX16: &[u8; 2usize] = b"X\0";
pub const PRIX32: &[u8; 2usize] = b"X\0";
pub const PRIX64: &[u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &[u8; 2usize] = b"X\0";
pub const PRIXFAST16: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &[u8; 3usize] = b"lX\0";
pub const PRIdMAX: &[u8; 3usize] = b"ld\0";
pub const PRIiMAX: &[u8; 3usize] = b"li\0";
pub const PRIoMAX: &[u8; 3usize] = b"lo\0";
pub const PRIuMAX: &[u8; 3usize] = b"lu\0";
pub const PRIxMAX: &[u8; 3usize] = b"lx\0";
pub const PRIXMAX: &[u8; 3usize] = b"lX\0";
pub const PRIdPTR: &[u8; 3usize] = b"ld\0";
pub const PRIiPTR: &[u8; 3usize] = b"li\0";
pub const PRIoPTR: &[u8; 3usize] = b"lo\0";
pub const PRIuPTR: &[u8; 3usize] = b"lu\0";
pub const PRIxPTR: &[u8; 3usize] = b"lx\0";
pub const PRIXPTR: &[u8; 3usize] = b"lX\0";
pub const SCNd8: &[u8; 4usize] = b"hhd\0";
pub const SCNd16: &[u8; 3usize] = b"hd\0";
pub const SCNd32: &[u8; 2usize] = b"d\0";
pub const SCNd64: &[u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &[u8; 3usize] = b"ld\0";
pub const SCNi8: &[u8; 4usize] = b"hhi\0";
pub const SCNi16: &[u8; 3usize] = b"hi\0";
pub const SCNi32: &[u8; 2usize] = b"i\0";
pub const SCNi64: &[u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &[u8; 3usize] = b"li\0";
pub const SCNiFAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3usize] = b"li\0";
pub const SCNiFAST32: &[u8; 3usize] = b"li\0";
pub const SCNiFAST64: &[u8; 3usize] = b"li\0";
pub const SCNu8: &[u8; 4usize] = b"hhu\0";
pub const SCNu16: &[u8; 3usize] = b"hu\0";
pub const SCNu32: &[u8; 2usize] = b"u\0";
pub const SCNu64: &[u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &[u8; 3usize] = b"lu\0";
pub const SCNo8: &[u8; 4usize] = b"hho\0";
pub const SCNo16: &[u8; 3usize] = b"ho\0";
pub const SCNo32: &[u8; 2usize] = b"o\0";
pub const SCNo64: &[u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &[u8; 3usize] = b"lo\0";
pub const SCNx8: &[u8; 4usize] = b"hhx\0";
pub const SCNx16: &[u8; 3usize] = b"hx\0";
pub const SCNx32: &[u8; 2usize] = b"x\0";
pub const SCNx64: &[u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &[u8; 3usize] = b"lx\0";
pub const SCNdMAX: &[u8; 3usize] = b"ld\0";
pub const SCNiMAX: &[u8; 3usize] = b"li\0";
pub const SCNoMAX: &[u8; 3usize] = b"lo\0";
pub const SCNuMAX: &[u8; 3usize] = b"lu\0";
pub const SCNxMAX: &[u8; 3usize] = b"lx\0";
pub const SCNdPTR: &[u8; 3usize] = b"ld\0";
pub const SCNiPTR: &[u8; 3usize] = b"li\0";
pub const SCNoPTR: &[u8; 3usize] = b"lo\0";
pub const SCNuPTR: &[u8; 3usize] = b"lu\0";
pub const SCNxPTR: &[u8; 3usize] = b"lx\0";
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const HAVE___BUILTIN_CLZ: u32 = 1;
pub const HTS_PATH_SEPARATOR_CHAR: u8 = 58u8;
pub const HTS_PATH_SEPARATOR_STR: &[u8; 2usize] = b":\0";
pub const HTS_RESIZE_CLEAR: u32 = 1;
pub const HTS_IDX_DELIM: &[u8; 8usize] = b"##idx##\0";
pub const HTS_VERSION: u32 = 101600;
pub const HTS_FEATURE_CONFIGURE: u32 = 1;
pub const HTS_FEATURE_PLUGINS: u32 = 2;
pub const HTS_FEATURE_LIBCURL: u32 = 1024;
pub const HTS_FEATURE_S3: u32 = 2048;
pub const HTS_FEATURE_GCS: u32 = 4096;
pub const HTS_FEATURE_LIBDEFLATE: u32 = 1048576;
pub const HTS_FEATURE_LZMA: u32 = 2097152;
pub const HTS_FEATURE_BZIP2: u32 = 4194304;
pub const HTS_FEATURE_HTSCODECS: u32 = 8388608;
pub const HTS_FEATURE_CC: u32 = 134217728;
pub const HTS_FEATURE_CFLAGS: u32 = 268435456;
pub const HTS_FEATURE_CPPFLAGS: u32 = 536870912;
pub const HTS_FEATURE_LDFLAGS: u32 = 1073741824;
pub const HTS_IDX_NOCOOR: i32 = -2;
pub const HTS_IDX_START: i32 = -3;
pub const HTS_IDX_REST: i32 = -4;
pub const HTS_IDX_NONE: i32 = -5;
pub const HTS_FMT_CSI: u32 = 0;
pub const HTS_FMT_BAI: u32 = 1;
pub const HTS_FMT_TBI: u32 = 2;
pub const HTS_FMT_CRAI: u32 = 3;
pub const HTS_FMT_FAI: u32 = 4;
pub const PRIhts_pos: &[u8; 3usize] = b"ld\0";
pub const HTS_IDX_SAVE_REMOTE: u32 = 1;
pub const HTS_IDX_SILENT_FAIL: u32 = 2;
pub const HTS_PARSE_THOUSANDS_SEP: u32 = 1;
pub const HTS_PARSE_ONE_COORD: u32 = 2;
pub const HTS_PARSE_LIST: u32 = 4;
pub const FT_UNKN: u32 = 0;
pub const FT_GZ: u32 = 1;
pub const FT_VCF: u32 = 2;
pub const FT_VCF_GZ: u32 = 3;
pub const FT_BCF: u32 = 4;
pub const FT_BCF_GZ: u32 = 5;
pub const FT_STDIN: u32 = 8;
pub const HTS_ALLOW_UNALIGNED: u32 = 1;
pub const _ASSERT_H: u32 = 1;
pub const BCF_HL_FLT: u32 = 0;
pub const BCF_HL_INFO: u32 = 1;
pub const BCF_HL_FMT: u32 = 2;
pub const BCF_HL_CTG: u32 = 3;
pub const BCF_HL_STR: u32 = 4;
pub const BCF_HL_GEN: u32 = 5;
pub const BCF_HT_FLAG: u32 = 0;
pub const BCF_HT_INT: u32 = 1;
pub const BCF_HT_REAL: u32 = 2;
pub const BCF_HT_STR: u32 = 3;
pub const BCF_HT_LONG: u32 = 257;
pub const BCF_VL_FIXED: u32 = 0;
pub const BCF_VL_VAR: u32 = 1;
pub const BCF_VL_A: u32 = 2;
pub const BCF_VL_G: u32 = 3;
pub const BCF_VL_R: u32 = 4;
pub const BCF_DT_ID: u32 = 0;
pub const BCF_DT_CTG: u32 = 1;
pub const BCF_DT_SAMPLE: u32 = 2;
pub const BCF_BT_NULL: u32 = 0;
pub const BCF_BT_INT8: u32 = 1;
pub const BCF_BT_INT16: u32 = 2;
pub const BCF_BT_INT32: u32 = 3;
pub const BCF_BT_INT64: u32 = 4;
pub const BCF_BT_FLOAT: u32 = 5;
pub const BCF_BT_CHAR: u32 = 7;
pub const VCF_REF: u32 = 0;
pub const VCF_SNP: u32 = 1;
pub const VCF_MNP: u32 = 2;
pub const VCF_INDEL: u32 = 4;
pub const VCF_OTHER: u32 = 8;
pub const VCF_BND: u32 = 16;
pub const VCF_OVERLAP: u32 = 32;
pub const VCF_INS: u32 = 64;
pub const VCF_DEL: u32 = 128;
pub const VCF_ANY: u32 = 255;
pub const BCF1_DIRTY_ID: u32 = 1;
pub const BCF1_DIRTY_ALS: u32 = 2;
pub const BCF1_DIRTY_FLT: u32 = 4;
pub const BCF1_DIRTY_INF: u32 = 8;
pub const BCF_ERR_CTG_UNDEF: u32 = 1;
pub const BCF_ERR_TAG_UNDEF: u32 = 2;
pub const BCF_ERR_NCOLS: u32 = 4;
pub const BCF_ERR_LIMITS: u32 = 8;
pub const BCF_ERR_CHAR: u32 = 16;
pub const BCF_ERR_CTG_INVALID: u32 = 32;
pub const BCF_ERR_TAG_INVALID: u32 = 64;
pub const BCF_UN_STR: u32 = 1;
pub const BCF_UN_FLT: u32 = 2;
pub const BCF_UN_INFO: u32 = 4;
pub const BCF_UN_SHR: u32 = 7;
pub const BCF_UN_FMT: u32 = 8;
pub const BCF_UN_IND: u32 = 8;
pub const BCF_UN_ALL: u32 = 15;
pub const bcf_gt_missing: u32 = 0;
pub const bcf_int8_vector_end: i32 = -127;
pub const bcf_int16_vector_end: i32 = -32767;
pub const bcf_int32_vector_end: i32 = -2147483647;
pub const bcf_int64_vector_end: i64 = -9223372036854775807;
pub const bcf_str_vector_end: u32 = 0;
pub const bcf_int8_missing: i32 = -128;
pub const bcf_int16_missing: i32 = -32768;
pub const bcf_int32_missing: i32 = -2147483648;
pub const bcf_int64_missing: i64 = -9223372036854775808;
pub const bcf_str_missing: u32 = 7;
pub const BCF_MAX_BT_INT8: u32 = 127;
pub const BCF_MAX_BT_INT16: u32 = 32767;
pub const BCF_MAX_BT_INT32: u32 = 2147483647;
pub const BCF_MIN_BT_INT8: i32 = -120;
pub const BCF_MIN_BT_INT16: i32 = -32760;
pub const BCF_MIN_BT_INT32: i32 = -2147483640;
pub const SAM_FORMAT_VERSION: &[u8; 4usize] = b"1.6\0";
pub const BAM_CMATCH: u32 = 0;
pub const BAM_CINS: u32 = 1;
pub const BAM_CDEL: u32 = 2;
pub const BAM_CREF_SKIP: u32 = 3;
pub const BAM_CSOFT_CLIP: u32 = 4;
pub const BAM_CHARD_CLIP: u32 = 5;
pub const BAM_CPAD: u32 = 6;
pub const BAM_CEQUAL: u32 = 7;
pub const BAM_CDIFF: u32 = 8;
pub const BAM_CBACK: u32 = 9;
pub const BAM_CIGAR_STR: &[u8; 11usize] = b"MIDNSHP=XB\0";
pub const BAM_CIGAR_SHIFT: u32 = 4;
pub const BAM_CIGAR_MASK: u32 = 15;
pub const BAM_CIGAR_TYPE: u32 = 246183;
pub const BAM_FPAIRED: u32 = 1;
pub const BAM_FPROPER_PAIR: u32 = 2;
pub const BAM_FUNMAP: u32 = 4;
pub const BAM_FMUNMAP: u32 = 8;
pub const BAM_FREVERSE: u32 = 16;
pub const BAM_FMREVERSE: u32 = 32;
pub const BAM_FREAD1: u32 = 64;
pub const BAM_FREAD2: u32 = 128;
pub const BAM_FSECONDARY: u32 = 256;
pub const BAM_FQCFAIL: u32 = 512;
pub const BAM_FDUP: u32 = 1024;
pub const BAM_FSUPPLEMENTARY: u32 = 2048;
pub const BAM_USER_OWNS_STRUCT: u32 = 1;
pub const BAM_USER_OWNS_DATA: u32 = 2;
pub const BGZF_BLOCK_SIZE: u32 = 65280;
pub const BGZF_MAX_BLOCK_SIZE: u32 = 65536;
pub const BGZF_ERR_ZLIB: u32 = 1;
pub const BGZF_ERR_HEADER: u32 = 2;
pub const BGZF_ERR_IO: u32 = 4;
pub const BGZF_ERR_MISUSE: u32 = 8;
pub const BGZF_ERR_MT: u32 = 16;
pub const BGZF_ERR_CRC: u32 = 32;
pub const GT_HOM_RR: u32 = 0;
pub const GT_HOM_AA: u32 = 1;
pub const GT_HET_RA: u32 = 2;
pub const GT_HET_AA: u32 = 3;
pub const GT_HAPL_R: u32 = 4;
pub const GT_HAPL_A: u32 = 5;
pub const GT_UNKN: u32 = 6;
pub const TBX_MAX_SHIFT: u32 = 31;
pub const TBX_GENERIC: u32 = 0;
pub const TBX_SAM: u32 = 1;
pub const TBX_VCF: u32 = 2;
pub const TBX_UCSC: u32 = 65536;
pub const COLLAPSE_NONE: u32 = 0;
pub const COLLAPSE_SNPS: u32 = 1;
pub const COLLAPSE_INDELS: u32 = 2;
pub const COLLAPSE_ANY: u32 = 4;
pub const COLLAPSE_SOME: u32 = 8;
pub const COLLAPSE_BOTH: u32 = 3;
pub const BCF_SR_PAIR_SNPS: u32 = 1;
pub const BCF_SR_PAIR_INDELS: u32 = 2;
pub const BCF_SR_PAIR_ANY: u32 = 4;
pub const BCF_SR_PAIR_SOME: u32 = 8;
pub const BCF_SR_PAIR_SNP_REF: u32 = 16;
pub const BCF_SR_PAIR_INDEL_REF: u32 = 32;
pub const BCF_SR_PAIR_EXACT: u32 = 64;
pub const BCF_SR_PAIR_BOTH: u32 = 3;
pub const BCF_SR_PAIR_BOTH_REF: u32 = 51;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    fn test_field___clang_max_align_nonce1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<max_align_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(max_align_t),
                "::",
                stringify!(__clang_max_align_nonce1)
            )
        );
    }
    test_field___clang_max_align_nonce1();
    fn test_field___clang_max_align_nonce2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<max_align_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(max_align_t),
                "::",
                stringify!(__clang_max_align_nonce2)
            )
        );
    }
    test_field___clang_max_align_nonce2();
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__fsid_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__fsid_t),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<imaxdiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(imaxdiv_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<imaxdiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(imaxdiv_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
#[doc = "< All logging disabled."]
pub const htsLogLevel_HTS_LOG_OFF: htsLogLevel = 0;
#[doc = "< Logging of errors only."]
pub const htsLogLevel_HTS_LOG_ERROR: htsLogLevel = 1;
#[doc = "< Logging of errors and warnings."]
pub const htsLogLevel_HTS_LOG_WARNING: htsLogLevel = 3;
#[doc = "< Logging of errors, warnings, and normal but significant events."]
pub const htsLogLevel_HTS_LOG_INFO: htsLogLevel = 4;
#[doc = "< Logging of all except the most detailed debug events."]
pub const htsLogLevel_HTS_LOG_DEBUG: htsLogLevel = 5;
#[doc = "< All logging enabled."]
pub const htsLogLevel_HTS_LOG_TRACE: htsLogLevel = 6;
#[doc = " Log levels."]
pub type htsLogLevel = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Sets the selected log level."]
    pub fn hts_set_log_level(level: htsLogLevel);
}
extern "C" {
    #[doc = " Gets the selected log level."]
    pub fn hts_get_log_level() -> htsLogLevel;
}
extern "C" {
    #[doc = " Selected log level."]
    #[doc = "*!"]
    #[doc = "* One of the HTS_LOG_* values. The default is HTS_LOG_WARNING."]
    #[doc = "* \\note Avoid direct use of this variable. Use hts_set_log_level and hts_get_log_level instead."]
    #[doc = "*/"]
    pub static mut hts_verbose: ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Logs an event."]
    #[doc = " \\param severity      Severity of the event:"]
    #[doc = "                      - HTS_LOG_ERROR means that something went wrong so that a task could not be completed."]
    #[doc = "                      - HTS_LOG_WARNING means that something unexpected happened, but that execution can continue, perhaps in a degraded mode."]
    #[doc = "                      - HTS_LOG_INFO means that something normal but significant happened."]
    #[doc = "                      - HTS_LOG_DEBUG means that something normal and insignificant happened."]
    #[doc = "                      - HTS_LOG_TRACE means that something happened that might be of interest when troubleshooting."]
    #[doc = " \\param context       Context where the event occurred. Typically set to \"__func__\"."]
    #[doc = " \\param format        Format string with placeholders, like printf."]
    pub fn hts_log(
        severity: htsLogLevel,
        context: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<div_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(div_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<div_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(div_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ldiv_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ldiv_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(lldiv_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(lldiv_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sigset_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sigset_t),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timeval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_usec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timeval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval),
                "::",
                stringify!(tv_usec)
            )
        );
    }
    test_field_tv_usec();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timespec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_nsec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timespec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec),
                "::",
                stringify!(tv_nsec)
            )
        );
    }
    test_field_tv_nsec();
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    fn test_field___fds_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fd_set>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fd_set),
                "::",
                stringify!(__fds_bits)
            )
        );
    }
    test_field___fds_bits();
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    fn test_field___low() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<__atomic_wide_counter__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__atomic_wide_counter__bindgen_ty_1),
                "::",
                stringify!(__low)
            )
        );
    }
    test_field___low();
    fn test_field___high() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<__atomic_wide_counter__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__atomic_wide_counter__bindgen_ty_1),
                "::",
                stringify!(__high)
            )
        );
    }
    test_field___high();
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    fn test_field___value64() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__atomic_wide_counter>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__atomic_wide_counter),
                "::",
                stringify!(__value64)
            )
        );
    }
    test_field___value64();
    fn test_field___value32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__atomic_wide_counter>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__atomic_wide_counter),
                "::",
                stringify!(__value32)
            )
        );
    }
    test_field___value32();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    fn test_field___prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_internal_list>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_list),
                "::",
                stringify!(__prev)
            )
        );
    }
    test_field___prev();
    fn test_field___next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_internal_list>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_list),
                "::",
                stringify!(__next)
            )
        );
    }
    test_field___next();
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    fn test_field___next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_internal_slist>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_slist),
                "::",
                stringify!(__next)
            )
        );
    }
    test_field___next();
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    fn test_field___lock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__lock)
            )
        );
    }
    test_field___lock();
    fn test_field___count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__count)
            )
        );
    }
    test_field___count();
    fn test_field___owner() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__owner)
            )
        );
    }
    test_field___owner();
    fn test_field___nusers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__nusers)
            )
        );
    }
    test_field___nusers();
    fn test_field___kind() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__kind)
            )
        );
    }
    test_field___kind();
    fn test_field___spins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__spins)
            )
        );
    }
    test_field___spins();
    fn test_field___elision() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize
            },
            22usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__elision)
            )
        );
    }
    test_field___elision();
    fn test_field___list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__list)
            )
        );
    }
    test_field___list();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    fn test_field___readers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__readers)
            )
        );
    }
    test_field___readers();
    fn test_field___writers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__writers)
            )
        );
    }
    test_field___writers();
    fn test_field___wrphase_futex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__wrphase_futex)
            )
        );
    }
    test_field___wrphase_futex();
    fn test_field___writers_futex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__writers_futex)
            )
        );
    }
    test_field___writers_futex();
    fn test_field___pad3() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__pad3)
            )
        );
    }
    test_field___pad3();
    fn test_field___pad4() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__pad4)
            )
        );
    }
    test_field___pad4();
    fn test_field___cur_writer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__cur_writer)
            )
        );
    }
    test_field___cur_writer();
    fn test_field___shared() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__shared)
            )
        );
    }
    test_field___shared();
    fn test_field___rwelision() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__rwelision)
            )
        );
    }
    test_field___rwelision();
    fn test_field___pad1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize
            },
            33usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__pad1)
            )
        );
    }
    test_field___pad1();
    fn test_field___pad2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__pad2)
            )
        );
    }
    test_field___pad2();
    fn test_field___flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__flags)
            )
        );
    }
    test_field___flags();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    fn test_field___wseq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__wseq)
            )
        );
    }
    test_field___wseq();
    fn test_field___g1_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g1_start)
            )
        );
    }
    test_field___g1_start();
    fn test_field___g_refs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g_refs)
            )
        );
    }
    test_field___g_refs();
    fn test_field___g_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g_size)
            )
        );
    }
    test_field___g_size();
    fn test_field___g1_orig_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g1_orig_size)
            )
        );
    }
    test_field___g1_orig_size();
    fn test_field___wrefs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__wrefs)
            )
        );
    }
    test_field___wrefs();
    fn test_field___g_signals() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g_signals)
            )
        );
    }
    test_field___g_signals();
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    fn test_field___data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__once_flag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__once_flag),
                "::",
                stringify!(__data)
            )
        );
    }
    test_field___data();
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutexattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutexattr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutexattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutexattr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_condattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_condattr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_condattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_condattr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_attr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_attr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_attr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_attr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    fn test_field___data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__data)
            )
        );
    }
    test_field___data();
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    fn test_field___data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_cond_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_cond_t),
                "::",
                stringify!(__data)
            )
        );
    }
    test_field___data();
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_cond_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_cond_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_cond_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_cond_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    fn test_field___data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlock_t),
                "::",
                stringify!(__data)
            )
        );
    }
    test_field___data();
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlock_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlock_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlockattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlockattr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlockattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlockattr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_barrier_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_barrier_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_barrier_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_barrier_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_barrierattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_barrierattr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_barrierattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_barrierattr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    fn test_field_fptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(fptr)
            )
        );
    }
    test_field_fptr();
    fn test_field_rptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(rptr)
            )
        );
    }
    test_field_rptr();
    fn test_field_state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(state)
            )
        );
    }
    test_field_state();
    fn test_field_rand_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(rand_type)
            )
        );
    }
    test_field_rand_type();
    fn test_field_rand_deg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(rand_deg)
            )
        );
    }
    test_field_rand_deg();
    fn test_field_rand_sep() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(rand_sep)
            )
        );
    }
    test_field_rand_sep();
    fn test_field_end_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(end_ptr)
            )
        );
    }
    test_field_end_ptr();
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    fn test_field___x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<drand48_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(drand48_data),
                "::",
                stringify!(__x)
            )
        );
    }
    test_field___x();
    fn test_field___old_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<drand48_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(drand48_data),
                "::",
                stringify!(__old_x)
            )
        );
    }
    test_field___old_x();
    fn test_field___c() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<drand48_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(drand48_data),
                "::",
                stringify!(__c)
            )
        );
    }
    test_field___c();
    fn test_field___init() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<drand48_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize
            },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(drand48_data),
                "::",
                stringify!(__init)
            )
        );
    }
    test_field___init();
    fn test_field___a() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<drand48_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(drand48_data),
                "::",
                stringify!(__a)
            )
        );
    }
    test_field___a();
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __size: size_t);
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        __pwcs: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(
        __s: *mut ::std::os::raw::c_char,
        __pwcs: *const wchar_t,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    fn test_field___locales() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__locales)
            )
        );
    }
    test_field___locales();
    fn test_field___ctype_b() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_b)
            )
        );
    }
    test_field___ctype_b();
    fn test_field___ctype_tolower() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_tolower)
            )
        );
    }
    test_field___ctype_tolower();
    fn test_field___ctype_toupper() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_toupper)
            )
        );
    }
    test_field___ctype_toupper();
    fn test_field___names() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__names)
            )
        );
    }
    test_field___names();
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
        __l: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: size_t,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    fn test_field___wch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t__bindgen_ty_1),
                "::",
                stringify!(__wch)
            )
        );
    }
    test_field___wch();
    fn test_field___wchb() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t__bindgen_ty_1),
                "::",
                stringify!(__wchb)
            )
        );
    }
    test_field___wchb();
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    fn test_field___count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__count)
            )
        );
    }
    test_field___count();
    fn test_field___value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__value)
            )
        );
    }
    test_field___value();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    fn test_field___pos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_G_fpos_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_G_fpos_t),
                "::",
                stringify!(__pos)
            )
        );
    }
    test_field___pos();
    fn test_field___state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_G_fpos_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_G_fpos_t),
                "::",
                stringify!(__state)
            )
        );
    }
    test_field___state();
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    fn test_field___pos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_G_fpos64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_G_fpos64_t),
                "::",
                stringify!(__pos)
            )
        );
    }
    test_field___pos();
    fn test_field___state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_G_fpos64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_G_fpos64_t),
                "::",
                stringify!(__state)
            )
        );
    }
    test_field___state();
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    fn test_field__flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_flags)
            )
        );
    }
    test_field__flags();
    fn test_field__IO_read_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_ptr)
            )
        );
    }
    test_field__IO_read_ptr();
    fn test_field__IO_read_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_end)
            )
        );
    }
    test_field__IO_read_end();
    fn test_field__IO_read_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_base)
            )
        );
    }
    test_field__IO_read_base();
    fn test_field__IO_write_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_base)
            )
        );
    }
    test_field__IO_write_base();
    fn test_field__IO_write_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_ptr)
            )
        );
    }
    test_field__IO_write_ptr();
    fn test_field__IO_write_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_end)
            )
        );
    }
    test_field__IO_write_end();
    fn test_field__IO_buf_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_buf_base)
            )
        );
    }
    test_field__IO_buf_base();
    fn test_field__IO_buf_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_buf_end)
            )
        );
    }
    test_field__IO_buf_end();
    fn test_field__IO_save_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_save_base)
            )
        );
    }
    test_field__IO_save_base();
    fn test_field__IO_backup_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_backup_base)
            )
        );
    }
    test_field__IO_backup_base();
    fn test_field__IO_save_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_save_end)
            )
        );
    }
    test_field__IO_save_end();
    fn test_field__markers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_markers)
            )
        );
    }
    test_field__markers();
    fn test_field__chain() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_chain)
            )
        );
    }
    test_field__chain();
    fn test_field__fileno() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_fileno)
            )
        );
    }
    test_field__fileno();
    fn test_field__flags2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_flags2)
            )
        );
    }
    test_field__flags2();
    fn test_field__old_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_old_offset)
            )
        );
    }
    test_field__old_offset();
    fn test_field__cur_column() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_cur_column)
            )
        );
    }
    test_field__cur_column();
    fn test_field__vtable_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize
            },
            130usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_vtable_offset)
            )
        );
    }
    test_field__vtable_offset();
    fn test_field__shortbuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize
            },
            131usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_shortbuf)
            )
        );
    }
    test_field__shortbuf();
    fn test_field__lock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_lock)
            )
        );
    }
    test_field__lock();
    fn test_field__offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_offset)
            )
        );
    }
    test_field__offset();
    fn test_field__codecvt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_codecvt)
            )
        );
    }
    test_field__codecvt();
    fn test_field__wide_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_wide_data)
            )
        );
    }
    test_field__wide_data();
    fn test_field__freeres_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_freeres_list)
            )
        );
    }
    test_field__freeres_list();
    fn test_field__freeres_buf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_freeres_buf)
            )
        );
    }
    test_field__freeres_buf();
    fn test_field___pad5() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(__pad5)
            )
        );
    }
    test_field___pad5();
    fn test_field__mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_mode)
            )
        );
    }
    test_field__mode();
    fn test_field__unused2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize
            },
            196usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_unused2)
            )
        );
    }
    test_field__unused2();
}
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: size_t,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: size_t);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kstring_t {
    pub l: size_t,
    pub m: size_t,
    pub s: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_kstring_t() {
    assert_eq!(
        ::std::mem::size_of::<kstring_t>(),
        24usize,
        concat!("Size of: ", stringify!(kstring_t))
    );
    assert_eq!(
        ::std::mem::align_of::<kstring_t>(),
        8usize,
        concat!("Alignment of ", stringify!(kstring_t))
    );
    fn test_field_l() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kstring_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kstring_t),
                "::",
                stringify!(l)
            )
        );
    }
    test_field_l();
    fn test_field_m() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kstring_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(kstring_t),
                "::",
                stringify!(m)
            )
        );
    }
    test_field_m();
    fn test_field_s() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kstring_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(kstring_t),
                "::",
                stringify!(s)
            )
        );
    }
    test_field_s();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ks_tokaux_t {
    pub tab: [u64; 4usize],
    pub sep: ::std::os::raw::c_int,
    pub finished: ::std::os::raw::c_int,
    pub p: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ks_tokaux_t() {
    assert_eq!(
        ::std::mem::size_of::<ks_tokaux_t>(),
        48usize,
        concat!("Size of: ", stringify!(ks_tokaux_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ks_tokaux_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ks_tokaux_t))
    );
    fn test_field_tab() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ks_tokaux_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tab) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ks_tokaux_t),
                "::",
                stringify!(tab)
            )
        );
    }
    test_field_tab();
    fn test_field_sep() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ks_tokaux_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sep) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(ks_tokaux_t),
                "::",
                stringify!(sep)
            )
        );
    }
    test_field_sep();
    fn test_field_finished() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ks_tokaux_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).finished) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(ks_tokaux_t),
                "::",
                stringify!(finished)
            )
        );
    }
    test_field_finished();
    fn test_field_p() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ks_tokaux_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(ks_tokaux_t),
                "::",
                stringify!(p)
            )
        );
    }
    test_field_p();
}
extern "C" {
    pub fn kvsprintf(
        s: *mut kstring_t,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ksprintf(
        s: *mut kstring_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kputd(d: f64, s: *mut kstring_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ksplit_core(
        s: *mut ::std::os::raw::c_char,
        delimiter: ::std::os::raw::c_int,
        _max: *mut ::std::os::raw::c_int,
        _offsets: *mut *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrstr(
        str_: *const ::std::os::raw::c_char,
        pat: *const ::std::os::raw::c_char,
        _prep: *mut *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn kstrnstr(
        str_: *const ::std::os::raw::c_char,
        pat: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
        _prep: *mut *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn kmemmem(
        _str: *const ::std::os::raw::c_void,
        n: ::std::os::raw::c_int,
        _pat: *const ::std::os::raw::c_void,
        m: ::std::os::raw::c_int,
        _prep: *mut *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kstrtok(
        str_: *const ::std::os::raw::c_char,
        sep: *const ::std::os::raw::c_char,
        aux: *mut ks_tokaux_t,
    ) -> *mut ::std::os::raw::c_char;
}
pub type kgets_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_char,
>;
extern "C" {
    pub fn kgetline(
        s: *mut kstring_t,
        fgets_fn: kgets_func,
        fp: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub type kgets_func2 = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ssize_t,
>;
extern "C" {
    pub fn kgetline2(
        s: *mut kstring_t,
        fgets_fn: kgets_func2,
        fp: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cram_fd {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hFILE {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hts_tpool {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hts_resize_array_(
        arg1: size_t,
        arg2: size_t,
        arg3: size_t,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut *mut ::std::os::raw::c_void,
        arg6: ::std::os::raw::c_int,
        arg7: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release resources when dlclosing a dynamically loaded HTSlib"]
    #[doc = "** @discussion"]
    #[doc = "*  Normally HTSlib cleans up automatically when your program exits,"]
    #[doc = "*  whether that is via exit(3) or returning from main(). However if you"]
    #[doc = "*  have dlopen(3)ed HTSlib and wish to close it before your main program"]
    #[doc = "*  exits, you must call hts_lib_shutdown() before dlclose(3)."]
    #[doc = "*/"]
    pub fn hts_lib_shutdown();
}
extern "C" {
    #[doc = " Wrapper function for free(). Enables memory deallocation across DLL"]
    #[doc = " boundary. Should be used by all applications, which are compiled"]
    #[doc = " with a different standard library than htslib and call htslib"]
    #[doc = " methods that return dynamically allocated data."]
    pub fn hts_free(ptr: *mut ::std::os::raw::c_void);
}
pub const htsFormatCategory_unknown_category: htsFormatCategory = 0;
pub const htsFormatCategory_sequence_data: htsFormatCategory = 1;
pub const htsFormatCategory_variant_data: htsFormatCategory = 2;
pub const htsFormatCategory_index_file: htsFormatCategory = 3;
pub const htsFormatCategory_region_list: htsFormatCategory = 4;
pub const htsFormatCategory_category_maximum: htsFormatCategory = 32767;
#[doc = " File I/O *"]
pub type htsFormatCategory = ::std::os::raw::c_uint;
pub const htsExactFormat_unknown_format: htsExactFormat = 0;
pub const htsExactFormat_binary_format: htsExactFormat = 1;
pub const htsExactFormat_text_format: htsExactFormat = 2;
pub const htsExactFormat_sam: htsExactFormat = 3;
pub const htsExactFormat_bam: htsExactFormat = 4;
pub const htsExactFormat_bai: htsExactFormat = 5;
pub const htsExactFormat_cram: htsExactFormat = 6;
pub const htsExactFormat_crai: htsExactFormat = 7;
pub const htsExactFormat_vcf: htsExactFormat = 8;
pub const htsExactFormat_bcf: htsExactFormat = 9;
pub const htsExactFormat_csi: htsExactFormat = 10;
pub const htsExactFormat_gzi: htsExactFormat = 11;
pub const htsExactFormat_tbi: htsExactFormat = 12;
pub const htsExactFormat_bed: htsExactFormat = 13;
pub const htsExactFormat_htsget: htsExactFormat = 14;
pub const htsExactFormat_json: htsExactFormat = 14;
pub const htsExactFormat_empty_format: htsExactFormat = 15;
pub const htsExactFormat_fasta_format: htsExactFormat = 16;
pub const htsExactFormat_fastq_format: htsExactFormat = 17;
pub const htsExactFormat_fai_format: htsExactFormat = 18;
pub const htsExactFormat_fqi_format: htsExactFormat = 19;
pub const htsExactFormat_hts_crypt4gh_format: htsExactFormat = 20;
pub const htsExactFormat_d4_format: htsExactFormat = 21;
pub const htsExactFormat_format_maximum: htsExactFormat = 32767;
pub type htsExactFormat = ::std::os::raw::c_uint;
pub const htsCompression_no_compression: htsCompression = 0;
pub const htsCompression_gzip: htsCompression = 1;
pub const htsCompression_bgzf: htsCompression = 2;
pub const htsCompression_custom: htsCompression = 3;
pub const htsCompression_bzip2_compression: htsCompression = 4;
pub const htsCompression_razf_compression: htsCompression = 5;
pub const htsCompression_xz_compression: htsCompression = 6;
pub const htsCompression_zstd_compression: htsCompression = 7;
pub const htsCompression_compression_maximum: htsCompression = 32767;
pub type htsCompression = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct htsFormat {
    pub category: htsFormatCategory,
    pub format: htsExactFormat,
    pub version: htsFormat__bindgen_ty_1,
    pub compression: htsCompression,
    pub compression_level: ::std::os::raw::c_short,
    pub specific: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct htsFormat__bindgen_ty_1 {
    pub major: ::std::os::raw::c_short,
    pub minor: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_htsFormat__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<htsFormat__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(htsFormat__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<htsFormat__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(htsFormat__bindgen_ty_1))
    );
    fn test_field_major() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<htsFormat__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(htsFormat__bindgen_ty_1),
                "::",
                stringify!(major)
            )
        );
    }
    test_field_major();
    fn test_field_minor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<htsFormat__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minor) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(htsFormat__bindgen_ty_1),
                "::",
                stringify!(minor)
            )
        );
    }
    test_field_minor();
}
#[test]
fn bindgen_test_layout_htsFormat() {
    assert_eq!(
        ::std::mem::size_of::<htsFormat>(),
        32usize,
        concat!("Size of: ", stringify!(htsFormat))
    );
    assert_eq!(
        ::std::mem::align_of::<htsFormat>(),
        8usize,
        concat!("Alignment of ", stringify!(htsFormat))
    );
    fn test_field_category() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<htsFormat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).category) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(htsFormat),
                "::",
                stringify!(category)
            )
        );
    }
    test_field_category();
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<htsFormat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(htsFormat),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<htsFormat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(htsFormat),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_compression() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<htsFormat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compression) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(htsFormat),
                "::",
                stringify!(compression)
            )
        );
    }
    test_field_compression();
    fn test_field_compression_level() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<htsFormat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compression_level) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(htsFormat),
                "::",
                stringify!(compression_level)
            )
        );
    }
    test_field_compression_level();
    fn test_field_specific() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<htsFormat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).specific) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(htsFormat),
                "::",
                stringify!(specific)
            )
        );
    }
    test_field_specific();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hts_idx_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hts_filter_t {
    _unused: [u8; 0],
}
#[doc = " @brief File handle returned by hts_open() etc."]
#[doc = " This structure should be considered opaque by end users. There should be"]
#[doc = " no need to access most fields directly in user code, and in cases where"]
#[doc = " it is desirable accessor functions such as hts_get_format() are provided."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct htsFile {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub lineno: i64,
    pub line: kstring_t,
    pub fn_: *mut ::std::os::raw::c_char,
    pub fn_aux: *mut ::std::os::raw::c_char,
    pub fp: htsFile__bindgen_ty_1,
    pub state: *mut ::std::os::raw::c_void,
    pub format: htsFormat,
    pub idx: *mut hts_idx_t,
    pub fnidx: *const ::std::os::raw::c_char,
    pub bam_header: *mut sam_hdr_t,
    pub filter: *mut hts_filter_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union htsFile__bindgen_ty_1 {
    pub bgzf: *mut BGZF,
    pub cram: *mut cram_fd,
    pub hfile: *mut hFILE,
}
#[test]
fn bindgen_test_layout_htsFile__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<htsFile__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(htsFile__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<htsFile__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(htsFile__bindgen_ty_1))
    );
    fn test_field_bgzf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<htsFile__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bgzf) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(htsFile__bindgen_ty_1),
                "::",
                stringify!(bgzf)
            )
        );
    }
    test_field_bgzf();
    fn test_field_cram() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<htsFile__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cram) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(htsFile__bindgen_ty_1),
                "::",
                stringify!(cram)
            )
        );
    }
    test_field_cram();
    fn test_field_hfile() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<htsFile__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hfile) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(htsFile__bindgen_ty_1),
                "::",
                stringify!(hfile)
            )
        );
    }
    test_field_hfile();
}
#[test]
fn bindgen_test_layout_htsFile() {
    assert_eq!(
        ::std::mem::size_of::<htsFile>(),
        136usize,
        concat!("Size of: ", stringify!(htsFile))
    );
    assert_eq!(
        ::std::mem::align_of::<htsFile>(),
        8usize,
        concat!("Alignment of ", stringify!(htsFile))
    );
    fn test_field_lineno() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<htsFile>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lineno) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(htsFile),
                "::",
                stringify!(lineno)
            )
        );
    }
    test_field_lineno();
    fn test_field_line() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<htsFile>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).line) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(htsFile),
                "::",
                stringify!(line)
            )
        );
    }
    test_field_line();
    fn test_field_fn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<htsFile>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fn_) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(htsFile),
                "::",
                stringify!(fn_)
            )
        );
    }
    test_field_fn();
    fn test_field_fn_aux() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<htsFile>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fn_aux) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(htsFile),
                "::",
                stringify!(fn_aux)
            )
        );
    }
    test_field_fn_aux();
    fn test_field_fp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<htsFile>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fp) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(htsFile),
                "::",
                stringify!(fp)
            )
        );
    }
    test_field_fp();
    fn test_field_state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<htsFile>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(htsFile),
                "::",
                stringify!(state)
            )
        );
    }
    test_field_state();
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<htsFile>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(htsFile),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
    fn test_field_idx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<htsFile>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).idx) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(htsFile),
                "::",
                stringify!(idx)
            )
        );
    }
    test_field_idx();
    fn test_field_fnidx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<htsFile>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fnidx) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(htsFile),
                "::",
                stringify!(fnidx)
            )
        );
    }
    test_field_fnidx();
    fn test_field_bam_header() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<htsFile>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bam_header) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(htsFile),
                "::",
                stringify!(bam_header)
            )
        );
    }
    test_field_bam_header();
    fn test_field_filter() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<htsFile>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filter) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(htsFile),
                "::",
                stringify!(filter)
            )
        );
    }
    test_field_filter();
}
impl htsFile {
    #[inline]
    pub fn is_bin(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_bin(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_write(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_write(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_be(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_be(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_cram(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_cram(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_bgzf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_bgzf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dummy(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_dummy(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_bin: u32,
        is_write: u32,
        is_be: u32,
        is_cram: u32,
        is_bgzf: u32,
        dummy: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_bin: u32 = unsafe { ::std::mem::transmute(is_bin) };
            is_bin as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_write: u32 = unsafe { ::std::mem::transmute(is_write) };
            is_write as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let is_be: u32 = unsafe { ::std::mem::transmute(is_be) };
            is_be as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_cram: u32 = unsafe { ::std::mem::transmute(is_cram) };
            is_cram as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_bgzf: u32 = unsafe { ::std::mem::transmute(is_bgzf) };
            is_bgzf as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let dummy: u32 = unsafe { ::std::mem::transmute(dummy) };
            dummy as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct htsThreadPool {
    pub pool: *mut hts_tpool,
    pub qsize: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_htsThreadPool() {
    assert_eq!(
        ::std::mem::size_of::<htsThreadPool>(),
        16usize,
        concat!("Size of: ", stringify!(htsThreadPool))
    );
    assert_eq!(
        ::std::mem::align_of::<htsThreadPool>(),
        8usize,
        concat!("Alignment of ", stringify!(htsThreadPool))
    );
    fn test_field_pool() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<htsThreadPool>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(htsThreadPool),
                "::",
                stringify!(pool)
            )
        );
    }
    test_field_pool();
    fn test_field_qsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<htsThreadPool>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).qsize) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(htsThreadPool),
                "::",
                stringify!(qsize)
            )
        );
    }
    test_field_qsize();
}
pub const sam_fields_SAM_QNAME: sam_fields = 1;
pub const sam_fields_SAM_FLAG: sam_fields = 2;
pub const sam_fields_SAM_RNAME: sam_fields = 4;
pub const sam_fields_SAM_POS: sam_fields = 8;
pub const sam_fields_SAM_MAPQ: sam_fields = 16;
pub const sam_fields_SAM_CIGAR: sam_fields = 32;
pub const sam_fields_SAM_RNEXT: sam_fields = 64;
pub const sam_fields_SAM_PNEXT: sam_fields = 128;
pub const sam_fields_SAM_TLEN: sam_fields = 256;
pub const sam_fields_SAM_SEQ: sam_fields = 512;
pub const sam_fields_SAM_QUAL: sam_fields = 1024;
pub const sam_fields_SAM_AUX: sam_fields = 2048;
pub const sam_fields_SAM_RGAUX: sam_fields = 4096;
pub type sam_fields = ::std::os::raw::c_uint;
pub const hts_fmt_option_CRAM_OPT_DECODE_MD: hts_fmt_option = 0;
pub const hts_fmt_option_CRAM_OPT_PREFIX: hts_fmt_option = 1;
pub const hts_fmt_option_CRAM_OPT_VERBOSITY: hts_fmt_option = 2;
pub const hts_fmt_option_CRAM_OPT_SEQS_PER_SLICE: hts_fmt_option = 3;
pub const hts_fmt_option_CRAM_OPT_SLICES_PER_CONTAINER: hts_fmt_option = 4;
pub const hts_fmt_option_CRAM_OPT_RANGE: hts_fmt_option = 5;
pub const hts_fmt_option_CRAM_OPT_VERSION: hts_fmt_option = 6;
pub const hts_fmt_option_CRAM_OPT_EMBED_REF: hts_fmt_option = 7;
pub const hts_fmt_option_CRAM_OPT_IGNORE_MD5: hts_fmt_option = 8;
pub const hts_fmt_option_CRAM_OPT_REFERENCE: hts_fmt_option = 9;
pub const hts_fmt_option_CRAM_OPT_MULTI_SEQ_PER_SLICE: hts_fmt_option = 10;
pub const hts_fmt_option_CRAM_OPT_NO_REF: hts_fmt_option = 11;
pub const hts_fmt_option_CRAM_OPT_USE_BZIP2: hts_fmt_option = 12;
pub const hts_fmt_option_CRAM_OPT_SHARED_REF: hts_fmt_option = 13;
pub const hts_fmt_option_CRAM_OPT_NTHREADS: hts_fmt_option = 14;
pub const hts_fmt_option_CRAM_OPT_THREAD_POOL: hts_fmt_option = 15;
pub const hts_fmt_option_CRAM_OPT_USE_LZMA: hts_fmt_option = 16;
pub const hts_fmt_option_CRAM_OPT_USE_RANS: hts_fmt_option = 17;
pub const hts_fmt_option_CRAM_OPT_REQUIRED_FIELDS: hts_fmt_option = 18;
pub const hts_fmt_option_CRAM_OPT_LOSSY_NAMES: hts_fmt_option = 19;
pub const hts_fmt_option_CRAM_OPT_BASES_PER_SLICE: hts_fmt_option = 20;
pub const hts_fmt_option_CRAM_OPT_STORE_MD: hts_fmt_option = 21;
pub const hts_fmt_option_CRAM_OPT_STORE_NM: hts_fmt_option = 22;
pub const hts_fmt_option_CRAM_OPT_RANGE_NOSEEK: hts_fmt_option = 23;
pub const hts_fmt_option_CRAM_OPT_USE_TOK: hts_fmt_option = 24;
pub const hts_fmt_option_CRAM_OPT_USE_FQZ: hts_fmt_option = 25;
pub const hts_fmt_option_CRAM_OPT_USE_ARITH: hts_fmt_option = 26;
pub const hts_fmt_option_CRAM_OPT_POS_DELTA: hts_fmt_option = 27;
pub const hts_fmt_option_HTS_OPT_COMPRESSION_LEVEL: hts_fmt_option = 100;
pub const hts_fmt_option_HTS_OPT_NTHREADS: hts_fmt_option = 101;
pub const hts_fmt_option_HTS_OPT_THREAD_POOL: hts_fmt_option = 102;
pub const hts_fmt_option_HTS_OPT_CACHE_SIZE: hts_fmt_option = 103;
pub const hts_fmt_option_HTS_OPT_BLOCK_SIZE: hts_fmt_option = 104;
pub const hts_fmt_option_HTS_OPT_FILTER: hts_fmt_option = 105;
pub const hts_fmt_option_HTS_OPT_PROFILE: hts_fmt_option = 106;
pub const hts_fmt_option_FASTQ_OPT_CASAVA: hts_fmt_option = 1000;
pub const hts_fmt_option_FASTQ_OPT_AUX: hts_fmt_option = 1001;
pub const hts_fmt_option_FASTQ_OPT_RNUM: hts_fmt_option = 1002;
pub const hts_fmt_option_FASTQ_OPT_BARCODE: hts_fmt_option = 1003;
pub const hts_fmt_option_FASTQ_OPT_NAME2: hts_fmt_option = 1004;
pub type hts_fmt_option = ::std::os::raw::c_uint;
pub const hts_profile_option_HTS_PROFILE_FAST: hts_profile_option = 0;
pub const hts_profile_option_HTS_PROFILE_NORMAL: hts_profile_option = 1;
pub const hts_profile_option_HTS_PROFILE_SMALL: hts_profile_option = 2;
pub const hts_profile_option_HTS_PROFILE_ARCHIVE: hts_profile_option = 3;
pub type hts_profile_option = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hts_opt {
    pub arg: *mut ::std::os::raw::c_char,
    pub opt: hts_fmt_option,
    pub val: hts_opt__bindgen_ty_1,
    pub next: *mut hts_opt,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hts_opt__bindgen_ty_1 {
    pub i: ::std::os::raw::c_int,
    pub s: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_hts_opt__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hts_opt__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(hts_opt__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hts_opt__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(hts_opt__bindgen_ty_1))
    );
    fn test_field_i() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_opt__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_opt__bindgen_ty_1),
                "::",
                stringify!(i)
            )
        );
    }
    test_field_i();
    fn test_field_s() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_opt__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_opt__bindgen_ty_1),
                "::",
                stringify!(s)
            )
        );
    }
    test_field_s();
}
#[test]
fn bindgen_test_layout_hts_opt() {
    assert_eq!(
        ::std::mem::size_of::<hts_opt>(),
        32usize,
        concat!("Size of: ", stringify!(hts_opt))
    );
    assert_eq!(
        ::std::mem::align_of::<hts_opt>(),
        8usize,
        concat!("Alignment of ", stringify!(hts_opt))
    );
    fn test_field_arg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_opt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arg) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_opt),
                "::",
                stringify!(arg)
            )
        );
    }
    test_field_arg();
    fn test_field_opt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_opt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).opt) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_opt),
                "::",
                stringify!(opt)
            )
        );
    }
    test_field_opt();
    fn test_field_val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_opt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_opt),
                "::",
                stringify!(val)
            )
        );
    }
    test_field_val();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_opt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_opt),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
}
extern "C" {
    pub fn hts_opt_add(
        opts: *mut *mut hts_opt,
        c_arg: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hts_opt_apply(fp: *mut htsFile, opts: *mut hts_opt) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hts_opt_free(opts: *mut hts_opt);
}
extern "C" {
    pub fn hts_parse_format(
        opt: *mut htsFormat,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hts_parse_opt_list(
        opt: *mut htsFormat,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @abstract Table for converting a nucleotide character to 4-bit encoding."]
    #[doc = "The input character may be either an IUPAC ambiguity code, '=' for 0, or"]
    #[doc = "'0'/'1'/'2'/'3' for a result of 1/2/4/8.  The result is encoded as 1/2/4/8"]
    #[doc = "for A/C/G/T or combinations of these bits for ambiguous bases."]
    pub static seq_nt16_table: [::std::os::raw::c_uchar; 256usize];
}
extern "C" {
    #[doc = " @abstract Table for converting a 4-bit encoded nucleotide to an IUPAC"]
    #[doc = "ambiguity code letter (or '=' when given 0)."]
    pub static mut seq_nt16_str: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[doc = " @abstract Table for converting a 4-bit encoded nucleotide to about 2 bits."]
    #[doc = "Returns 0/1/2/3 for 1/2/4/8 (i.e., A/C/G/T), or 4 otherwise (0 or ambiguous)."]
    pub static mut seq_nt16_int: [::std::os::raw::c_int; 0usize];
}
extern "C" {
    #[doc = "@abstract  Get the htslib version number"]
    #[doc = "@return    For released versions, a string like \"N.N[.N]\"; or git describe"]
    #[doc = "output if using a library built within a Git repository."]
    pub fn hts_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @abstract Introspection on the features enabled in htslib"]
    #[doc = ""]
    #[doc = " @return a bitfield of HTS_FEATURE_* macros."]
    pub fn hts_features() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hts_test_feature(id: ::std::os::raw::c_uint) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @abstract Introspection on the features enabled in htslib, string form"]
    #[doc = ""]
    #[doc = " @return a string describing htslib build features"]
    pub fn hts_feature_string() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@abstract    Determine format by peeking at the start of a file"]
    #[doc = "@param fp    File opened for reading, positioned at the beginning"]
    #[doc = "@param fmt   Format structure that will be filled out on return"]
    #[doc = "@return      0 for success, or negative if an error occurred."]
    #[doc = ""]
    #[doc = "Equivalent to hts_detect_format2(fp, NULL, fmt)."]
    pub fn hts_detect_format(fp: *mut hFILE, fmt: *mut htsFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@abstract    Determine format primarily by peeking at the start of a file"]
    #[doc = "@param fp    File opened for reading, positioned at the beginning"]
    #[doc = "@param fname Name of the file, or NULL if not available"]
    #[doc = "@param fmt   Format structure that will be filled out on return"]
    #[doc = "@return      0 for success, or negative if an error occurred."]
    #[doc = "@since       1.15"]
    #[doc = ""]
    #[doc = "Some formats are only recognised if the filename is available and has the"]
    #[doc = "expected extension, as otherwise more generic files may be misrecognised."]
    #[doc = "In particular:"]
    #[doc = "- FASTA/Q indexes must have .fai/.fqi extensions; without this requirement,"]
    #[doc = "some similar BED files would be misrecognised as indexes."]
    pub fn hts_detect_format2(
        fp: *mut hFILE,
        fname: *const ::std::os::raw::c_char,
        fmt: *mut htsFormat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@abstract    Get a human-readable description of the file format"]
    #[doc = "@param fmt   Format structure holding type, version, compression, etc."]
    #[doc = "@return      Description string, to be freed by the caller after use."]
    pub fn hts_format_description(format: *const htsFormat) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@abstract       Open a sequence data (SAM/BAM/CRAM) or variant data (VCF/BCF)"]
    #[doc = "or possibly-compressed textual line-orientated file"]
    #[doc = "@param fn       The file name or \"-\" for stdin/stdout. For indexed files"]
    #[doc = "with a non-standard naming, the file name can include the"]
    #[doc = "name of the index file delimited with HTS_IDX_DELIM"]
    #[doc = "@param mode     Mode matching / [rwa][bcefFguxz0-9]* /"]
    #[doc = "@discussion"]
    #[doc = "With 'r' opens for reading; any further format mode letters are ignored"]
    #[doc = "as the format is detected by checking the first few bytes or BGZF blocks"]
    #[doc = "of the file.  With 'w' or 'a' opens for writing or appending, with format"]
    #[doc = "specifier letters:"]
    #[doc = "b  binary format (BAM, BCF, etc) rather than text (SAM, VCF, etc)"]
    #[doc = "c  CRAM format"]
    #[doc = "f  FASTQ format"]
    #[doc = "F  FASTA format"]
    #[doc = "g  gzip compressed"]
    #[doc = "u  uncompressed"]
    #[doc = "z  bgzf compressed"]
    #[doc = "[0-9]  zlib compression level"]
    #[doc = "and with non-format option letters (for any of 'r'/'w'/'a'):"]
    #[doc = "e  close the file on exec(2) (opens with O_CLOEXEC, where supported)"]
    #[doc = "x  create the file exclusively (opens with O_EXCL, where supported)"]
    #[doc = "Note that there is a distinction between 'u' and '0': the first yields"]
    #[doc = "plain uncompressed output whereas the latter outputs uncompressed data"]
    #[doc = "wrapped in the zlib format."]
    #[doc = "@example"]
    #[doc = "[rw]b  .. compressed BCF, BAM, FAI"]
    #[doc = "[rw]bu .. uncompressed BCF"]
    #[doc = "[rw]z  .. compressed VCF"]
    #[doc = "[rw]   .. uncompressed VCF"]
    pub fn hts_open(
        fn_: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut htsFile;
}
extern "C" {
    #[doc = "@abstract       Open a SAM/BAM/CRAM/VCF/BCF/etc file"]
    #[doc = "@param fn       The file name or \"-\" for stdin/stdout"]
    #[doc = "@param mode     Open mode, as per hts_open()"]
    #[doc = "@param fmt      Optional format specific parameters"]
    #[doc = "@discussion"]
    #[doc = "See hts_open() for description of fn and mode."]
    #[doc = "Opts contains a format string (sam, bam, cram, vcf, bcf) which will,"]
    #[doc = "if defined, override mode.  Opts also contains a linked list of hts_opt"]
    #[doc = "structures to apply to the open file handle.  These can contain things"]
    #[doc = "like pointers to the reference or information on compression levels,"]
    #[doc = "block sizes, etc."]
    pub fn hts_open_format(
        fn_: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
        fmt: *const htsFormat,
    ) -> *mut htsFile;
}
extern "C" {
    #[doc = "@abstract       Open an existing stream as a SAM/BAM/CRAM/VCF/BCF/etc file"]
    #[doc = "@param fn       The already-open file handle"]
    #[doc = "@param mode     Open mode, as per hts_open()"]
    pub fn hts_hopen(
        fp: *mut hFILE,
        fn_: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut htsFile;
}
extern "C" {
    #[doc = "@abstract  For output streams, flush any buffered data"]
    #[doc = "@param fp  The file handle to be flushed"]
    #[doc = "@return    0 for success, or negative if an error occurred."]
    #[doc = "@since     1.14"]
    pub fn hts_flush(fp: *mut htsFile) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@abstract  Close a file handle, flushing buffered data for output streams"]
    #[doc = "@param fp  The file handle to be closed"]
    #[doc = "@return    0 for success, or negative if an error occurred."]
    pub fn hts_close(fp: *mut htsFile) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@abstract  Returns the file's format information"]
    #[doc = "@param fp  The file handle"]
    #[doc = "@return    Read-only pointer to the file's htsFormat."]
    pub fn hts_get_format(fp: *mut htsFile) -> *const htsFormat;
}
extern "C" {
    #[doc = "@ abstract      Returns a string containing the file format extension."]
    #[doc = "@ param format  Format structure containing the file type."]
    #[doc = "@ return        A string (\"sam\", \"bam\", etc) or \"?\" for unknown formats."]
    pub fn hts_format_file_extension(format: *const htsFormat) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@abstract  Sets a specified CRAM option on the open file handle."]
    #[doc = "@param fp  The file handle open the open file."]
    #[doc = "@param opt The CRAM_OPT_* option."]
    #[doc = "@param ... Optional arguments, dependent on the option used."]
    #[doc = "@return    0 for success, or negative if an error occurred."]
    pub fn hts_set_opt(fp: *mut htsFile, opt: hts_fmt_option, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@abstract         Read a line (and its \\n or \\r\\n terminator) from a file"]
    #[doc = "@param fp         The file handle"]
    #[doc = "@param delimiter  Unused, but must be '\\n' (or KS_SEP_LINE)"]
    #[doc = "@param str        The line (not including the terminator) is written here"]
    #[doc = "@return           Length of the string read (capped at INT_MAX);"]
    #[doc = "-1 on end-of-file; <= -2 on error"]
    pub fn hts_getline(
        fp: *mut htsFile,
        delimiter: ::std::os::raw::c_int,
        str_: *mut kstring_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hts_readlines(
        fn_: *const ::std::os::raw::c_char,
        _n: *mut ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@abstract       Parse comma-separated list or read list from a file"]
    #[doc = "@param list     File name or comma-separated list"]
    #[doc = "@param is_file"]
    #[doc = "@param _n       Size of the output array (number of items read)"]
    #[doc = "@return         NULL on failure or pointer to newly allocated array of"]
    #[doc = "strings"]
    pub fn hts_readlist(
        fn_: *const ::std::os::raw::c_char,
        is_file: ::std::os::raw::c_int,
        _n: *mut ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@abstract  Create extra threads to aid compress/decompression for this file"]
    #[doc = "@param fp  The file handle"]
    #[doc = "@param n   The number of worker threads to create"]
    #[doc = "@return    0 for success, or negative if an error occurred."]
    #[doc = "@notes     This function creates non-shared threads for use solely by fp."]
    #[doc = "The hts_set_thread_pool function is the recommended alternative."]
    pub fn hts_set_threads(fp: *mut htsFile, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@abstract  Create extra threads to aid compress/decompression for this file"]
    #[doc = "@param fp  The file handle"]
    #[doc = "@param p   A pool of worker threads, previously allocated by hts_create_threads()."]
    #[doc = "@return    0 for success, or negative if an error occurred."]
    pub fn hts_set_thread_pool(fp: *mut htsFile, p: *mut htsThreadPool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@abstract  Adds a cache of decompressed blocks, potentially speeding up seeks."]
    #[doc = "This may not work for all file types (currently it is bgzf only)."]
    #[doc = "@param fp  The file handle"]
    #[doc = "@param n   The size of cache, in bytes"]
    pub fn hts_set_cache_size(fp: *mut htsFile, n: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "@abstract  Set .fai filename for a file opened for reading"]
    #[doc = "@return    0 for success, negative on failure"]
    #[doc = "@discussion"]
    #[doc = "Called before *_hdr_read(), this provides the name of a .fai file"]
    #[doc = "used to provide a reference list if the htsFile contains no @SQ headers."]
    pub fn hts_set_fai_filename(
        fp: *mut htsFile,
        fn_aux: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@abstract  Sets a filter expression"]
    #[doc = "@return    0 for success, negative on failure"]
    #[doc = "@discussion"]
    #[doc = "To clear an existing filter, specifying expr as NULL."]
    pub fn hts_set_filter_expression(
        fp: *mut htsFile,
        expr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@abstract  Determine whether a given htsFile contains a valid EOF block"]
    #[doc = "@return    3 for a non-EOF checkable filetype;"]
    #[doc = "2 for an unseekable file type where EOF cannot be checked;"]
    #[doc = "1 for a valid EOF block;"]
    #[doc = "0 for if the EOF marker is absent when it should be present;"]
    #[doc = "-1 (with errno set) on failure"]
    #[doc = "@discussion"]
    #[doc = "Check if the BGZF end-of-file (EOF) marker is present"]
    pub fn hts_check_EOF(fp: *mut htsFile) -> ::std::os::raw::c_int;
}
pub type hts_pos_t = i64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hts_pair_pos_t {
    pub beg: hts_pos_t,
    pub end: hts_pos_t,
}
#[test]
fn bindgen_test_layout_hts_pair_pos_t() {
    assert_eq!(
        ::std::mem::size_of::<hts_pair_pos_t>(),
        16usize,
        concat!("Size of: ", stringify!(hts_pair_pos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hts_pair_pos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(hts_pair_pos_t))
    );
    fn test_field_beg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_pair_pos_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).beg) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_pair_pos_t),
                "::",
                stringify!(beg)
            )
        );
    }
    test_field_beg();
    fn test_field_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_pair_pos_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_pair_pos_t),
                "::",
                stringify!(end)
            )
        );
    }
    test_field_end();
}
pub type hts_pair32_t = hts_pair_pos_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hts_pair64_t {
    pub u: u64,
    pub v: u64,
}
#[test]
fn bindgen_test_layout_hts_pair64_t() {
    assert_eq!(
        ::std::mem::size_of::<hts_pair64_t>(),
        16usize,
        concat!("Size of: ", stringify!(hts_pair64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hts_pair64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(hts_pair64_t))
    );
    fn test_field_u() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_pair64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_pair64_t),
                "::",
                stringify!(u)
            )
        );
    }
    test_field_u();
    fn test_field_v() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_pair64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_pair64_t),
                "::",
                stringify!(v)
            )
        );
    }
    test_field_v();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hts_pair64_max_t {
    pub u: u64,
    pub v: u64,
    pub max: u64,
}
#[test]
fn bindgen_test_layout_hts_pair64_max_t() {
    assert_eq!(
        ::std::mem::size_of::<hts_pair64_max_t>(),
        24usize,
        concat!("Size of: ", stringify!(hts_pair64_max_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hts_pair64_max_t>(),
        8usize,
        concat!("Alignment of ", stringify!(hts_pair64_max_t))
    );
    fn test_field_u() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_pair64_max_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_pair64_max_t),
                "::",
                stringify!(u)
            )
        );
    }
    test_field_u();
    fn test_field_v() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_pair64_max_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_pair64_max_t),
                "::",
                stringify!(v)
            )
        );
    }
    test_field_v();
    fn test_field_max() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_pair64_max_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_pair64_max_t),
                "::",
                stringify!(max)
            )
        );
    }
    test_field_max();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hts_reglist_t {
    pub reg: *const ::std::os::raw::c_char,
    pub intervals: *mut hts_pair_pos_t,
    pub tid: ::std::os::raw::c_int,
    pub count: u32,
    pub min_beg: hts_pos_t,
    pub max_end: hts_pos_t,
}
#[test]
fn bindgen_test_layout_hts_reglist_t() {
    assert_eq!(
        ::std::mem::size_of::<hts_reglist_t>(),
        40usize,
        concat!("Size of: ", stringify!(hts_reglist_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hts_reglist_t>(),
        8usize,
        concat!("Alignment of ", stringify!(hts_reglist_t))
    );
    fn test_field_reg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_reglist_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reg) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_reglist_t),
                "::",
                stringify!(reg)
            )
        );
    }
    test_field_reg();
    fn test_field_intervals() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_reglist_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).intervals) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_reglist_t),
                "::",
                stringify!(intervals)
            )
        );
    }
    test_field_intervals();
    fn test_field_tid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_reglist_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tid) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_reglist_t),
                "::",
                stringify!(tid)
            )
        );
    }
    test_field_tid();
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_reglist_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_reglist_t),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
    fn test_field_min_beg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_reglist_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).min_beg) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_reglist_t),
                "::",
                stringify!(min_beg)
            )
        );
    }
    test_field_min_beg();
    fn test_field_max_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_reglist_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_end) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_reglist_t),
                "::",
                stringify!(max_end)
            )
        );
    }
    test_field_max_end();
}
pub type hts_readrec_func = ::std::option::Option<
    unsafe extern "C" fn(
        fp: *mut BGZF,
        data: *mut ::std::os::raw::c_void,
        r: *mut ::std::os::raw::c_void,
        tid: *mut ::std::os::raw::c_int,
        beg: *mut hts_pos_t,
        end: *mut hts_pos_t,
    ) -> ::std::os::raw::c_int,
>;
pub type hts_seek_func = ::std::option::Option<
    unsafe extern "C" fn(
        fp: *mut ::std::os::raw::c_void,
        offset: i64,
        where_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type hts_tell_func =
    ::std::option::Option<unsafe extern "C" fn(fp: *mut ::std::os::raw::c_void) -> i64>;
#[doc = " @brief File iterator that can handle multiple target regions."]
#[doc = " This structure should be considered opaque by end users."]
#[doc = " It does both the stepping inside the file and the filtering of alignments."]
#[doc = " It can operate in single or multi-region mode, and depending on this,"]
#[doc = " it uses different fields."]
#[doc = ""]
#[doc = " read_rest (1) - read everything from the current offset, without filtering"]
#[doc = " finished  (1) - no more iterations"]
#[doc = " is_cram   (1) - current file has CRAM format"]
#[doc = " nocoor    (1) - read all unmapped reads"]
#[doc = ""]
#[doc = " multi     (1) - multi-region moode"]
#[doc = " reg_list  - List of target regions"]
#[doc = " n_reg     - Size of the above list"]
#[doc = " curr_reg  - List index of the current region of search"]
#[doc = " curr_intv - Interval index inside the current region; points to a (beg, end)"]
#[doc = " end       - Used for CRAM files, to preserve the max end coordinate"]
#[doc = ""]
#[doc = " multi     (0) - single-region mode"]
#[doc = " tid       - Reference id of the target region"]
#[doc = " beg       - Start position of the target region"]
#[doc = " end       - End position of the target region"]
#[doc = ""]
#[doc = " Common fields:"]
#[doc = " off        - List of file offsets computed from the index"]
#[doc = " n_off      - Size of the above list"]
#[doc = " i          - List index of the current file offset"]
#[doc = " curr_off   - File offset for the next file read"]
#[doc = " curr_tid   - Reference id of the current alignment"]
#[doc = " curr_beg   - Start position of the current alignment"]
#[doc = " curr_end   - End position of the current alignment"]
#[doc = " nocoor_off - File offset where the unmapped reads start"]
#[doc = ""]
#[doc = " readrec    - File specific function that reads an alignment"]
#[doc = " seek       - File specific function for changing the file offset"]
#[doc = " tell       - File specific function for indicating the file offset"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hts_itr_t {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub tid: ::std::os::raw::c_int,
    pub n_off: ::std::os::raw::c_int,
    pub i: ::std::os::raw::c_int,
    pub n_reg: ::std::os::raw::c_int,
    pub beg: hts_pos_t,
    pub end: hts_pos_t,
    pub reg_list: *mut hts_reglist_t,
    pub curr_tid: ::std::os::raw::c_int,
    pub curr_reg: ::std::os::raw::c_int,
    pub curr_intv: ::std::os::raw::c_int,
    pub curr_beg: hts_pos_t,
    pub curr_end: hts_pos_t,
    pub curr_off: u64,
    pub nocoor_off: u64,
    pub off: *mut hts_pair64_max_t,
    pub readrec: hts_readrec_func,
    pub seek: hts_seek_func,
    pub tell: hts_tell_func,
    pub bins: hts_itr_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hts_itr_t__bindgen_ty_1 {
    pub n: ::std::os::raw::c_int,
    pub m: ::std::os::raw::c_int,
    pub a: *mut ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_hts_itr_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hts_itr_t__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(hts_itr_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hts_itr_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(hts_itr_t__bindgen_ty_1))
    );
    fn test_field_n() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_itr_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_itr_t__bindgen_ty_1),
                "::",
                stringify!(n)
            )
        );
    }
    test_field_n();
    fn test_field_m() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_itr_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_itr_t__bindgen_ty_1),
                "::",
                stringify!(m)
            )
        );
    }
    test_field_m();
    fn test_field_a() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_itr_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_itr_t__bindgen_ty_1),
                "::",
                stringify!(a)
            )
        );
    }
    test_field_a();
}
#[test]
fn bindgen_test_layout_hts_itr_t() {
    assert_eq!(
        ::std::mem::size_of::<hts_itr_t>(),
        144usize,
        concat!("Size of: ", stringify!(hts_itr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hts_itr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(hts_itr_t))
    );
    fn test_field_tid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_itr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tid) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_itr_t),
                "::",
                stringify!(tid)
            )
        );
    }
    test_field_tid();
    fn test_field_n_off() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_itr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n_off) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_itr_t),
                "::",
                stringify!(n_off)
            )
        );
    }
    test_field_n_off();
    fn test_field_i() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_itr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_itr_t),
                "::",
                stringify!(i)
            )
        );
    }
    test_field_i();
    fn test_field_n_reg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_itr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n_reg) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_itr_t),
                "::",
                stringify!(n_reg)
            )
        );
    }
    test_field_n_reg();
    fn test_field_beg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_itr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).beg) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_itr_t),
                "::",
                stringify!(beg)
            )
        );
    }
    test_field_beg();
    fn test_field_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_itr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_itr_t),
                "::",
                stringify!(end)
            )
        );
    }
    test_field_end();
    fn test_field_reg_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_itr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reg_list) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_itr_t),
                "::",
                stringify!(reg_list)
            )
        );
    }
    test_field_reg_list();
    fn test_field_curr_tid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_itr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).curr_tid) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_itr_t),
                "::",
                stringify!(curr_tid)
            )
        );
    }
    test_field_curr_tid();
    fn test_field_curr_reg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_itr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).curr_reg) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_itr_t),
                "::",
                stringify!(curr_reg)
            )
        );
    }
    test_field_curr_reg();
    fn test_field_curr_intv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_itr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).curr_intv) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_itr_t),
                "::",
                stringify!(curr_intv)
            )
        );
    }
    test_field_curr_intv();
    fn test_field_curr_beg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_itr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).curr_beg) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_itr_t),
                "::",
                stringify!(curr_beg)
            )
        );
    }
    test_field_curr_beg();
    fn test_field_curr_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_itr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).curr_end) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_itr_t),
                "::",
                stringify!(curr_end)
            )
        );
    }
    test_field_curr_end();
    fn test_field_curr_off() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_itr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).curr_off) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_itr_t),
                "::",
                stringify!(curr_off)
            )
        );
    }
    test_field_curr_off();
    fn test_field_nocoor_off() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_itr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nocoor_off) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_itr_t),
                "::",
                stringify!(nocoor_off)
            )
        );
    }
    test_field_nocoor_off();
    fn test_field_off() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_itr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).off) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_itr_t),
                "::",
                stringify!(off)
            )
        );
    }
    test_field_off();
    fn test_field_readrec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_itr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).readrec) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_itr_t),
                "::",
                stringify!(readrec)
            )
        );
    }
    test_field_readrec();
    fn test_field_seek() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_itr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_itr_t),
                "::",
                stringify!(seek)
            )
        );
    }
    test_field_seek();
    fn test_field_tell() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_itr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tell) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_itr_t),
                "::",
                stringify!(tell)
            )
        );
    }
    test_field_tell();
    fn test_field_bins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_itr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bins) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_itr_t),
                "::",
                stringify!(bins)
            )
        );
    }
    test_field_bins();
}
impl hts_itr_t {
    #[inline]
    pub fn read_rest(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_read_rest(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn finished(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_finished(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_cram(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_cram(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nocoor(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nocoor(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn multi(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_multi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dummy(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_dummy(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        read_rest: u32,
        finished: u32,
        is_cram: u32,
        nocoor: u32,
        multi: u32,
        dummy: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let read_rest: u32 = unsafe { ::std::mem::transmute(read_rest) };
            read_rest as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let finished: u32 = unsafe { ::std::mem::transmute(finished) };
            finished as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let is_cram: u32 = unsafe { ::std::mem::transmute(is_cram) };
            is_cram as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let nocoor: u32 = unsafe { ::std::mem::transmute(nocoor) };
            nocoor as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let multi: u32 = unsafe { ::std::mem::transmute(multi) };
            multi as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let dummy: u32 = unsafe { ::std::mem::transmute(dummy) };
            dummy as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief File iterator that can handle multiple target regions."]
#[doc = " This structure should be considered opaque by end users."]
#[doc = " It does both the stepping inside the file and the filtering of alignments."]
#[doc = " It can operate in single or multi-region mode, and depending on this,"]
#[doc = " it uses different fields."]
#[doc = ""]
#[doc = " read_rest (1) - read everything from the current offset, without filtering"]
#[doc = " finished  (1) - no more iterations"]
#[doc = " is_cram   (1) - current file has CRAM format"]
#[doc = " nocoor    (1) - read all unmapped reads"]
#[doc = ""]
#[doc = " multi     (1) - multi-region moode"]
#[doc = " reg_list  - List of target regions"]
#[doc = " n_reg     - Size of the above list"]
#[doc = " curr_reg  - List index of the current region of search"]
#[doc = " curr_intv - Interval index inside the current region; points to a (beg, end)"]
#[doc = " end       - Used for CRAM files, to preserve the max end coordinate"]
#[doc = ""]
#[doc = " multi     (0) - single-region mode"]
#[doc = " tid       - Reference id of the target region"]
#[doc = " beg       - Start position of the target region"]
#[doc = " end       - End position of the target region"]
#[doc = ""]
#[doc = " Common fields:"]
#[doc = " off        - List of file offsets computed from the index"]
#[doc = " n_off      - Size of the above list"]
#[doc = " i          - List index of the current file offset"]
#[doc = " curr_off   - File offset for the next file read"]
#[doc = " curr_tid   - Reference id of the current alignment"]
#[doc = " curr_beg   - Start position of the current alignment"]
#[doc = " curr_end   - End position of the current alignment"]
#[doc = " nocoor_off - File offset where the unmapped reads start"]
#[doc = ""]
#[doc = " readrec    - File specific function that reads an alignment"]
#[doc = " seek       - File specific function for changing the file offset"]
#[doc = " tell       - File specific function for indicating the file offset"]
pub type hts_itr_multi_t = hts_itr_t;
extern "C" {
    #[doc = " Create a BAI/CSI/TBI type index structure"]
    #[doc = "** @param n          Initial number of targets"]
    #[doc = "@param fmt        Format, one of HTS_FMT_CSI, HTS_FMT_BAI or HTS_FMT_TBI"]
    #[doc = "@param offset0    Initial file offset"]
    #[doc = "@param min_shift  Number of bits for the minimal interval"]
    #[doc = "@param n_lvls     Number of levels in the binning index"]
    #[doc = "@return An initialised hts_idx_t struct on success; NULL on failure"]
    #[doc = ""]
    #[doc = "The struct returned by a successful call should be freed via hts_idx_destroy()"]
    #[doc = "when it is no longer needed."]
    #[doc = "*/"]
    pub fn hts_idx_init(
        n: ::std::os::raw::c_int,
        fmt: ::std::os::raw::c_int,
        offset0: u64,
        min_shift: ::std::os::raw::c_int,
        n_lvls: ::std::os::raw::c_int,
    ) -> *mut hts_idx_t;
}
extern "C" {
    #[doc = " Free a BAI/CSI/TBI type index"]
    #[doc = "** @param idx   Index structure to free"]
    #[doc = "*/"]
    pub fn hts_idx_destroy(idx: *mut hts_idx_t);
}
extern "C" {
    #[doc = " Push an index entry"]
    #[doc = "** @param idx        Index"]
    #[doc = "@param tid        Target id"]
    #[doc = "@param beg        Range start (zero-based)"]
    #[doc = "@param end        Range end (zero-based, half-open)"]
    #[doc = "@param offset     File offset"]
    #[doc = "@param is_mapped  Range corresponds to a mapped read"]
    #[doc = "@return 0 on success; -1 on failure"]
    #[doc = ""]
    #[doc = "The @p is_mapped parameter is used to update the n_mapped / n_unmapped counts"]
    #[doc = "stored in the meta-data bin."]
    #[doc = "*/"]
    pub fn hts_idx_push(
        idx: *mut hts_idx_t,
        tid: ::std::os::raw::c_int,
        beg: hts_pos_t,
        end: hts_pos_t,
        offset: u64,
        is_mapped: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Finish building an index"]
    #[doc = "** @param idx          Index"]
    #[doc = "@param final_offset Last file offset"]
    #[doc = "@return 0 on success; non-zero on failure."]
    #[doc = "*/"]
    pub fn hts_idx_finish(idx: *mut hts_idx_t, final_offset: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns index format"]
    #[doc = "** @param idx   Index"]
    #[doc = "@return One of HTS_FMT_CSI, HTS_FMT_BAI or HTS_FMT_TBI"]
    #[doc = "*/"]
    pub fn hts_idx_fmt(idx: *mut hts_idx_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add name to TBI index meta-data"]
    #[doc = "** @param idx   Index"]
    #[doc = "@param tid   Target identifier"]
    #[doc = "@param name  Target name"]
    #[doc = "@return Index number of name in names list on success; -1 on failure."]
    #[doc = "*/"]
    pub fn hts_idx_tbi_name(
        idx: *mut hts_idx_t,
        tid: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Save an index to a file"]
    #[doc = "** @param idx  Index to be written"]
    #[doc = "@param fn   Input BAM/BCF/etc filename, to which .bai/.csi/etc will be added"]
    #[doc = "@param fmt  One of the HTS_FMT_* index formats"]
    #[doc = "@return  0 if successful, or negative if an error occurred."]
    #[doc = "*/"]
    pub fn hts_idx_save(
        idx: *const hts_idx_t,
        fn_: *const ::std::os::raw::c_char,
        fmt: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Save an index to a specific file"]
    #[doc = "** @param idx    Index to be written"]
    #[doc = "@param fn     Input BAM/BCF/etc filename"]
    #[doc = "@param fnidx  Output filename, or NULL to add .bai/.csi/etc to @a fn"]
    #[doc = "@param fmt    One of the HTS_FMT_* index formats"]
    #[doc = "@return  0 if successful, or negative if an error occurred."]
    #[doc = "*/"]
    pub fn hts_idx_save_as(
        idx: *const hts_idx_t,
        fn_: *const ::std::os::raw::c_char,
        fnidx: *const ::std::os::raw::c_char,
        fmt: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Load an index file"]
    #[doc = "** @param fn   BAM/BCF/etc filename, to which .bai/.csi/etc will be added or"]
    #[doc = "the extension substituted, to search for an existing index file."]
    #[doc = "In case of a non-standard naming, the file name can include the"]
    #[doc = "name of the index file delimited with HTS_IDX_DELIM."]
    #[doc = "@param fmt  One of the HTS_FMT_* index formats"]
    #[doc = "@return  The index, or NULL if an error occurred."]
    #[doc = ""]
    #[doc = "If @p fn contains the string \"##idx##\" (HTS_IDX_DELIM), the part before"]
    #[doc = "the delimiter will be used as the name of the data file and the part after"]
    #[doc = "it will be used as the name of the index."]
    #[doc = ""]
    #[doc = "Otherwise, this function tries to work out the index name as follows:"]
    #[doc = ""]
    #[doc = "It will try appending \".csi\" to @p fn"]
    #[doc = "It will try substituting an existing suffix (e.g. .bam, .vcf) with \".csi\""]
    #[doc = "Then, if @p fmt is HTS_FMT_BAI:"]
    #[doc = "It will try appending \".bai\" to @p fn"]
    #[doc = "To will substituting the existing suffix (e.g. .bam) with \".bai\""]
    #[doc = "else if @p fmt is HTS_FMT_TBI:"]
    #[doc = "It will try appending \".tbi\" to @p fn"]
    #[doc = "To will substituting the existing suffix (e.g. .vcf) with \".tbi\""]
    #[doc = ""]
    #[doc = "If the index file is remote (served over a protocol like https), first a check"]
    #[doc = "is made to see is a locally cached copy is available.  This is done for all"]
    #[doc = "of the possible names listed above.  If a cached copy is not available then"]
    #[doc = "the index will be downloaded and stored in the current working directory,"]
    #[doc = "with the same name as the remote index."]
    #[doc = ""]
    #[doc = "Equivalent to hts_idx_load3(fn, NULL, fmt, HTS_IDX_SAVE_REMOTE);"]
    #[doc = "*/"]
    pub fn hts_idx_load(
        fn_: *const ::std::os::raw::c_char,
        fmt: ::std::os::raw::c_int,
    ) -> *mut hts_idx_t;
}
extern "C" {
    #[doc = " Load a specific index file"]
    #[doc = "** @param fn     Input BAM/BCF/etc filename"]
    #[doc = "@param fnidx  The input index filename"]
    #[doc = "@return  The index, or NULL if an error occurred."]
    #[doc = ""]
    #[doc = "Equivalent to hts_idx_load3(fn, fnidx, 0, 0);"]
    #[doc = ""]
    #[doc = "This function will not attempt to save index files locally."]
    #[doc = "*/"]
    pub fn hts_idx_load2(
        fn_: *const ::std::os::raw::c_char,
        fnidx: *const ::std::os::raw::c_char,
    ) -> *mut hts_idx_t;
}
extern "C" {
    #[doc = " Load a specific index file"]
    #[doc = "** @param fn     Input BAM/BCF/etc filename"]
    #[doc = "@param fnidx  The input index filename"]
    #[doc = "@param fmt    One of the HTS_FMT_* index formats"]
    #[doc = "@param flags  Flags to alter behaviour (see description)"]
    #[doc = "@return  The index, or NULL if an error occurred."]
    #[doc = ""]
    #[doc = "If @p fnidx is NULL, the index name will be derived from @p fn in the"]
    #[doc = "same way as hts_idx_load()."]
    #[doc = ""]
    #[doc = "If @p fnidx is not NULL, @p fmt is ignored."]
    #[doc = ""]
    #[doc = "The @p flags parameter can be set to a combination of the following"]
    #[doc = "values:"]
    #[doc = ""]
    #[doc = "HTS_IDX_SAVE_REMOTE   Save a local copy of any remote indexes"]
    #[doc = "HTS_IDX_SILENT_FAIL   Fail silently if the index is not present"]
    #[doc = ""]
    #[doc = "The index struct returned by a successful call should be freed"]
    #[doc = "via hts_idx_destroy() when it is no longer needed."]
    #[doc = "*/"]
    pub fn hts_idx_load3(
        fn_: *const ::std::os::raw::c_char,
        fnidx: *const ::std::os::raw::c_char,
        fmt: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> *mut hts_idx_t;
}
#[doc = ""]
pub type hts_id2name_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char,
>;
extern "C" {
    #[doc = " Get extra index meta-data"]
    #[doc = "** @param idx    The index"]
    #[doc = "@param l_meta Pointer to where the length of the extra data is stored"]
    #[doc = "@return Pointer to the extra data if present; NULL otherwise"]
    #[doc = ""]
    #[doc = "Indexes (both .tbi and .csi) made by tabix include extra data about"]
    #[doc = "the indexed file.  The returns a pointer to this data.  Note that the"]
    #[doc = "data is stored exactly as it is in the index.  Callers need to interpret"]
    #[doc = "the results themselves, including knowing what sort of data to expect;"]
    #[doc = "byte swapping etc."]
    #[doc = "*/"]
    pub fn hts_idx_get_meta(idx: *mut hts_idx_t, l_meta: *mut u32) -> *mut u8;
}
extern "C" {
    #[doc = " Set extra index meta-data"]
    #[doc = "** @param idx     The index"]
    #[doc = "@param l_meta  Length of data"]
    #[doc = "@param meta    Pointer to the extra data"]
    #[doc = "@param is_copy If not zero, a copy of the data is taken"]
    #[doc = "@return 0 on success; -1 on failure (out of memory)."]
    #[doc = ""]
    #[doc = "Sets the data that is returned by hts_idx_get_meta()."]
    #[doc = ""]
    #[doc = "If is_copy != 0, a copy of the input data is taken.  If not, ownership of"]
    #[doc = "the data pointed to by *meta passes to the index."]
    #[doc = "*/"]
    pub fn hts_idx_set_meta(
        idx: *mut hts_idx_t,
        l_meta: u32,
        meta: *mut u8,
        is_copy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get number of mapped and unmapped reads from an index"]
    #[doc = "** @param      idx      Index"]
    #[doc = "@param      tid      Target ID"]
    #[doc = "@param[out] mapped   Location to store number of mapped reads"]
    #[doc = "@param[out] unmapped Location to store number of unmapped reads"]
    #[doc = "@return 0 on success; -1 on failure (data not available)"]
    #[doc = ""]
    #[doc = "BAI and CSI indexes store information on the number of reads for each"]
    #[doc = "target that were mapped or unmapped (unmapped reads will generally have"]
    #[doc = "a paired read that is mapped to the target).  This function returns this"]
    #[doc = "information if it is available."]
    #[doc = ""]
    #[doc = "@note Cram CRAI indexes do not include this information."]
    #[doc = "*/"]
    pub fn hts_idx_get_stat(
        idx: *const hts_idx_t,
        tid: ::std::os::raw::c_int,
        mapped: *mut u64,
        unmapped: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the number of unplaced reads from an index"]
    #[doc = "** @param idx    Index"]
    #[doc = "@return Unplaced reads count"]
    #[doc = ""]
    #[doc = "Unplaced reads are not linked to any reference (e.g. RNAME is '*' in SAM"]
    #[doc = "files)."]
    #[doc = "*/"]
    pub fn hts_idx_get_n_no_coor(idx: *const hts_idx_t) -> u64;
}
extern "C" {
    #[doc = " Return a list of target names from an index"]
    #[doc = "** @param      idx    Index"]
    #[doc = "@param[out] n      Location to store the number of targets"]
    #[doc = "@param      getid  Callback function to get the name for a target ID"]
    #[doc = "@param      hdr    Header from indexed file"]
    #[doc = "@return An array of pointers to the names on success; NULL on failure"]
    #[doc = ""]
    #[doc = "@note The names are pointers into the header data structure.  When cleaning"]
    #[doc = "up, only the array should be freed, not the names."]
    #[doc = "*/"]
    pub fn hts_idx_seqnames(
        idx: *const hts_idx_t,
        n: *mut ::std::os::raw::c_int,
        getid: hts_id2name_f,
        hdr: *mut ::std::os::raw::c_void,
    ) -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the number of targets from an index"]
    #[doc = "** @param      idx    Index"]
    #[doc = "@return The number of targets"]
    #[doc = "*/"]
    pub fn hts_idx_nseq(idx: *const hts_idx_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse a numeric string"]
    #[doc = "** The number may be expressed in scientific notation, and optionally may"]
    #[doc = "contain commas in the integer part (before any decimal point or E notation)."]
    #[doc = "@param str     String to be parsed"]
    #[doc = "@param strend  If non-NULL, set on return to point to the first character"]
    #[doc = "in @a str after those forming the parsed number"]
    #[doc = "@param flags   Or'ed-together combination of HTS_PARSE_* flags"]
    #[doc = "@return  Integer value of the parsed number, or 0 if no valid number"]
    #[doc = ""]
    #[doc = "The input string is parsed as: optional whitespace; an optional '+' or"]
    #[doc = "'-' sign; decimal digits possibly including ',' characters (if @a flags"]
    #[doc = "includes HTS_PARSE_THOUSANDS_SEP) and a '.' decimal point; and an optional"]
    #[doc = "case-insensitive suffix, which may be either 'k', 'M', 'G', or scientific"]
    #[doc = "notation consisting of 'e'/'E' followed by an optional '+' or '-' sign and"]
    #[doc = "decimal digits. To be considered a valid numeric value, the main part (not"]
    #[doc = "including any suffix or scientific notation) must contain at least one"]
    #[doc = "digit (either before or after the decimal point)."]
    #[doc = ""]
    #[doc = "When @a strend is NULL, @a str is expected to contain only (optional"]
    #[doc = "whitespace followed by) the numeric value. A warning will be printed"]
    #[doc = "(if hts_verbose is HTS_LOG_WARNING or more) if no valid parsable number"]
    #[doc = "is found or if there are any unused characters after the number."]
    #[doc = ""]
    #[doc = "When @a strend is non-NULL, @a str starts with (optional whitespace"]
    #[doc = "followed by) the numeric value. On return, @a strend is set to point"]
    #[doc = "to the first unused character after the numeric value, or to @a str"]
    #[doc = "if no valid parsable number is found."]
    #[doc = "*/"]
    pub fn hts_parse_decimal(
        str_: *const ::std::os::raw::c_char,
        strend: *mut *mut ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
pub type hts_name2id_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Parse a \"CHR:START-END\"-style region string"]
    #[doc = "** @param str  String to be parsed"]
    #[doc = "@param beg  Set on return to the 0-based start of the region"]
    #[doc = "@param end  Set on return to the 1-based end of the region"]
    #[doc = "@return  Pointer to the colon or '\\0' after the reference sequence name,"]
    #[doc = "or NULL if @a str could not be parsed."]
    #[doc = ""]
    #[doc = "NOTE: For compatibility with hts_parse_reg only."]
    #[doc = "Please use hts_parse_region instead."]
    #[doc = "*/"]
    pub fn hts_parse_reg64(
        str_: *const ::std::os::raw::c_char,
        beg: *mut hts_pos_t,
        end: *mut hts_pos_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Parse a \"CHR:START-END\"-style region string"]
    #[doc = "** @param str  String to be parsed"]
    #[doc = "@param beg  Set on return to the 0-based start of the region"]
    #[doc = "@param end  Set on return to the 1-based end of the region"]
    #[doc = "@return  Pointer to the colon or '\\0' after the reference sequence name,"]
    #[doc = "or NULL if @a str could not be parsed."]
    #[doc = "*/"]
    pub fn hts_parse_reg(
        str_: *const ::std::os::raw::c_char,
        beg: *mut ::std::os::raw::c_int,
        end: *mut ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Parse a \"CHR:START-END\"-style region string"]
    #[doc = "** @param str   String to be parsed"]
    #[doc = "@param tid   Set on return (if not NULL) to be reference index (-1 if invalid)"]
    #[doc = "@param beg   Set on return to the 0-based start of the region"]
    #[doc = "@param end   Set on return to the 1-based end of the region"]
    #[doc = "@param getid Function pointer.  Called if not NULL to set tid."]
    #[doc = "@param hdr   Caller data passed to getid."]
    #[doc = "@param flags Bitwise HTS_PARSE_* flags listed above."]
    #[doc = "@return      Pointer to the byte after the end of the entire region"]
    #[doc = "specifier (including any trailing comma) on success,"]
    #[doc = "or NULL if @a str could not be parsed."]
    #[doc = ""]
    #[doc = "A variant of hts_parse_reg which is reference-id aware.  It uses"]
    #[doc = "the iterator name2id callbacks to validate the region tokenisation works."]
    #[doc = ""]
    #[doc = "This is necessary due to GRCh38 HLA additions which have reference names"]
    #[doc = "like \"HLA-DRB1*12:17\"."]
    #[doc = ""]
    #[doc = "To work around ambiguous parsing issues, eg both \"chr1\" and \"chr1:100-200\""]
    #[doc = "are reference names, quote using curly braces."]
    #[doc = "Thus \"{chr1}:100-200\" and \"{chr1:100-200}\" disambiguate the above example."]
    #[doc = ""]
    #[doc = "Flags are used to control how parsing works, and can be one of the below."]
    #[doc = ""]
    #[doc = "HTS_PARSE_THOUSANDS_SEP:"]
    #[doc = "Ignore commas in numbers.  For example with this flag 1,234,567"]
    #[doc = "is interpreted as 1234567."]
    #[doc = ""]
    #[doc = "HTS_PARSE_LIST:"]
    #[doc = "If present, the region is assmed to be a comma separated list and"]
    #[doc = "position parsing will not contain commas (this implicitly"]
    #[doc = "clears HTS_PARSE_THOUSANDS_SEP in the call to hts_parse_decimal)."]
    #[doc = "On success the return pointer will be the start of the next region, ie"]
    #[doc = "the character after the comma.  (If *ret != '\\0' then the caller can"]
    #[doc = "assume another region is present in the list.)"]
    #[doc = ""]
    #[doc = "If not set then positions may contain commas.  In this case the return"]
    #[doc = "value should point to the end of the string, or NULL on failure."]
    #[doc = ""]
    #[doc = "HTS_PARSE_ONE_COORD:"]
    #[doc = "If present, X:100 is treated as the single base pair region X:100-100."]
    #[doc = "In this case X:-100 is shorthand for X:1-100 and X:100- is X:100-<end>."]
    #[doc = "(This is the standard bcftools region convention.)"]
    #[doc = ""]
    #[doc = "When not set X:100 is considered to be X:100-<end> where <end> is"]
    #[doc = "the end of chromosome X (set to INT_MAX here).  X:100- and X:-100 are"]
    #[doc = "invalid."]
    #[doc = "(This is the standard samtools region convention.)"]
    #[doc = ""]
    #[doc = "Note the supplied string expects 1 based inclusive coordinates, but the"]
    #[doc = "returned coordinates start from 0 and are half open, so pos0 is valid"]
    #[doc = "for use in e.g. \"for (pos0 = beg; pos0 < end; pos0++) {...}\""]
    #[doc = ""]
    #[doc = "If NULL is returned, the value in tid mat give additional information"]
    #[doc = "about the error:"]
    #[doc = ""]
    #[doc = "-2   Failed to parse @p hdr; or out of memory"]
    #[doc = "-1   The reference in @p str has mismatched braces, or does not"]
    #[doc = "exist in @p hdr"]
    #[doc = ">= 0 The specified range in @p str could not be parsed"]
    #[doc = "*/"]
    pub fn hts_parse_region(
        s: *const ::std::os::raw::c_char,
        tid: *mut ::std::os::raw::c_int,
        beg: *mut hts_pos_t,
        end: *mut hts_pos_t,
        getid: hts_name2id_f,
        hdr: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Create a single-region iterator"]
    #[doc = "** @param idx      Index"]
    #[doc = "@param tid      Target ID"]
    #[doc = "@param beg      Start of region"]
    #[doc = "@param end      End of region"]
    #[doc = "@param readrec  Callback to read a record from the input file"]
    #[doc = "@return An iterator on success; NULL on failure"]
    #[doc = ""]
    #[doc = "The iterator struct returned by a successful call should be freed"]
    #[doc = "via hts_itr_destroy() when it is no longer needed."]
    #[doc = "*/"]
    pub fn hts_itr_query(
        idx: *const hts_idx_t,
        tid: ::std::os::raw::c_int,
        beg: hts_pos_t,
        end: hts_pos_t,
        readrec: hts_readrec_func,
    ) -> *mut hts_itr_t;
}
extern "C" {
    #[doc = " Free an iterator"]
    #[doc = "** @param iter   Iterator to free"]
    #[doc = "*/"]
    pub fn hts_itr_destroy(iter: *mut hts_itr_t);
}
pub type hts_itr_query_func = ::std::option::Option<
    unsafe extern "C" fn(
        idx: *const hts_idx_t,
        tid: ::std::os::raw::c_int,
        beg: hts_pos_t,
        end: hts_pos_t,
        readrec: hts_readrec_func,
    ) -> *mut hts_itr_t,
>;
extern "C" {
    #[doc = " Create a single-region iterator from a text region specification"]
    #[doc = "** @param idx       Index"]
    #[doc = "@param reg       Region specifier"]
    #[doc = "@param getid     Callback function to return the target ID for a name"]
    #[doc = "@param hdr       Input file header"]
    #[doc = "@param itr_query Callback function returning an iterator for a numeric tid,"]
    #[doc = "start and end position"]
    #[doc = "@param readrec   Callback to read a record from the input file"]
    #[doc = "@return An iterator on success; NULL on error"]
    #[doc = ""]
    #[doc = "The iterator struct returned by a successful call should be freed"]
    #[doc = "via hts_itr_destroy() when it is no longer needed."]
    #[doc = "*/"]
    pub fn hts_itr_querys(
        idx: *const hts_idx_t,
        reg: *const ::std::os::raw::c_char,
        getid: hts_name2id_f,
        hdr: *mut ::std::os::raw::c_void,
        itr_query: hts_itr_query_func,
        readrec: hts_readrec_func,
    ) -> *mut hts_itr_t;
}
extern "C" {
    #[doc = " Return the next record from an iterator"]
    #[doc = "** @param fp      Input file handle"]
    #[doc = "@param iter    Iterator"]
    #[doc = "@param r       Pointer to record placeholder"]
    #[doc = "@param data    Data passed to the readrec callback"]
    #[doc = "@return >= 0 on success, -1 when there is no more data, < -1 on error"]
    #[doc = "*/"]
    pub fn hts_itr_next(
        fp: *mut BGZF,
        iter: *mut hts_itr_t,
        r: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Iterator with multiple regions *"]
pub type hts_itr_multi_query_func = ::std::option::Option<
    unsafe extern "C" fn(idx: *const hts_idx_t, itr: *mut hts_itr_t) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn hts_itr_multi_bam(idx: *const hts_idx_t, iter: *mut hts_itr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hts_itr_multi_cram(idx: *const hts_idx_t, iter: *mut hts_itr_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a multi-region iterator from a region list"]
    #[doc = "** @param idx          Index"]
    #[doc = "@param reglist      Region list"]
    #[doc = "@param count        Number of items in region list"]
    #[doc = "@param getid        Callback to convert names to target IDs"]
    #[doc = "@param hdr          Indexed file header (passed to getid)"]
    #[doc = "@param itr_specific Filetype-specific callback function"]
    #[doc = "@param readrec      Callback to read an input file record"]
    #[doc = "@param seek         Callback to seek in the input file"]
    #[doc = "@param tell         Callback to return current input file location"]
    #[doc = "@return An iterator on success; NULL on failure"]
    #[doc = ""]
    #[doc = "The iterator struct returned by a successful call should be freed"]
    #[doc = "via hts_itr_destroy() when it is no longer needed."]
    #[doc = "*/"]
    pub fn hts_itr_regions(
        idx: *const hts_idx_t,
        reglist: *mut hts_reglist_t,
        count: ::std::os::raw::c_int,
        getid: hts_name2id_f,
        hdr: *mut ::std::os::raw::c_void,
        itr_specific: hts_itr_multi_query_func,
        readrec: hts_readrec_func,
        seek: hts_seek_func,
        tell: hts_tell_func,
    ) -> *mut hts_itr_t;
}
extern "C" {
    #[doc = " Return the next record from an iterator"]
    #[doc = "** @param fp      Input file handle"]
    #[doc = "@param iter    Iterator"]
    #[doc = "@param r       Pointer to record placeholder"]
    #[doc = "@return >= 0 on success, -1 when there is no more data, < -1 on error"]
    #[doc = "*/"]
    pub fn hts_itr_multi_next(
        fd: *mut htsFile,
        iter: *mut hts_itr_t,
        r: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a region list from a char array"]
    #[doc = "** @param argv      Char array of target:interval elements, e.g. chr1:2500-3600, chr1:5100, chr2"]
    #[doc = "@param argc      Number of items in the array"]
    #[doc = "@param r_count   Pointer to the number of items in the resulting region list"]
    #[doc = "@param hdr       Header for the sam/bam/cram file"]
    #[doc = "@param getid     Callback to convert target names to target ids."]
    #[doc = "@return  A region list on success, NULL on failure"]
    #[doc = ""]
    #[doc = "The hts_reglist_t struct returned by a successful call should be freed"]
    #[doc = "via hts_reglist_free() when it is no longer needed."]
    #[doc = "*/"]
    pub fn hts_reglist_create(
        argv: *mut *mut ::std::os::raw::c_char,
        argc: ::std::os::raw::c_int,
        r_count: *mut ::std::os::raw::c_int,
        hdr: *mut ::std::os::raw::c_void,
        getid: hts_name2id_f,
    ) -> *mut hts_reglist_t;
}
extern "C" {
    #[doc = " Free a region list"]
    #[doc = "** @param reglist    Region list"]
    #[doc = "@param count      Number of items in the list"]
    #[doc = "*/"]
    pub fn hts_reglist_free(reglist: *mut hts_reglist_t, count: ::std::os::raw::c_int);
}
extern "C" {
    pub fn hts_file_type(fname: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
#[doc = " Revised MAQ error model *"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct errmod_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn errmod_init(depcorr: f64) -> *mut errmod_t;
}
extern "C" {
    pub fn errmod_destroy(em: *mut errmod_t);
}
extern "C" {
    pub fn errmod_cal(
        em: *const errmod_t,
        n: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        bases: *mut u16,
        q: *mut f32,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Probabilistic banded glocal alignment             *"]
#[doc = " See https://doi.org/10.1093/bioinformatics/btr076 *"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct probaln_par_t {
    pub d: f32,
    pub e: f32,
    pub bw: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_probaln_par_t() {
    assert_eq!(
        ::std::mem::size_of::<probaln_par_t>(),
        12usize,
        concat!("Size of: ", stringify!(probaln_par_t))
    );
    assert_eq!(
        ::std::mem::align_of::<probaln_par_t>(),
        4usize,
        concat!("Alignment of ", stringify!(probaln_par_t))
    );
    fn test_field_d() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<probaln_par_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).d) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(probaln_par_t),
                "::",
                stringify!(d)
            )
        );
    }
    test_field_d();
    fn test_field_e() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<probaln_par_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(probaln_par_t),
                "::",
                stringify!(e)
            )
        );
    }
    test_field_e();
    fn test_field_bw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<probaln_par_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bw) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(probaln_par_t),
                "::",
                stringify!(bw)
            )
        );
    }
    test_field_bw();
}
extern "C" {
    #[doc = " Perform probabilistic banded glocal alignment"]
    #[doc = "** @param      ref     Reference sequence"]
    #[doc = "@param      l_ref   Length of reference"]
    #[doc = "@param      query   Query sequence"]
    #[doc = "@param      l_query Length of query sequence"]
    #[doc = "@param      iqual   Query base qualities"]
    #[doc = "@param      c       Alignment parameters"]
    #[doc = "@param[out] state   Output alignment"]
    #[doc = "@param[out] q    Phred scaled posterior probability of state[i] being wrong"]
    #[doc = "@return     Phred-scaled likelihood score, or INT_MIN on failure."]
    #[doc = ""]
    #[doc = "The reference and query sequences are coded using integers 0,1,2,3,4 for"]
    #[doc = "bases A,C,G,T,N respectively (N here is for any ambiguity code)."]
    #[doc = ""]
    #[doc = "On output, state and q are arrays of length l_query. The higher 30"]
    #[doc = "bits give the reference position the query base is matched to and the"]
    #[doc = "lower two bits can be 0 (an alignment match) or 1 (an"]
    #[doc = "insertion). q[i] gives the phred scaled posterior probability of"]
    #[doc = "state[i] being wrong."]
    #[doc = ""]
    #[doc = "On failure, errno will be set to EINVAL if the values of l_ref or l_query"]
    #[doc = "were invalid; or ENOMEM if a memory allocation failed."]
    #[doc = "*/"]
    pub fn probaln_glocal(
        ref_: *const u8,
        l_ref: ::std::os::raw::c_int,
        query: *const u8,
        l_query: ::std::os::raw::c_int,
        iqual: *const u8,
        c: *const probaln_par_t,
        state: *mut ::std::os::raw::c_int,
        q: *mut u8,
    ) -> ::std::os::raw::c_int;
}
#[doc = " MD5 implementation *"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hts_md5_context {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @abstract   Initialises an MD5 context."]
    #[doc = "  @discussion"]
    #[doc = "    The expected use is to allocate an hts_md5_context using"]
    #[doc = "    hts_md5_init().  This pointer is then passed into one or more calls"]
    #[doc = "    of hts_md5_update() to compute successive internal portions of the"]
    #[doc = "    MD5 sum, which can then be externalised as a full 16-byte MD5sum"]
    #[doc = "    calculation by calling hts_md5_final().  This can then be turned"]
    #[doc = "    into ASCII via hts_md5_hex()."]
    #[doc = ""]
    #[doc = "    To dealloate any resources created by hts_md5_init() call the"]
    #[doc = "    hts_md5_destroy() function."]
    #[doc = ""]
    #[doc = "  @return     hts_md5_context pointer on success, NULL otherwise."]
    pub fn hts_md5_init() -> *mut hts_md5_context;
}
extern "C" {
    #[doc = " @abstract Updates the context with the MD5 of the data."]
    pub fn hts_md5_update(
        ctx: *mut hts_md5_context,
        data: *const ::std::os::raw::c_void,
        size: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    #[doc = " @abstract Computes the final 128-bit MD5 hash from the given context"]
    pub fn hts_md5_final(digest: *mut ::std::os::raw::c_uchar, ctx: *mut hts_md5_context);
}
extern "C" {
    #[doc = " @abstract Resets an md5_context to the initial state, as returned"]
    #[doc = "            by hts_md5_init()."]
    pub fn hts_md5_reset(ctx: *mut hts_md5_context);
}
extern "C" {
    #[doc = " @abstract Converts a 128-bit MD5 hash into a 33-byte nul-termninated"]
    #[doc = "            hex string."]
    pub fn hts_md5_hex(hex: *mut ::std::os::raw::c_char, digest: *const ::std::os::raw::c_uchar);
}
extern "C" {
    #[doc = " @abstract Deallocates any memory allocated by hts_md5_init."]
    pub fn hts_md5_destroy(ctx: *mut hts_md5_context);
}
pub type uint16_u = u16;
pub type uint32_u = u32;
pub type uint64_u = u64;
extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn __assert(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bcf_hrec_t {
    pub type_: ::std::os::raw::c_int,
    pub key: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
    pub nkeys: ::std::os::raw::c_int,
    pub keys: *mut *mut ::std::os::raw::c_char,
    pub vals: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_bcf_hrec_t() {
    assert_eq!(
        ::std::mem::size_of::<bcf_hrec_t>(),
        48usize,
        concat!("Size of: ", stringify!(bcf_hrec_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bcf_hrec_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bcf_hrec_t))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_hrec_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_hrec_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_hrec_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_hrec_t),
                "::",
                stringify!(key)
            )
        );
    }
    test_field_key();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_hrec_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_hrec_t),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
    fn test_field_nkeys() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_hrec_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nkeys) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_hrec_t),
                "::",
                stringify!(nkeys)
            )
        );
    }
    test_field_nkeys();
    fn test_field_keys() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_hrec_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keys) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_hrec_t),
                "::",
                stringify!(keys)
            )
        );
    }
    test_field_keys();
    fn test_field_vals() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_hrec_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vals) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_hrec_t),
                "::",
                stringify!(vals)
            )
        );
    }
    test_field_vals();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bcf_idinfo_t {
    pub info: [u64; 3usize],
    pub hrec: [*mut bcf_hrec_t; 3usize],
    pub id: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_bcf_idinfo_t() {
    assert_eq!(
        ::std::mem::size_of::<bcf_idinfo_t>(),
        56usize,
        concat!("Size of: ", stringify!(bcf_idinfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bcf_idinfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bcf_idinfo_t))
    );
    fn test_field_info() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_idinfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_idinfo_t),
                "::",
                stringify!(info)
            )
        );
    }
    test_field_info();
    fn test_field_hrec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_idinfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hrec) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_idinfo_t),
                "::",
                stringify!(hrec)
            )
        );
    }
    test_field_hrec();
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_idinfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_idinfo_t),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bcf_idpair_t {
    pub key: *const ::std::os::raw::c_char,
    pub val: *const bcf_idinfo_t,
}
#[test]
fn bindgen_test_layout_bcf_idpair_t() {
    assert_eq!(
        ::std::mem::size_of::<bcf_idpair_t>(),
        16usize,
        concat!("Size of: ", stringify!(bcf_idpair_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bcf_idpair_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bcf_idpair_t))
    );
    fn test_field_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_idpair_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_idpair_t),
                "::",
                stringify!(key)
            )
        );
    }
    test_field_key();
    fn test_field_val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_idpair_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_idpair_t),
                "::",
                stringify!(val)
            )
        );
    }
    test_field_val();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bcf_hdr_t {
    pub n: [i32; 3usize],
    pub id: [*mut bcf_idpair_t; 3usize],
    pub dict: [*mut ::std::os::raw::c_void; 3usize],
    pub samples: *mut *mut ::std::os::raw::c_char,
    pub hrec: *mut *mut bcf_hrec_t,
    pub nhrec: ::std::os::raw::c_int,
    pub dirty: ::std::os::raw::c_int,
    pub ntransl: ::std::os::raw::c_int,
    pub transl: [*mut ::std::os::raw::c_int; 2usize],
    pub nsamples_ori: ::std::os::raw::c_int,
    pub keep_samples: *mut u8,
    pub mem: kstring_t,
    pub m: [i32; 3usize],
}
#[test]
fn bindgen_test_layout_bcf_hdr_t() {
    assert_eq!(
        ::std::mem::size_of::<bcf_hdr_t>(),
        168usize,
        concat!("Size of: ", stringify!(bcf_hdr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bcf_hdr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bcf_hdr_t))
    );
    fn test_field_n() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_hdr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_hdr_t),
                "::",
                stringify!(n)
            )
        );
    }
    test_field_n();
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_hdr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_hdr_t),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_dict() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_hdr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dict) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_hdr_t),
                "::",
                stringify!(dict)
            )
        );
    }
    test_field_dict();
    fn test_field_samples() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_hdr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).samples) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_hdr_t),
                "::",
                stringify!(samples)
            )
        );
    }
    test_field_samples();
    fn test_field_hrec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_hdr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hrec) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_hdr_t),
                "::",
                stringify!(hrec)
            )
        );
    }
    test_field_hrec();
    fn test_field_nhrec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_hdr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nhrec) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_hdr_t),
                "::",
                stringify!(nhrec)
            )
        );
    }
    test_field_nhrec();
    fn test_field_dirty() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_hdr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dirty) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_hdr_t),
                "::",
                stringify!(dirty)
            )
        );
    }
    test_field_dirty();
    fn test_field_ntransl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_hdr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ntransl) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_hdr_t),
                "::",
                stringify!(ntransl)
            )
        );
    }
    test_field_ntransl();
    fn test_field_transl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_hdr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).transl) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_hdr_t),
                "::",
                stringify!(transl)
            )
        );
    }
    test_field_transl();
    fn test_field_nsamples_ori() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_hdr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nsamples_ori) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_hdr_t),
                "::",
                stringify!(nsamples_ori)
            )
        );
    }
    test_field_nsamples_ori();
    fn test_field_keep_samples() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_hdr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keep_samples) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_hdr_t),
                "::",
                stringify!(keep_samples)
            )
        );
    }
    test_field_keep_samples();
    fn test_field_mem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_hdr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mem) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_hdr_t),
                "::",
                stringify!(mem)
            )
        );
    }
    test_field_mem();
    fn test_field_m() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_hdr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_hdr_t),
                "::",
                stringify!(m)
            )
        );
    }
    test_field_m();
}
extern "C" {
    pub static mut bcf_type_shift: [u8; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bcf_variant_t {
    pub type_: ::std::os::raw::c_int,
    pub n: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_bcf_variant_t() {
    assert_eq!(
        ::std::mem::size_of::<bcf_variant_t>(),
        8usize,
        concat!("Size of: ", stringify!(bcf_variant_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bcf_variant_t>(),
        4usize,
        concat!("Alignment of ", stringify!(bcf_variant_t))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_variant_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_variant_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_n() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_variant_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_variant_t),
                "::",
                stringify!(n)
            )
        );
    }
    test_field_n();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bcf_fmt_t {
    pub id: ::std::os::raw::c_int,
    pub n: ::std::os::raw::c_int,
    pub size: ::std::os::raw::c_int,
    pub type_: ::std::os::raw::c_int,
    pub p: *mut u8,
    pub p_len: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_bcf_fmt_t() {
    assert_eq!(
        ::std::mem::size_of::<bcf_fmt_t>(),
        32usize,
        concat!("Size of: ", stringify!(bcf_fmt_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bcf_fmt_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bcf_fmt_t))
    );
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_fmt_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_fmt_t),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_n() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_fmt_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_fmt_t),
                "::",
                stringify!(n)
            )
        );
    }
    test_field_n();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_fmt_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_fmt_t),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_fmt_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_fmt_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_p() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_fmt_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_fmt_t),
                "::",
                stringify!(p)
            )
        );
    }
    test_field_p();
    fn test_field_p_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_fmt_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_len) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_fmt_t),
                "::",
                stringify!(p_len)
            )
        );
    }
    test_field_p_len();
}
impl bcf_fmt_t {
    #[inline]
    pub fn p_off(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_p_off(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn p_free(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_p_free(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(p_off: u32, p_free: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let p_off: u32 = unsafe { ::std::mem::transmute(p_off) };
            p_off as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let p_free: u32 = unsafe { ::std::mem::transmute(p_free) };
            p_free as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bcf_info_t {
    pub key: ::std::os::raw::c_int,
    pub type_: ::std::os::raw::c_int,
    pub v1: bcf_info_t__bindgen_ty_1,
    pub vptr: *mut u8,
    pub vptr_len: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub len: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bcf_info_t__bindgen_ty_1 {
    pub i: i64,
    pub f: f32,
}
#[test]
fn bindgen_test_layout_bcf_info_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<bcf_info_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(bcf_info_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<bcf_info_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(bcf_info_t__bindgen_ty_1))
    );
    fn test_field_i() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_info_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_info_t__bindgen_ty_1),
                "::",
                stringify!(i)
            )
        );
    }
    test_field_i();
    fn test_field_f() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_info_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_info_t__bindgen_ty_1),
                "::",
                stringify!(f)
            )
        );
    }
    test_field_f();
}
#[test]
fn bindgen_test_layout_bcf_info_t() {
    assert_eq!(
        ::std::mem::size_of::<bcf_info_t>(),
        40usize,
        concat!("Size of: ", stringify!(bcf_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bcf_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bcf_info_t))
    );
    fn test_field_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_info_t),
                "::",
                stringify!(key)
            )
        );
    }
    test_field_key();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_info_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_v1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v1) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_info_t),
                "::",
                stringify!(v1)
            )
        );
    }
    test_field_v1();
    fn test_field_vptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vptr) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_info_t),
                "::",
                stringify!(vptr)
            )
        );
    }
    test_field_vptr();
    fn test_field_vptr_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vptr_len) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_info_t),
                "::",
                stringify!(vptr_len)
            )
        );
    }
    test_field_vptr_len();
    fn test_field_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_info_t),
                "::",
                stringify!(len)
            )
        );
    }
    test_field_len();
}
impl bcf_info_t {
    #[inline]
    pub fn vptr_off(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_vptr_off(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn vptr_free(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vptr_free(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(vptr_off: u32, vptr_free: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let vptr_off: u32 = unsafe { ::std::mem::transmute(vptr_off) };
            vptr_off as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let vptr_free: u32 = unsafe { ::std::mem::transmute(vptr_free) };
            vptr_free as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bcf_dec_t {
    pub m_fmt: ::std::os::raw::c_int,
    pub m_info: ::std::os::raw::c_int,
    pub m_id: ::std::os::raw::c_int,
    pub m_als: ::std::os::raw::c_int,
    pub m_allele: ::std::os::raw::c_int,
    pub m_flt: ::std::os::raw::c_int,
    pub n_flt: ::std::os::raw::c_int,
    pub flt: *mut ::std::os::raw::c_int,
    pub id: *mut ::std::os::raw::c_char,
    pub als: *mut ::std::os::raw::c_char,
    pub allele: *mut *mut ::std::os::raw::c_char,
    pub info: *mut bcf_info_t,
    pub fmt: *mut bcf_fmt_t,
    pub var: *mut bcf_variant_t,
    pub n_var: ::std::os::raw::c_int,
    pub var_type: ::std::os::raw::c_int,
    pub shared_dirty: ::std::os::raw::c_int,
    pub indiv_dirty: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_bcf_dec_t() {
    assert_eq!(
        ::std::mem::size_of::<bcf_dec_t>(),
        104usize,
        concat!("Size of: ", stringify!(bcf_dec_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bcf_dec_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bcf_dec_t))
    );
    fn test_field_m_fmt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_dec_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_fmt) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_dec_t),
                "::",
                stringify!(m_fmt)
            )
        );
    }
    test_field_m_fmt();
    fn test_field_m_info() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_dec_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_info) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_dec_t),
                "::",
                stringify!(m_info)
            )
        );
    }
    test_field_m_info();
    fn test_field_m_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_dec_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_id) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_dec_t),
                "::",
                stringify!(m_id)
            )
        );
    }
    test_field_m_id();
    fn test_field_m_als() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_dec_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_als) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_dec_t),
                "::",
                stringify!(m_als)
            )
        );
    }
    test_field_m_als();
    fn test_field_m_allele() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_dec_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_allele) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_dec_t),
                "::",
                stringify!(m_allele)
            )
        );
    }
    test_field_m_allele();
    fn test_field_m_flt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_dec_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_flt) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_dec_t),
                "::",
                stringify!(m_flt)
            )
        );
    }
    test_field_m_flt();
    fn test_field_n_flt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_dec_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n_flt) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_dec_t),
                "::",
                stringify!(n_flt)
            )
        );
    }
    test_field_n_flt();
    fn test_field_flt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_dec_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flt) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_dec_t),
                "::",
                stringify!(flt)
            )
        );
    }
    test_field_flt();
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_dec_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_dec_t),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_als() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_dec_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).als) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_dec_t),
                "::",
                stringify!(als)
            )
        );
    }
    test_field_als();
    fn test_field_allele() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_dec_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allele) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_dec_t),
                "::",
                stringify!(allele)
            )
        );
    }
    test_field_allele();
    fn test_field_info() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_dec_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_dec_t),
                "::",
                stringify!(info)
            )
        );
    }
    test_field_info();
    fn test_field_fmt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_dec_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fmt) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_dec_t),
                "::",
                stringify!(fmt)
            )
        );
    }
    test_field_fmt();
    fn test_field_var() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_dec_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).var) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_dec_t),
                "::",
                stringify!(var)
            )
        );
    }
    test_field_var();
    fn test_field_n_var() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_dec_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n_var) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_dec_t),
                "::",
                stringify!(n_var)
            )
        );
    }
    test_field_n_var();
    fn test_field_var_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_dec_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).var_type) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_dec_t),
                "::",
                stringify!(var_type)
            )
        );
    }
    test_field_var_type();
    fn test_field_shared_dirty() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_dec_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shared_dirty) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_dec_t),
                "::",
                stringify!(shared_dirty)
            )
        );
    }
    test_field_shared_dirty();
    fn test_field_indiv_dirty() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_dec_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).indiv_dirty) as usize - ptr as usize
            },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_dec_t),
                "::",
                stringify!(indiv_dirty)
            )
        );
    }
    test_field_indiv_dirty();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bcf1_t {
    pub pos: hts_pos_t,
    pub rlen: hts_pos_t,
    pub rid: i32,
    pub qual: f32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub shared: kstring_t,
    pub indiv: kstring_t,
    pub d: bcf_dec_t,
    pub max_unpack: ::std::os::raw::c_int,
    pub unpacked: ::std::os::raw::c_int,
    pub unpack_size: [::std::os::raw::c_int; 3usize],
    pub errcode: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_bcf1_t() {
    assert_eq!(
        ::std::mem::size_of::<bcf1_t>(),
        208usize,
        concat!("Size of: ", stringify!(bcf1_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bcf1_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bcf1_t))
    );
    fn test_field_pos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf1_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf1_t),
                "::",
                stringify!(pos)
            )
        );
    }
    test_field_pos();
    fn test_field_rlen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf1_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rlen) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf1_t),
                "::",
                stringify!(rlen)
            )
        );
    }
    test_field_rlen();
    fn test_field_rid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf1_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rid) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf1_t),
                "::",
                stringify!(rid)
            )
        );
    }
    test_field_rid();
    fn test_field_qual() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf1_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).qual) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf1_t),
                "::",
                stringify!(qual)
            )
        );
    }
    test_field_qual();
    fn test_field_shared() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf1_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shared) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf1_t),
                "::",
                stringify!(shared)
            )
        );
    }
    test_field_shared();
    fn test_field_indiv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf1_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).indiv) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf1_t),
                "::",
                stringify!(indiv)
            )
        );
    }
    test_field_indiv();
    fn test_field_d() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf1_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).d) as usize - ptr as usize
            },
            80usize,
            concat!("Offset of field: ", stringify!(bcf1_t), "::", stringify!(d))
        );
    }
    test_field_d();
    fn test_field_max_unpack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf1_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_unpack) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf1_t),
                "::",
                stringify!(max_unpack)
            )
        );
    }
    test_field_max_unpack();
    fn test_field_unpacked() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf1_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unpacked) as usize - ptr as usize
            },
            188usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf1_t),
                "::",
                stringify!(unpacked)
            )
        );
    }
    test_field_unpacked();
    fn test_field_unpack_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf1_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unpack_size) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf1_t),
                "::",
                stringify!(unpack_size)
            )
        );
    }
    test_field_unpack_size();
    fn test_field_errcode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf1_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).errcode) as usize - ptr as usize
            },
            204usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf1_t),
                "::",
                stringify!(errcode)
            )
        );
    }
    test_field_errcode();
}
impl bcf1_t {
    #[inline]
    pub fn n_info(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_n_info(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn n_allele(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_n_allele(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn n_fmt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_n_fmt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn n_sample(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_n_sample(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        n_info: u32,
        n_allele: u32,
        n_fmt: u32,
        n_sample: u32,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let n_info: u32 = unsafe { ::std::mem::transmute(n_info) };
            n_info as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let n_allele: u32 = unsafe { ::std::mem::transmute(n_allele) };
            n_allele as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let n_fmt: u32 = unsafe { ::std::mem::transmute(n_fmt) };
            n_fmt as u64
        });
        __bindgen_bitfield_unit.set(40usize, 24u8, {
            let n_sample: u32 = unsafe { ::std::mem::transmute(n_sample) };
            n_sample as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = "  bcf_hdr_init() - create an empty BCF header."]
    #[doc = "  @param mode    \"r\" or \"w\""]
    #[doc = ""]
    #[doc = "  When opened for writing, the mandatory fileFormat and"]
    #[doc = "  FILTER=PASS lines are added automatically."]
    #[doc = ""]
    #[doc = " The bcf_hdr_t struct returned by a successful call should be freed"]
    #[doc = " via bcf_hdr_destroy() when it is no longer needed."]
    pub fn bcf_hdr_init(mode: *const ::std::os::raw::c_char) -> *mut bcf_hdr_t;
}
extern "C" {
    #[doc = " Destroy a BCF header struct"]
    pub fn bcf_hdr_destroy(h: *mut bcf_hdr_t);
}
extern "C" {
    #[doc = " Allocate and initialize a bcf1_t object."]
    #[doc = ""]
    #[doc = " The bcf1_t struct returned by a successful call should be freed"]
    #[doc = " via bcf_destroy() when it is no longer needed."]
    pub fn bcf_init() -> *mut bcf1_t;
}
extern "C" {
    #[doc = " Deallocate a bcf1_t object"]
    pub fn bcf_destroy(v: *mut bcf1_t);
}
extern "C" {
    #[doc = "  Same as bcf_destroy() but frees only the memory allocated by bcf1_t,"]
    #[doc = "  not the bcf1_t object itself."]
    pub fn bcf_empty(v: *mut bcf1_t);
}
extern "C" {
    #[doc = "  Make the bcf1_t object ready for next read. Intended mostly for"]
    #[doc = "  internal use, the user should rarely need to call this function"]
    #[doc = "  directly."]
    pub fn bcf_clear(v: *mut bcf1_t);
}
#[doc = " @brief File handle returned by hts_open() etc."]
#[doc = " This structure should be considered opaque by end users. There should be"]
#[doc = " no need to access most fields directly in user code, and in cases where"]
#[doc = " it is desirable accessor functions such as hts_get_format() are provided."]
pub type vcfFile = htsFile;
extern "C" {
    #[doc = " Read a VCF or BCF header"]
    #[doc = "** @param  fp  The file to read the header from"]
    #[doc = "@return Pointer to a populated header structure on success;"]
    #[doc = "NULL on failure"]
    #[doc = ""]
    #[doc = "The bcf_hdr_t struct returned by a successful call should be freed"]
    #[doc = "via bcf_hdr_destroy() when it is no longer needed."]
    #[doc = "*/"]
    pub fn bcf_hdr_read(fp: *mut htsFile) -> *mut bcf_hdr_t;
}
extern "C" {
    #[doc = "  bcf_hdr_set_samples() - for more efficient VCF parsing when only one/few samples are needed"]
    #[doc = "  @param samples  samples to include or exclude from file or as a comma-separated string."]
    #[doc = "              LIST|FILE   .. select samples in list/file"]
    #[doc = "              ^LIST|FILE  .. exclude samples from list/file"]
    #[doc = "              -           .. include all samples"]
    #[doc = "              NULL        .. exclude all samples"]
    #[doc = "  @param is_file  @p samples is a file (1) or a comma-separated list (0)"]
    #[doc = ""]
    #[doc = "  The bottleneck of VCF reading is parsing of genotype fields. If the"]
    #[doc = "  reader knows in advance that only subset of samples is needed (possibly"]
    #[doc = "  no samples at all), the performance of bcf_read() can be significantly"]
    #[doc = "  improved by calling bcf_hdr_set_samples after bcf_hdr_read()."]
    #[doc = "  The function bcf_read() will subset the VCF/BCF records automatically"]
    #[doc = "  with the notable exception when reading records via bcf_itr_next()."]
    #[doc = "  In this case, bcf_subset_format() must be called explicitly, because"]
    #[doc = "  bcf_readrec() does not see the header."]
    #[doc = ""]
    #[doc = "  Returns 0 on success, -1 on error or a positive integer if the list"]
    #[doc = "  contains samples not present in the VCF header. In such a case, the"]
    #[doc = "  return value is the index of the offending sample."]
    pub fn bcf_hdr_set_samples(
        hdr: *mut bcf_hdr_t,
        samples: *const ::std::os::raw::c_char,
        is_file: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcf_subset_format(hdr: *const bcf_hdr_t, rec: *mut bcf1_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write a VCF or BCF header"]
    #[doc = "** @param  fp  Output file"]
    #[doc = "@param  h   The header to write"]
    #[doc = "@return 0 on success; -1 on failure"]
    #[doc = "*/"]
    pub fn bcf_hdr_write(fp: *mut htsFile, h: *mut bcf_hdr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse VCF line contained in kstring and populate the bcf1_t struct"]
    #[doc = " The line must not end with \\n or \\r characters."]
    pub fn vcf_parse(
        s: *mut kstring_t,
        h: *const bcf_hdr_t,
        v: *mut bcf1_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Complete the file opening mode, according to its extension."]
    #[doc = " @param mode      Preallocated mode string to be completed."]
    #[doc = " @param fn        File name to be opened."]
    #[doc = " @param format    Format string (vcf|bcf|vcf.gz)"]
    #[doc = " @return          0 on success; -1 on failure"]
    pub fn vcf_open_mode(
        mode: *mut ::std::os::raw::c_char,
        fn_: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The opposite of vcf_parse. It should rarely be called directly, see vcf_write"]
    pub fn vcf_format(
        h: *const bcf_hdr_t,
        v: *const bcf1_t,
        s: *mut kstring_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read next VCF or BCF record"]
    #[doc = "** @param fp  The file to read the record from"]
    #[doc = "@param h   The header for the vcf/bcf file"]
    #[doc = "@param v   The bcf1_t structure to populate"]
    #[doc = "@return 0 on success; -1 on end of file; < -1 on critical error"]
    #[doc = ""]
    #[doc = "On errors which are not critical for reading, such as missing header"]
    #[doc = "definitions in vcf files, zero will be returned but v->errcode will have been"]
    #[doc = "set to one of BCF_ERR* codes and must be checked before calling bcf_write()."]
    #[doc = "*/"]
    pub fn bcf_read(fp: *mut htsFile, h: *const bcf_hdr_t, v: *mut bcf1_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcf_unpack(b: *mut bcf1_t, which: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcf_dup(src: *mut bcf1_t) -> *mut bcf1_t;
}
extern "C" {
    pub fn bcf_copy(dst: *mut bcf1_t, src: *mut bcf1_t) -> *mut bcf1_t;
}
extern "C" {
    #[doc = " Write one VCF or BCF record. The type is determined at the open() call."]
    #[doc = "** @param  fp  The file to write to"]
    #[doc = "@param  h   The header for the vcf/bcf file"]
    #[doc = "@param  v   The bcf1_t structure to write"]
    #[doc = "@return 0 on success; -1 on error"]
    #[doc = "*/"]
    pub fn bcf_write(fp: *mut htsFile, h: *mut bcf_hdr_t, v: *mut bcf1_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  The following functions work only with VCFs and should rarely be called"]
    #[doc = "  directly. Usually one wants to use their bcf_* alternatives, which work"]
    #[doc = "  transparently with both VCFs and BCFs."]
    #[doc = "@return Pointer to a populated header structure on success;"]
    #[doc = "NULL on failure"]
    #[doc = ""]
    #[doc = "Use bcf_hdr_read() instead."]
    #[doc = ""]
    #[doc = "The bcf_hdr_t struct returned by a successful call should be freed"]
    #[doc = "via bcf_hdr_destroy() when it is no longer needed."]
    pub fn vcf_hdr_read(fp: *mut htsFile) -> *mut bcf_hdr_t;
}
extern "C" {
    #[doc = " Write a VCF format header"]
    #[doc = "** @param  fp  Output file"]
    #[doc = "@param  h   The header to write"]
    #[doc = "@return 0 on success; -1 on failure"]
    #[doc = ""]
    #[doc = "Use bcf_hdr_write() instead"]
    #[doc = "*/"]
    pub fn vcf_hdr_write(fp: *mut htsFile, h: *const bcf_hdr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read a record from a VCF file"]
    #[doc = "** @param fp  The file to read the record from"]
    #[doc = "@param h   The header for the vcf file"]
    #[doc = "@param v   The bcf1_t structure to populate"]
    #[doc = "@return 0 on success; -1 on end of file; < -1 on error"]
    #[doc = ""]
    #[doc = "Use bcf_read() instead"]
    #[doc = "*/"]
    pub fn vcf_read(fp: *mut htsFile, h: *const bcf_hdr_t, v: *mut bcf1_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write a record to a VCF file"]
    #[doc = "** @param  fp  The file to write to"]
    #[doc = "@param h   The header for the vcf file"]
    #[doc = "@param v   The bcf1_t structure to write"]
    #[doc = "@return 0 on success; -1 on error"]
    #[doc = ""]
    #[doc = "Use bcf_write() instead"]
    #[doc = "*/"]
    pub fn vcf_write(
        fp: *mut htsFile,
        h: *const bcf_hdr_t,
        v: *mut bcf1_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function for the bcf_itr_next() macro; internal use, ignore it"]
    pub fn bcf_readrec(
        fp: *mut BGZF,
        null: *mut ::std::os::raw::c_void,
        v: *mut ::std::os::raw::c_void,
        tid: *mut ::std::os::raw::c_int,
        beg: *mut hts_pos_t,
        end: *mut hts_pos_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write a line to a VCF file"]
    #[doc = "** @param line   Line to write"]
    #[doc = "@param fp     File to write it to"]
    #[doc = "@return 0 on success; -1 on failure"]
    #[doc = ""]
    #[doc = "@note No checks are done on the line being added, apart from"]
    #[doc = "ensuring that it ends with a newline.  This function"]
    #[doc = "should therefore be used with care."]
    #[doc = "*/"]
    pub fn vcf_write_line(fp: *mut htsFile, line: *mut kstring_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new header using the supplied template"]
    #[doc = ""]
    #[doc = "  The bcf_hdr_t struct returned by a successful call should be freed"]
    #[doc = "  via bcf_hdr_destroy() when it is no longer needed."]
    #[doc = "  @return NULL on failure, header otherwise"]
    pub fn bcf_hdr_dup(hdr: *const bcf_hdr_t) -> *mut bcf_hdr_t;
}
extern "C" {
    #[doc = "  Copy header lines from src to dst if not already present in dst. See also bcf_translate()."]
    #[doc = "  Returns 0 on success or sets a bit on error:"]
    #[doc = "      1 .. conflicting definitions of tag length"]
    #[doc = "      // todo"]
    pub fn bcf_hdr_combine(dst: *mut bcf_hdr_t, src: *const bcf_hdr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  bcf_hdr_merge() - copy header lines from src to dst, see also bcf_translate()"]
    #[doc = "  @param dst: the destination header to be merged into, NULL on the first pass"]
    #[doc = "  @param src: the source header"]
    #[doc = "  @return NULL on failure, header otherwise"]
    #[doc = ""]
    #[doc = "  Notes:"]
    #[doc = "      - use as:"]
    #[doc = "          bcf_hdr_t *dst = NULL;"]
    #[doc = "          for (i=0; i<nsrc; i++) dst = bcf_hdr_merge(dst,src[i]);"]
    #[doc = ""]
    #[doc = "      - bcf_hdr_merge() replaces bcf_hdr_combine() which had a problem when"]
    #[doc = "      combining multiple BCF headers. The current bcf_hdr_combine()"]
    #[doc = "      does not have this problem, but became slow when used for many files."]
    pub fn bcf_hdr_merge(dst: *mut bcf_hdr_t, src: *const bcf_hdr_t) -> *mut bcf_hdr_t;
}
extern "C" {
    #[doc = "  bcf_hdr_add_sample() - add a new sample."]
    #[doc = "  @param sample:  sample name to be added"]
    #[doc = ""]
    #[doc = "  Note:"]
    #[doc = "      After all samples have been added, the internal header structure must be updated"]
    #[doc = "      by calling bcf_hdr_sync(). This is normally done automatically by the first bcf_hdr_write()"]
    #[doc = "      or bcf_write() call. Otherwise, the caller must force the update by calling bcf_hdr_sync()"]
    #[doc = "      explicitly."]
    pub fn bcf_hdr_add_sample(
        hdr: *mut bcf_hdr_t,
        sample: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read VCF header from a file and update the header"]
    pub fn bcf_hdr_set(
        hdr: *mut bcf_hdr_t,
        fname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Appends formatted header text to _str_."]
    #[doc = "** If _is_bcf_ is zero, `IDX` fields are discarded."]
    #[doc = "*  @return 0 if successful, or negative if an error occurred"]
    #[doc = "*  @since 1.4"]
    #[doc = "*/"]
    pub fn bcf_hdr_format(
        hdr: *const bcf_hdr_t,
        is_bcf: ::std::os::raw::c_int,
        str_: *mut kstring_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns formatted header (newly allocated string) and its length,"]
    #[doc = "  excluding the terminating \\0. If is_bcf parameter is unset, IDX"]
    #[doc = "  fields are discarded."]
    #[doc = "  @deprecated Use bcf_hdr_format() instead as it can handle huge headers."]
    pub fn bcf_hdr_fmt_text(
        hdr: *const bcf_hdr_t,
        is_bcf: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Append new VCF header line, returns 0 on success"]
    pub fn bcf_hdr_append(
        h: *mut bcf_hdr_t,
        line: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcf_hdr_printf(
        h: *mut bcf_hdr_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " VCF version, e.g. VCFv4.2"]
    pub fn bcf_hdr_get_version(hdr: *const bcf_hdr_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set version in bcf header"]
    #[doc = "**"]
    #[doc = "@param hdr     BCF header struct"]
    #[doc = "@param version Version to set, e.g. \"VCFv4.3\""]
    #[doc = "@return 0 on success; < 0 on error"]
    #[doc = "*/"]
    pub fn bcf_hdr_set_version(
        hdr: *mut bcf_hdr_t,
        version: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  bcf_hdr_remove() - remove VCF header tag"]
    #[doc = "  @param type:      one of BCF_HL_*"]
    #[doc = "  @param key:       tag name or NULL to remove all tags of the given type"]
    pub fn bcf_hdr_remove(
        h: *mut bcf_hdr_t,
        type_: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "  bcf_hdr_subset() - creates a new copy of the header removing unwanted samples"]
    #[doc = "  @param n:        number of samples to keep"]
    #[doc = "  @param samples:  names of the samples to keep"]
    #[doc = "  @param imap:     mapping from index in @samples to the sample index in the original file"]
    #[doc = "  @return NULL on failure, header otherwise"]
    #[doc = ""]
    #[doc = "  Sample names not present in h0 are ignored. The number of unmatched samples can be checked"]
    #[doc = "  by comparing n and bcf_hdr_nsamples(out_hdr)."]
    #[doc = "  This function can be used to reorder samples."]
    #[doc = "  See also bcf_subset() which subsets individual records."]
    #[doc = "  The bcf_hdr_t struct returned by a successful call should be freed"]
    #[doc = "  via bcf_hdr_destroy() when it is no longer needed."]
    pub fn bcf_hdr_subset(
        h0: *const bcf_hdr_t,
        n: ::std::os::raw::c_int,
        samples: *const *mut ::std::os::raw::c_char,
        imap: *mut ::std::os::raw::c_int,
    ) -> *mut bcf_hdr_t;
}
extern "C" {
    #[doc = " Creates a list of sequence names. It is up to the caller to free the list (but not the sequence names)"]
    pub fn bcf_hdr_seqnames(
        h: *const bcf_hdr_t,
        nseqs: *mut ::std::os::raw::c_int,
    ) -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " The following functions are for internal use and should rarely be called directly"]
    pub fn bcf_hdr_parse(
        hdr: *mut bcf_hdr_t,
        htxt: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Synchronize internal header structures"]
    #[doc = "** @param h  Header"]
    #[doc = "@return 0 on success, -1 on failure"]
    #[doc = ""]
    #[doc = "This function updates the id, sample and contig arrays in the"]
    #[doc = "bcf_hdr_t structure so that they point to the same locations as"]
    #[doc = "the id, sample and contig dictionaries."]
    #[doc = "*/"]
    pub fn bcf_hdr_sync(h: *mut bcf_hdr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " bcf_hdr_parse_line() - parse a single line of VCF textual header"]
    #[doc = " @param h     BCF header struct"]
    #[doc = " @param line  One or more lines of header text"]
    #[doc = " @param len   Filled out with length data parsed from 'line'."]
    #[doc = " @return bcf_hrec_t* on success;"]
    #[doc = "         NULL on error or on end of header text."]
    #[doc = "         NB: to distinguish error from end-of-header, check *len:"]
    #[doc = "           *len == 0 indicates @p line did not start with \"##\""]
    #[doc = "           *len == -1 indicates failure, likely due to out of memory"]
    #[doc = "           *len > 0 indicates a malformed header line"]
    #[doc = ""]
    #[doc = " If *len > 0 on exit, it will contain the full length of the line"]
    #[doc = " including any trailing newline (this includes cases where NULL was"]
    #[doc = " returned due to a malformed line).  Callers can use this to skip to"]
    #[doc = " the next header line."]
    pub fn bcf_hdr_parse_line(
        h: *const bcf_hdr_t,
        line: *const ::std::os::raw::c_char,
        len: *mut ::std::os::raw::c_int,
    ) -> *mut bcf_hrec_t;
}
extern "C" {
    #[doc = " Convert a bcf header record to string form"]
    #[doc = "**"]
    #[doc = "* @param hrec    Header record"]
    #[doc = "* @param str     Destination kstring"]
    #[doc = "* @return 0 on success; < 0 on error"]
    #[doc = "*/"]
    pub fn bcf_hrec_format(hrec: *const bcf_hrec_t, str_: *mut kstring_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcf_hdr_add_hrec(hdr: *mut bcf_hdr_t, hrec: *mut bcf_hrec_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  bcf_hdr_get_hrec() - get header line info"]
    #[doc = "  @param type:  one of the BCF_HL_* types: FLT,INFO,FMT,CTG,STR,GEN"]
    #[doc = "  @param key:   the header key for generic lines (e.g. \"fileformat\"), any field"]
    #[doc = "                  for structured lines, typically \"ID\"."]
    #[doc = "  @param value: the value which pairs with key. Can be be NULL for BCF_HL_GEN"]
    #[doc = "  @param str_class: the class of BCF_HL_STR line (e.g. \"ALT\" or \"SAMPLE\"), otherwise NULL"]
    pub fn bcf_hdr_get_hrec(
        hdr: *const bcf_hdr_t,
        type_: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        str_class: *const ::std::os::raw::c_char,
    ) -> *mut bcf_hrec_t;
}
extern "C" {
    #[doc = " Duplicate a header record"]
    #[doc = "** @param hrec   Header record to copy"]
    #[doc = "@return A new header record on success; NULL on failure"]
    #[doc = ""]
    #[doc = "The bcf_hrec_t struct returned by a successful call should be freed"]
    #[doc = "via bcf_hrec_destroy() when it is no longer needed."]
    #[doc = "*/"]
    pub fn bcf_hrec_dup(hrec: *mut bcf_hrec_t) -> *mut bcf_hrec_t;
}
extern "C" {
    #[doc = " Add a new header record key"]
    #[doc = "** @param hrec  Header record"]
    #[doc = "@param str   Key name"]
    #[doc = "@param len   Length of @p str"]
    #[doc = "@return 0 on success; -1 on failure"]
    #[doc = "*/"]
    pub fn bcf_hrec_add_key(
        hrec: *mut bcf_hrec_t,
        str_: *const ::std::os::raw::c_char,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set a header record value"]
    #[doc = "** @param hrec      Header record"]
    #[doc = "@param i         Index of value"]
    #[doc = "@param str       Value to set"]
    #[doc = "@param len       Length of @p str"]
    #[doc = "@param is_quoted Value should be quoted"]
    #[doc = "@return 0 on success; -1 on failure"]
    #[doc = "*/"]
    pub fn bcf_hrec_set_val(
        hrec: *mut bcf_hrec_t,
        i: ::std::os::raw::c_int,
        str_: *const ::std::os::raw::c_char,
        len: size_t,
        is_quoted: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcf_hrec_find_key(
        hrec: *mut bcf_hrec_t,
        key: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add an IDX header record"]
    #[doc = "** @param hrec   Header record"]
    #[doc = "@param idx    IDX value to add"]
    #[doc = "@return 0 on success; -1 on failure"]
    #[doc = "*/"]
    pub fn hrec_add_idx(hrec: *mut bcf_hrec_t, idx: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free up a header record and associated structures"]
    #[doc = "** @param hrec  Header record"]
    #[doc = "*/"]
    pub fn bcf_hrec_destroy(hrec: *mut bcf_hrec_t);
}
extern "C" {
    #[doc = " See the description of bcf_hdr_subset()"]
    pub fn bcf_subset(
        h: *const bcf_hdr_t,
        v: *mut bcf1_t,
        n: ::std::os::raw::c_int,
        imap: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  bcf_translate() - translate tags ids to be consistent with different header. This function"]
    #[doc = "                    is useful when lines from multiple VCF need to be combined."]
    #[doc = "  @dst_hdr:   the destination header, to be used in bcf_write(), see also bcf_hdr_combine()"]
    #[doc = "  @src_hdr:   the source header, used in bcf_read()"]
    #[doc = "  @src_line:  line obtained by bcf_read()"]
    pub fn bcf_translate(
        dst_hdr: *const bcf_hdr_t,
        src_hdr: *mut bcf_hdr_t,
        src_line: *mut bcf1_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get variant types in a BCF record"]
    #[doc = "**"]
    #[doc = "*  @param rec   BCF/VCF record"]
    #[doc = "*  @return Types of variant present"]
    #[doc = "*"]
    #[doc = "*  The return value will be a bitwise-or of VCF_SNP, VCF_MNP,"]
    #[doc = "*  VCF_INDEL, VCF_OTHER, VCF_BND or VCF_OVERLAP.  If will return"]
    #[doc = "*  VCF_REF (i.e. 0) if none of the other types is present."]
    #[doc = "*  @deprecated Please use bcf_has_variant_types() instead"]
    #[doc = "*/"]
    pub fn bcf_get_variant_types(rec: *mut bcf1_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get variant type in a BCF record, for a given allele"]
    #[doc = "**"]
    #[doc = "*  @param  rec        BCF/VCF record"]
    #[doc = "*  @param  ith_allele Allele to check"]
    #[doc = "*  @return Type of variant present"]
    #[doc = "*"]
    #[doc = "*  The return value will be one of VCF_REF, VCF_SNP, VCF_MNP,"]
    #[doc = "*  VCF_INDEL, VCF_OTHER, VCF_BND or VCF_OVERLAP."]
    #[doc = "*  @deprecated Please use bcf_has_variant_type() instead"]
    #[doc = "*/"]
    pub fn bcf_get_variant_type(
        rec: *mut bcf1_t,
        ith_allele: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< Types present exactly match tested for"]
pub const bcf_variant_match_bcf_match_exact: bcf_variant_match = 0;
#[doc = "< At least one variant type in common"]
pub const bcf_variant_match_bcf_match_overlap: bcf_variant_match = 1;
#[doc = "< Test set is a subset of types present"]
pub const bcf_variant_match_bcf_match_subset: bcf_variant_match = 2;
#[doc = " Match mode for bcf_has_variant_types()"]
pub type bcf_variant_match = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Check for presence of variant types in a BCF record"]
    #[doc = "**"]
    #[doc = "*  @param rec      BCF/VCF record"]
    #[doc = "*  @param bitmask  Set of variant types to test for"]
    #[doc = "*  @param mode     Match mode"]
    #[doc = "*  @return >0 if the variant types are present,"]
    #[doc = "*           0 if not present,"]
    #[doc = "*          -1 on error"]
    #[doc = "*"]
    #[doc = "*  @p bitmask should be the bitwise-or of the variant types (VCF_SNP,"]
    #[doc = "*     VCF_MNP, etc.) to test for."]
    #[doc = "*"]
    #[doc = "*  The return value is the bitwise-and of the set of types present"]
    #[doc = "*  and @p bitmask.  Callers that want to check for the presence of more"]
    #[doc = "*  than one type can avoid function call overhead by passing all the"]
    #[doc = "*  types to be checked for in a single call to this function, in"]
    #[doc = "*  bcf_match_overlap mode, and then check for them individually in the"]
    #[doc = "*  returned value."]
    #[doc = "*"]
    #[doc = "*  As VCF_REF is represented by 0 (i.e. the absence of other variants)"]
    #[doc = "*  it should be tested for using"]
    #[doc = "*    bcf_has_variant_types(rec, VCF_REF, bcf_match_exact)"]
    #[doc = "*  which will return 1 if no other variant type is present, otherwise 0."]
    #[doc = "*/"]
    pub fn bcf_has_variant_types(
        rec: *mut bcf1_t,
        bitmask: u32,
        mode: bcf_variant_match,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check for presence of variant types in a BCF record, for a given allele"]
    #[doc = "**"]
    #[doc = "*  @param rec         BCF/VCF record"]
    #[doc = "*  @param ith_allele  Allele to check"]
    #[doc = "*  @param bitmask     Set of variant types to test for"]
    #[doc = "*  @return >0 if one of the variant types is present,"]
    #[doc = "*           0 if not present,"]
    #[doc = "*          -1 on error"]
    #[doc = "*"]
    #[doc = "*  @p bitmask should be the bitwise-or of the variant types (VCF_SNP,"]
    #[doc = "*     VCF_MNP, etc.) to test for, or VCF_REF on its own."]
    #[doc = "*"]
    #[doc = "*  The return value is the bitwise-and of the set of types present"]
    #[doc = "*  and @p bitmask.  Callers that want to check for the presence of more"]
    #[doc = "*  than one type can avoid function call overhead by passing all the"]
    #[doc = "*  types to be checked for in a single call to this function, and then"]
    #[doc = "*  check for them individually in the returned value."]
    #[doc = "*"]
    #[doc = "*  As a special case, if @p bitmask is VCF_REF (i.e. 0), the function"]
    #[doc = "*  tests for an exact match.  The return value will be 1 if the"]
    #[doc = "*  variant type calculated for the allele is VCF_REF, otherwise if"]
    #[doc = "*  any other type is present it will be 0."]
    #[doc = "*/"]
    pub fn bcf_has_variant_type(
        rec: *mut bcf1_t,
        ith_allele: ::std::os::raw::c_int,
        bitmask: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the number of bases affected by a variant, for a given allele"]
    #[doc = "**"]
    #[doc = "*  @param rec         BCF/VCF record"]
    #[doc = "*  @param ith_allele  Allele index"]
    #[doc = "*  @return The number of bases affected (negative for deletions),"]
    #[doc = "*          or bcf_int32_missing on error."]
    #[doc = "*/"]
    pub fn bcf_variant_length(
        rec: *mut bcf1_t,
        ith_allele: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcf_is_snp(v: *mut bcf1_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  bcf_update_filter() - sets the FILTER column"]
    #[doc = "  @flt_ids:  The filter IDs to set, numeric IDs returned by bcf_hdr_id2int(hdr, BCF_DT_ID, \"PASS\")"]
    #[doc = "  @n:        Number of filters. If n==0, all filters are removed"]
    pub fn bcf_update_filter(
        hdr: *const bcf_hdr_t,
        line: *mut bcf1_t,
        flt_ids: *mut ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  bcf_add_filter() - adds to the FILTER column"]
    #[doc = "  @flt_id:   filter ID to add, numeric ID returned by bcf_hdr_id2int(hdr, BCF_DT_ID, \"PASS\")"]
    #[doc = ""]
    #[doc = "  If flt_id is PASS, all existing filters are removed first. If other than PASS, existing PASS is removed."]
    pub fn bcf_add_filter(
        hdr: *const bcf_hdr_t,
        line: *mut bcf1_t,
        flt_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  bcf_remove_filter() - removes from the FILTER column"]
    #[doc = "  @flt_id:   filter ID to remove, numeric ID returned by bcf_hdr_id2int(hdr, BCF_DT_ID, \"PASS\")"]
    #[doc = "  @pass:     when set to 1 and no filters are present, set to PASS"]
    pub fn bcf_remove_filter(
        hdr: *const bcf_hdr_t,
        line: *mut bcf1_t,
        flt_id: ::std::os::raw::c_int,
        pass: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Returns 1 if present, 0 if absent, or -1 if filter does not exist. \"PASS\" and \".\" can be used interchangeably."]
    pub fn bcf_has_filter(
        hdr: *const bcf_hdr_t,
        line: *mut bcf1_t,
        filter: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  bcf_update_alleles() and bcf_update_alleles_str() - update REF and ALT column"]
    #[doc = "  @alleles:           Array of alleles"]
    #[doc = "  @nals:              Number of alleles"]
    #[doc = "  @alleles_string:    Comma-separated alleles, starting with the REF allele"]
    pub fn bcf_update_alleles(
        hdr: *const bcf_hdr_t,
        line: *mut bcf1_t,
        alleles: *mut *const ::std::os::raw::c_char,
        nals: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcf_update_alleles_str(
        hdr: *const bcf_hdr_t,
        line: *mut bcf1_t,
        alleles_string: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  bcf_update_id() - sets new ID string"]
    #[doc = "  bcf_add_id() - adds to the ID string checking for duplicates"]
    pub fn bcf_update_id(
        hdr: *const bcf_hdr_t,
        line: *mut bcf1_t,
        id: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcf_add_id(
        hdr: *const bcf_hdr_t,
        line: *mut bcf1_t,
        id: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcf_update_info(
        hdr: *const bcf_hdr_t,
        line: *mut bcf1_t,
        key: *const ::std::os::raw::c_char,
        values: *const ::std::os::raw::c_void,
        n: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcf_update_format_string(
        hdr: *const bcf_hdr_t,
        line: *mut bcf1_t,
        key: *const ::std::os::raw::c_char,
        values: *mut *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcf_update_format(
        hdr: *const bcf_hdr_t,
        line: *mut bcf1_t,
        key: *const ::std::os::raw::c_char,
        values: *const ::std::os::raw::c_void,
        n: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " bcf_get_fmt() - returns pointer to FORMAT's field data"]
    #[doc = " @header: for access to BCF_DT_ID dictionary"]
    #[doc = " @line:   VCF line obtained from vcf_parse1"]
    #[doc = " @fmt:    one of GT,PL,..."]
    #[doc = ""]
    #[doc = " Returns bcf_fmt_t* if the call succeeded, or returns NULL when the field"]
    #[doc = " is not available."]
    pub fn bcf_get_fmt(
        hdr: *const bcf_hdr_t,
        line: *mut bcf1_t,
        key: *const ::std::os::raw::c_char,
    ) -> *mut bcf_fmt_t;
}
extern "C" {
    pub fn bcf_get_info(
        hdr: *const bcf_hdr_t,
        line: *mut bcf1_t,
        key: *const ::std::os::raw::c_char,
    ) -> *mut bcf_info_t;
}
extern "C" {
    #[doc = " bcf_get_*_id() - returns pointer to FORMAT/INFO field data given the header index instead of the string ID"]
    #[doc = " @line: VCF line obtained from vcf_parse1"]
    #[doc = " @id:  The header index for the tag, obtained from bcf_hdr_id2int()"]
    #[doc = ""]
    #[doc = " Returns bcf_fmt_t* / bcf_info_t*. These functions do not check if the index is valid"]
    #[doc = " as their goal is to avoid the header lookup."]
    pub fn bcf_get_fmt_id(line: *mut bcf1_t, id: ::std::os::raw::c_int) -> *mut bcf_fmt_t;
}
extern "C" {
    pub fn bcf_get_info_id(line: *mut bcf1_t, id: ::std::os::raw::c_int) -> *mut bcf_info_t;
}
extern "C" {
    pub fn bcf_get_info_values(
        hdr: *const bcf_hdr_t,
        line: *mut bcf1_t,
        tag: *const ::std::os::raw::c_char,
        dst: *mut *mut ::std::os::raw::c_void,
        ndst: *mut ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcf_get_format_string(
        hdr: *const bcf_hdr_t,
        line: *mut bcf1_t,
        tag: *const ::std::os::raw::c_char,
        dst: *mut *mut *mut ::std::os::raw::c_char,
        ndst: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcf_get_format_values(
        hdr: *const bcf_hdr_t,
        line: *mut bcf1_t,
        tag: *const ::std::os::raw::c_char,
        dst: *mut *mut ::std::os::raw::c_void,
        ndst: *mut ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  bcf_hdr_id2int() - Translates string into numeric ID"]
    #[doc = "  bcf_hdr_int2id() - Translates numeric ID into string"]
    #[doc = "  @type:     one of BCF_DT_ID, BCF_DT_CTG, BCF_DT_SAMPLE"]
    #[doc = "  @id:       tag name, such as: PL, DP, GT, etc."]
    #[doc = ""]
    #[doc = "  Returns -1 if string is not in dictionary, otherwise numeric ID which identifies"]
    #[doc = "  fields in BCF records."]
    pub fn bcf_hdr_id2int(
        hdr: *const bcf_hdr_t,
        type_: ::std::os::raw::c_int,
        id: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert BCF FORMAT data to string form"]
    #[doc = "**"]
    #[doc = "* @param s    kstring to write into"]
    #[doc = "* @param n    number of items in @p data"]
    #[doc = "* @param type type of items in @p data"]
    #[doc = "* @param data BCF format data"]
    #[doc = "* @return  0 on success"]
    #[doc = "*         -1 if out of memory"]
    #[doc = "*/"]
    pub fn bcf_fmt_array(
        s: *mut kstring_t,
        n: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcf_fmt_sized_array(s: *mut kstring_t, ptr: *mut u8) -> *mut u8;
}
extern "C" {
    #[doc = " Encode a variable-length char array in BCF format"]
    #[doc = "**"]
    #[doc = "* @param s    kstring to write into"]
    #[doc = "* @param l    length of input"]
    #[doc = "* @param a    input data to encode"]
    #[doc = "* @return 0 on success; < 0 on error"]
    #[doc = "*/"]
    pub fn bcf_enc_vchar(
        s: *mut kstring_t,
        l: ::std::os::raw::c_int,
        a: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encode a variable-length integer array in BCF format"]
    #[doc = "**"]
    #[doc = "* @param s      kstring to write into"]
    #[doc = "* @param n      total number of items in @p a (<= 0 to encode BCF_BT_NULL)"]
    #[doc = "* @param a      input data to encode"]
    #[doc = "* @param wsize  vector length (<= 0 is equivalent to @p n)"]
    #[doc = "* @return 0 on success; < 0 on error"]
    #[doc = "* @note @p n should be an exact multiple of @p wsize"]
    #[doc = "*/"]
    pub fn bcf_enc_vint(
        s: *mut kstring_t,
        n: ::std::os::raw::c_int,
        a: *mut i32,
        wsize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encode a variable-length float array in BCF format"]
    #[doc = "**"]
    #[doc = "* @param s      kstring to write into"]
    #[doc = "* @param n      total number of items in @p a (<= 0 to encode BCF_BT_NULL)"]
    #[doc = "* @param a      input data to encode"]
    #[doc = "* @return 0 on success; < 0 on error"]
    #[doc = "*/"]
    pub fn bcf_enc_vfloat(
        s: *mut kstring_t,
        n: ::std::os::raw::c_int,
        a: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Load a BCF index from a given index file name"]
    #[doc = "**  @param fn     Input BAM/BCF/etc filename"]
    #[doc = "@param fnidx  The input index filename"]
    #[doc = "@return  The index, or NULL if an error occurred."]
    #[doc = "@note This only works for BCF files.  Consider synced_bcf_reader instead"]
    #[doc = "which works for both BCF and VCF."]
    #[doc = "*/"]
    pub fn bcf_index_load2(
        fn_: *const ::std::os::raw::c_char,
        fnidx: *const ::std::os::raw::c_char,
    ) -> *mut hts_idx_t;
}
extern "C" {
    #[doc = " Load a BCF index from a given index file name"]
    #[doc = "**  @param fn     Input BAM/BCF/etc filename"]
    #[doc = "@param fnidx  The input index filename"]
    #[doc = "@param flags  Flags to alter behaviour (see description)"]
    #[doc = "@return  The index, or NULL if an error occurred."]
    #[doc = "@note This only works for BCF files.  Consider synced_bcf_reader instead"]
    #[doc = "which works for both BCF and VCF."]
    #[doc = ""]
    #[doc = "The @p flags parameter can be set to a combination of the following"]
    #[doc = "values:"]
    #[doc = ""]
    #[doc = "HTS_IDX_SAVE_REMOTE   Save a local copy of any remote indexes"]
    #[doc = "HTS_IDX_SILENT_FAIL   Fail silently if the index is not present"]
    #[doc = ""]
    #[doc = "Equivalent to hts_idx_load3(fn, fnidx, HTS_FMT_CSI, flags);"]
    #[doc = "*/"]
    pub fn bcf_index_load3(
        fn_: *const ::std::os::raw::c_char,
        fnidx: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> *mut hts_idx_t;
}
extern "C" {
    #[doc = "  bcf_index_build() - Generate and save an index file"]
    #[doc = "  @fn:         Input VCF(compressed)/BCF filename"]
    #[doc = "  @min_shift:  log2(width of the smallest bin), e.g. a value of 14"]
    #[doc = "  imposes a 16k base lower limit on the width of index bins."]
    #[doc = "  Positive to generate CSI, or 0 to generate TBI. However, a small"]
    #[doc = "  value of min_shift would create a large index, which would lead to"]
    #[doc = "  reduced performance when using the index. A recommended value is 14."]
    #[doc = "  For BCF files, only the CSI index can be generated."]
    #[doc = ""]
    #[doc = "  Returns 0 if successful, or negative if an error occurred."]
    #[doc = ""]
    #[doc = "  List of error codes:"]
    #[doc = "      -1 .. indexing failed"]
    #[doc = "      -2 .. opening @fn failed"]
    #[doc = "      -3 .. format not indexable"]
    #[doc = "      -4 .. failed to create and/or save the index"]
    pub fn bcf_index_build(
        fn_: *const ::std::os::raw::c_char,
        min_shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  bcf_index_build2() - Generate and save an index to a specific file"]
    #[doc = "  @fn:         Input VCF/BCF filename"]
    #[doc = "  @fnidx:      Output filename, or NULL to add .csi/.tbi to @fn"]
    #[doc = "  @min_shift:  Positive to generate CSI, or 0 to generate TBI"]
    #[doc = ""]
    #[doc = "  Returns 0 if successful, or negative if an error occurred."]
    #[doc = ""]
    #[doc = "  List of error codes:"]
    #[doc = "      -1 .. indexing failed"]
    #[doc = "      -2 .. opening @fn failed"]
    #[doc = "      -3 .. format not indexable"]
    #[doc = "      -4 .. failed to create and/or save the index"]
    pub fn bcf_index_build2(
        fn_: *const ::std::os::raw::c_char,
        fnidx: *const ::std::os::raw::c_char,
        min_shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  bcf_index_build3() - Generate and save an index to a specific file"]
    #[doc = "  @fn:         Input VCF/BCF filename"]
    #[doc = "  @fnidx:      Output filename, or NULL to add .csi/.tbi to @fn"]
    #[doc = "  @min_shift:  Positive to generate CSI, or 0 to generate TBI"]
    #[doc = "  @n_threads:  Number of VCF/BCF decoder threads"]
    #[doc = ""]
    #[doc = "  Returns 0 if successful, or negative if an error occurred."]
    #[doc = ""]
    #[doc = "  List of error codes:"]
    #[doc = "      -1 .. indexing failed"]
    #[doc = "      -2 .. opening @fn failed"]
    #[doc = "      -3 .. format not indexable"]
    #[doc = "      -4 .. failed to create and/or save the index"]
    pub fn bcf_index_build3(
        fn_: *const ::std::os::raw::c_char,
        fnidx: *const ::std::os::raw::c_char,
        min_shift: ::std::os::raw::c_int,
        n_threads: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialise fp->idx for the current format type, for VCF and BCF files."]
    #[doc = "** @param fp        File handle for the data file being written."]
    #[doc = "@param h         BCF header structured (needed for BAI and CSI)."]
    #[doc = "@param min_shift CSI bin size (CSI default is 14)."]
    #[doc = "@param fnidx     Filename to write index to.  This pointer must remain valid"]
    #[doc = "until after bcf_idx_save is called."]
    #[doc = "@return          0 on success, <0 on failure."]
    #[doc = "@note This must be called after the header has been written, but before"]
    #[doc = "any other data."]
    #[doc = "*/"]
    pub fn bcf_idx_init(
        fp: *mut htsFile,
        h: *mut bcf_hdr_t,
        min_shift: ::std::os::raw::c_int,
        fnidx: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Writes the index initialised with bcf_idx_init to disk."]
    #[doc = "** @param fp        File handle for the data file being written."]
    #[doc = "@return          0 on success, <0 on failure."]
    #[doc = "*/"]
    pub fn bcf_idx_save(fp: *mut htsFile) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut bcf_float_vector_end: u32;
}
extern "C" {
    pub static mut bcf_float_missing: u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sam_hrecs_t {
    _unused: [u8; 0],
}
#[doc = " @typedef"]
#[doc = "@abstract Structure for the alignment header."]
#[doc = "@field n_targets   number of reference sequences"]
#[doc = "@field l_text      length of the plain text in the header (may be zero if"]
#[doc = "the header has been edited)"]
#[doc = "@field target_len  lengths of the reference sequences"]
#[doc = "@field target_name names of the reference sequences"]
#[doc = "@field text        plain text (may be NULL if the header has been edited)"]
#[doc = "@field sdict       header dictionary"]
#[doc = "@field hrecs       pointer to the extended header struct (internal use only)"]
#[doc = "@field ref_count   reference count"]
#[doc = ""]
#[doc = "@note The text and l_text fields are included for backwards compatibility."]
#[doc = "These fields may be set to NULL and zero respectively as a side-effect"]
#[doc = "of calling some header API functions.  New code that needs to access the"]
#[doc = "header text should use the sam_hdr_str() and sam_hdr_length() functions"]
#[doc = "instead of these fields."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sam_hdr_t {
    pub n_targets: i32,
    pub ignore_sam_err: i32,
    pub l_text: size_t,
    pub target_len: *mut u32,
    pub cigar_tab: *const i8,
    pub target_name: *mut *mut ::std::os::raw::c_char,
    pub text: *mut ::std::os::raw::c_char,
    pub sdict: *mut ::std::os::raw::c_void,
    pub hrecs: *mut sam_hrecs_t,
    pub ref_count: u32,
}
#[test]
fn bindgen_test_layout_sam_hdr_t() {
    assert_eq!(
        ::std::mem::size_of::<sam_hdr_t>(),
        72usize,
        concat!("Size of: ", stringify!(sam_hdr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sam_hdr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sam_hdr_t))
    );
    fn test_field_n_targets() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sam_hdr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n_targets) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sam_hdr_t),
                "::",
                stringify!(n_targets)
            )
        );
    }
    test_field_n_targets();
    fn test_field_ignore_sam_err() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sam_hdr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ignore_sam_err) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(sam_hdr_t),
                "::",
                stringify!(ignore_sam_err)
            )
        );
    }
    test_field_ignore_sam_err();
    fn test_field_l_text() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sam_hdr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l_text) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sam_hdr_t),
                "::",
                stringify!(l_text)
            )
        );
    }
    test_field_l_text();
    fn test_field_target_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sam_hdr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).target_len) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(sam_hdr_t),
                "::",
                stringify!(target_len)
            )
        );
    }
    test_field_target_len();
    fn test_field_cigar_tab() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sam_hdr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cigar_tab) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(sam_hdr_t),
                "::",
                stringify!(cigar_tab)
            )
        );
    }
    test_field_cigar_tab();
    fn test_field_target_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sam_hdr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).target_name) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(sam_hdr_t),
                "::",
                stringify!(target_name)
            )
        );
    }
    test_field_target_name();
    fn test_field_text() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sam_hdr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(sam_hdr_t),
                "::",
                stringify!(text)
            )
        );
    }
    test_field_text();
    fn test_field_sdict() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sam_hdr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sdict) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(sam_hdr_t),
                "::",
                stringify!(sdict)
            )
        );
    }
    test_field_sdict();
    fn test_field_hrecs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sam_hdr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hrecs) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(sam_hdr_t),
                "::",
                stringify!(hrecs)
            )
        );
    }
    test_field_hrecs();
    fn test_field_ref_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sam_hdr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(sam_hdr_t),
                "::",
                stringify!(ref_count)
            )
        );
    }
    test_field_ref_count();
}
#[doc = " @typedef"]
#[doc = "@abstract Structure for the alignment header."]
#[doc = "@field n_targets   number of reference sequences"]
#[doc = "@field l_text      length of the plain text in the header (may be zero if"]
#[doc = "the header has been edited)"]
#[doc = "@field target_len  lengths of the reference sequences"]
#[doc = "@field target_name names of the reference sequences"]
#[doc = "@field text        plain text (may be NULL if the header has been edited)"]
#[doc = "@field sdict       header dictionary"]
#[doc = "@field hrecs       pointer to the extended header struct (internal use only)"]
#[doc = "@field ref_count   reference count"]
#[doc = ""]
#[doc = "@note The text and l_text fields are included for backwards compatibility."]
#[doc = "These fields may be set to NULL and zero respectively as a side-effect"]
#[doc = "of calling some header API functions.  New code that needs to access the"]
#[doc = "header text should use the sam_hdr_str() and sam_hdr_length() functions"]
#[doc = "instead of these fields."]
pub type bam_hdr_t = sam_hdr_t;
extern "C" {
    #[doc = " @abstract Table for converting a CIGAR operator character to BAM_CMATCH etc."]
    #[doc = "Result is operator code or -1. Be sure to cast the index if it is a plain char:"]
    #[doc = "int op = bam_cigar_table[(unsigned char) ch];"]
    pub static bam_cigar_table: [i8; 256usize];
}
#[doc = " @typedef"]
#[doc = "@abstract Structure for core alignment information."]
#[doc = "@field  pos     0-based leftmost coordinate"]
#[doc = "@field  tid     chromosome ID, defined by sam_hdr_t"]
#[doc = "@field  bin     bin calculated by bam_reg2bin()"]
#[doc = "@field  qual    mapping quality"]
#[doc = "@field  l_extranul length of extra NULs between qname & cigar (for alignment)"]
#[doc = "@field  flag    bitwise flag"]
#[doc = "@field  l_qname length of the query name"]
#[doc = "@field  n_cigar number of CIGAR operations"]
#[doc = "@field  l_qseq  length of the query sequence (read)"]
#[doc = "@field  mtid    chromosome ID of next read in template, defined by sam_hdr_t"]
#[doc = "@field  mpos    0-based leftmost coordinate of next read in template"]
#[doc = "@field  isize   observed template length (\"insert size\")"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bam1_core_t {
    pub pos: hts_pos_t,
    pub tid: i32,
    pub bin: u16,
    pub qual: u8,
    pub l_extranul: u8,
    pub flag: u16,
    pub l_qname: u16,
    pub n_cigar: u32,
    pub l_qseq: i32,
    pub mtid: i32,
    pub mpos: hts_pos_t,
    pub isize_: hts_pos_t,
}
#[test]
fn bindgen_test_layout_bam1_core_t() {
    assert_eq!(
        ::std::mem::size_of::<bam1_core_t>(),
        48usize,
        concat!("Size of: ", stringify!(bam1_core_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bam1_core_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bam1_core_t))
    );
    fn test_field_pos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bam1_core_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bam1_core_t),
                "::",
                stringify!(pos)
            )
        );
    }
    test_field_pos();
    fn test_field_tid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bam1_core_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tid) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bam1_core_t),
                "::",
                stringify!(tid)
            )
        );
    }
    test_field_tid();
    fn test_field_bin() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bam1_core_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bin) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(bam1_core_t),
                "::",
                stringify!(bin)
            )
        );
    }
    test_field_bin();
    fn test_field_qual() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bam1_core_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).qual) as usize - ptr as usize
            },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(bam1_core_t),
                "::",
                stringify!(qual)
            )
        );
    }
    test_field_qual();
    fn test_field_l_extranul() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bam1_core_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l_extranul) as usize - ptr as usize
            },
            15usize,
            concat!(
                "Offset of field: ",
                stringify!(bam1_core_t),
                "::",
                stringify!(l_extranul)
            )
        );
    }
    test_field_l_extranul();
    fn test_field_flag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bam1_core_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flag) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bam1_core_t),
                "::",
                stringify!(flag)
            )
        );
    }
    test_field_flag();
    fn test_field_l_qname() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bam1_core_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l_qname) as usize - ptr as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(bam1_core_t),
                "::",
                stringify!(l_qname)
            )
        );
    }
    test_field_l_qname();
    fn test_field_n_cigar() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bam1_core_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n_cigar) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(bam1_core_t),
                "::",
                stringify!(n_cigar)
            )
        );
    }
    test_field_n_cigar();
    fn test_field_l_qseq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bam1_core_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l_qseq) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bam1_core_t),
                "::",
                stringify!(l_qseq)
            )
        );
    }
    test_field_l_qseq();
    fn test_field_mtid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bam1_core_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mtid) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(bam1_core_t),
                "::",
                stringify!(mtid)
            )
        );
    }
    test_field_mtid();
    fn test_field_mpos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bam1_core_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mpos) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(bam1_core_t),
                "::",
                stringify!(mpos)
            )
        );
    }
    test_field_mpos();
    fn test_field_isize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bam1_core_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).isize_) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(bam1_core_t),
                "::",
                stringify!(isize_)
            )
        );
    }
    test_field_isize();
}
#[doc = " @typedef"]
#[doc = "@abstract Structure for one alignment."]
#[doc = "@field  core       core information about the alignment"]
#[doc = "@field  id"]
#[doc = "@field  data       all variable-length data, concatenated; structure: qname-cigar-seq-qual-aux"]
#[doc = "@field  l_data     current length of bam1_t::data"]
#[doc = "@field  m_data     maximum length of bam1_t::data"]
#[doc = "@field  mempolicy  memory handling policy, see bam_set_mempolicy()"]
#[doc = ""]
#[doc = "@discussion Notes:"]
#[doc = ""]
#[doc = "1. The data blob should be accessed using bam_get_qname, bam_get_cigar,"]
#[doc = "bam_get_seq, bam_get_qual and bam_get_aux macros.  These returns pointers"]
#[doc = "to the start of each type of data."]
#[doc = "2. qname is terminated by one to four NULs, so that the following"]
#[doc = "cigar data is 32-bit aligned; core.l_qname includes these trailing NULs,"]
#[doc = "while core.l_extranul counts the excess NULs (so 0 <= l_extranul <= 3)."]
#[doc = "3. Cigar data is encoded 4 bytes per CIGAR operation."]
#[doc = "See the bam_cigar_* macros for manipulation."]
#[doc = "4. seq is nibble-encoded according to bam_nt16_table."]
#[doc = "See the bam_seqi macro for retrieving individual bases."]
#[doc = "5. Per base qualities are stored in the Phred scale with no +33 offset."]
#[doc = "Ie as per the BAM specification and not the SAM ASCII printable method."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bam1_t {
    pub core: bam1_core_t,
    pub id: u64,
    pub data: *mut u8,
    pub l_data: ::std::os::raw::c_int,
    pub m_data: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout_bam1_t() {
    assert_eq!(
        ::std::mem::size_of::<bam1_t>(),
        80usize,
        concat!("Size of: ", stringify!(bam1_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bam1_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bam1_t))
    );
    fn test_field_core() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bam1_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).core) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bam1_t),
                "::",
                stringify!(core)
            )
        );
    }
    test_field_core();
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bam1_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(bam1_t),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bam1_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(bam1_t),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_l_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bam1_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l_data) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(bam1_t),
                "::",
                stringify!(l_data)
            )
        );
    }
    test_field_l_data();
    fn test_field_m_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bam1_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m_data) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(bam1_t),
                "::",
                stringify!(m_data)
            )
        );
    }
    test_field_m_data();
}
impl bam1_t {
    #[inline]
    pub fn mempolicy(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_mempolicy(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mempolicy: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let mempolicy: u32 = unsafe { ::std::mem::transmute(mempolicy) };
            mempolicy as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " Generates a new unpopulated header structure."]
    #[doc = "*!"]
    #[doc = "*"]
    #[doc = "* @return  A valid pointer to new header on success, NULL on failure"]
    #[doc = "*"]
    #[doc = "* The sam_hdr_t struct returned by a successful call should be freed"]
    #[doc = "* via sam_hdr_destroy() when it is no longer needed."]
    #[doc = "*/"]
    pub fn sam_hdr_init() -> *mut sam_hdr_t;
}
extern "C" {
    #[doc = " Read the header from a BAM compressed file."]
    #[doc = "*!"]
    #[doc = "* @param fp  File pointer"]
    #[doc = "* @return    A valid pointer to new header on success, NULL on failure"]
    #[doc = "*"]
    #[doc = "* This function only works with BAM files.  It is usually better to use"]
    #[doc = "* sam_hdr_read(), which works on SAM, BAM and CRAM files."]
    #[doc = "*"]
    #[doc = "* The sam_hdr_t struct returned by a successful call should be freed"]
    #[doc = "* via sam_hdr_destroy() when it is no longer needed."]
    #[doc = "*/"]
    pub fn bam_hdr_read(fp: *mut BGZF) -> *mut sam_hdr_t;
}
extern "C" {
    #[doc = " Writes the header to a BAM file."]
    #[doc = "*!"]
    #[doc = "* @param fp  File pointer"]
    #[doc = "* @param h   Header pointer"]
    #[doc = "* @return    0 on success, -1 on failure"]
    #[doc = "*"]
    #[doc = "* This function only works with BAM files.  Use sam_hdr_write() to"]
    #[doc = "* write in any of the SAM, BAM or CRAM formats."]
    #[doc = "*/"]
    pub fn bam_hdr_write(fp: *mut BGZF, h: *const sam_hdr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Frees the resources associated with a header."]
    pub fn sam_hdr_destroy(h: *mut sam_hdr_t);
}
extern "C" {
    #[doc = " Duplicate a header structure."]
    #[doc = "*!"]
    #[doc = "* @return  A valid pointer to new header on success, NULL on failure"]
    #[doc = "*"]
    #[doc = "* The sam_hdr_t struct returned by a successful call should be freed"]
    #[doc = "* via sam_hdr_destroy() when it is no longer needed."]
    #[doc = "*/"]
    pub fn sam_hdr_dup(h0: *const sam_hdr_t) -> *mut sam_hdr_t;
}
#[doc = " @brief File handle returned by hts_open() etc."]
#[doc = " This structure should be considered opaque by end users. There should be"]
#[doc = " no need to access most fields directly in user code, and in cases where"]
#[doc = " it is desirable accessor functions such as hts_get_format() are provided."]
pub type samFile = htsFile;
extern "C" {
    #[doc = " Create a header from existing text."]
    #[doc = "*!"]
    #[doc = "* @param l_text    Length of text"]
    #[doc = "* @param text      Header text"]
    #[doc = "* @return A populated sam_hdr_t structure on success; NULL on failure."]
    #[doc = "* @note The text field of the returned header will be NULL, and the l_text"]
    #[doc = "* field will be zero."]
    #[doc = "*"]
    #[doc = "* The sam_hdr_t struct returned by a successful call should be freed"]
    #[doc = "* via sam_hdr_destroy() when it is no longer needed."]
    #[doc = "*/"]
    pub fn sam_hdr_parse(l_text: size_t, text: *const ::std::os::raw::c_char) -> *mut sam_hdr_t;
}
extern "C" {
    #[doc = " Read a header from a SAM, BAM or CRAM file."]
    #[doc = "*!"]
    #[doc = "* @param fp    Pointer to a SAM, BAM or CRAM file handle"]
    #[doc = "* @return  A populated sam_hdr_t struct on success; NULL on failure."]
    #[doc = "*"]
    #[doc = "* The sam_hdr_t struct returned by a successful call should be freed"]
    #[doc = "* via sam_hdr_destroy() when it is no longer needed."]
    #[doc = "*/"]
    pub fn sam_hdr_read(fp: *mut samFile) -> *mut sam_hdr_t;
}
extern "C" {
    #[doc = " Write a header to a SAM, BAM or CRAM file."]
    #[doc = "*!"]
    #[doc = "* @param fp    SAM, BAM or CRAM file header"]
    #[doc = "* @param h     Header structure to write"]
    #[doc = "* @return  0 on success; -1 on failure"]
    #[doc = "*/"]
    pub fn sam_hdr_write(fp: *mut samFile, h: *const sam_hdr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the current length of the header text."]
    #[doc = "*!"]
    #[doc = "* @return  >= 0 on success, SIZE_MAX on failure"]
    #[doc = "*/"]
    pub fn sam_hdr_length(h: *mut sam_hdr_t) -> size_t;
}
extern "C" {
    #[doc = " Returns the text representation of the header."]
    #[doc = "*!"]
    #[doc = "* @return  valid char pointer on success, NULL on failure"]
    #[doc = "*"]
    #[doc = "* The returned string is part of the header structure.  It will remain"]
    #[doc = "* valid until a call to a header API function causes the string to be"]
    #[doc = "* invalidated, or the header is destroyed."]
    #[doc = "*"]
    #[doc = "* The caller should not attempt to free or realloc this pointer."]
    #[doc = "*/"]
    pub fn sam_hdr_str(h: *mut sam_hdr_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the number of references in the header."]
    #[doc = "*!"]
    #[doc = "* @return  >= 0 on success, -1 on failure"]
    #[doc = "*/"]
    pub fn sam_hdr_nref(h: *const sam_hdr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add formatted lines to an existing header."]
    #[doc = "*!"]
    #[doc = "* @param lines  Full SAM header record, eg \"@SQ\\tSN:foo\\tLN:100\", with"]
    #[doc = "*               optional new-line. If it contains more than 1 line then"]
    #[doc = "*               multiple lines will be added in order"]
    #[doc = "* @param len    The maximum length of lines (if an early NUL is not"]
    #[doc = "*               encountered). len may be 0 if unknown, in which case"]
    #[doc = "*               lines must be NUL-terminated"]
    #[doc = "* @return       0 on success, -1 on failure"]
    #[doc = "*"]
    #[doc = "* The lines will be appended to the end of the existing header"]
    #[doc = "* (apart from HD, which always comes first)."]
    #[doc = "*/"]
    pub fn sam_hdr_add_lines(
        h: *mut sam_hdr_t,
        lines: *const ::std::os::raw::c_char,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Adds a single line to an existing header."]
    #[doc = "*!"]
    #[doc = "* Specify type and one or more key,value pairs, ending with the NULL key."]
    #[doc = "* Eg. sam_hdr_add_line(h, \"SQ\", \"ID\", \"foo\", \"LN\", \"100\", NULL)."]
    #[doc = "*"]
    #[doc = "* @param type  Type of the added line. Eg. \"SQ\""]
    #[doc = "* @return      0 on success, -1 on failure"]
    #[doc = "*"]
    #[doc = "* The new line will be added immediately after any others of the same"]
    #[doc = "* type, or at the end of the existing header if no lines of the"]
    #[doc = "* given type currently exist.  The exception is HD lines, which always"]
    #[doc = "* come first.  If an HD line already exists, it will be replaced."]
    #[doc = "*/"]
    pub fn sam_hdr_add_line(
        h: *mut sam_hdr_t,
        type_: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns a complete line of formatted text for a given type and ID."]
    #[doc = "*!"]
    #[doc = "* @param type      Type of the searched line. Eg. \"SQ\""]
    #[doc = "* @param ID_key    Tag key defining the line. Eg. \"SN\""]
    #[doc = "* @param ID_value  Tag value associated with the key above. Eg. \"ref1\""]
    #[doc = "* @param ks        kstring to hold the result"]
    #[doc = "* @return          0 on success;"]
    #[doc = "*                 -1 if no matching line is found"]
    #[doc = "*                 -2 on other failures"]
    #[doc = "*"]
    #[doc = "* Puts a complete line of formatted text for a specific header type/ID"]
    #[doc = "* combination into @p ks. If ID_key is NULL then it returns the first line of"]
    #[doc = "* the specified type."]
    #[doc = "*"]
    #[doc = "* Any existing content in @p ks will be overwritten."]
    #[doc = "*/"]
    pub fn sam_hdr_find_line_id(
        h: *mut sam_hdr_t,
        type_: *const ::std::os::raw::c_char,
        ID_key: *const ::std::os::raw::c_char,
        ID_val: *const ::std::os::raw::c_char,
        ks: *mut kstring_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns a complete line of formatted text for a given type and index."]
    #[doc = "*!"]
    #[doc = "* @param type      Type of the searched line. Eg. \"SQ\""]
    #[doc = "* @param position  Index in lines of this type (zero-based)"]
    #[doc = "* @param ks        kstring to hold the result"]
    #[doc = "* @return          0 on success;"]
    #[doc = "*                 -1 if no matching line is found"]
    #[doc = "*                 -2 on other failures"]
    #[doc = "*"]
    #[doc = "* Puts a complete line of formatted text for a specific line into @p ks."]
    #[doc = "* The header line is selected using the @p type and @p position parameters."]
    #[doc = "*"]
    #[doc = "* Any existing content in @p ks will be overwritten."]
    #[doc = "*/"]
    pub fn sam_hdr_find_line_pos(
        h: *mut sam_hdr_t,
        type_: *const ::std::os::raw::c_char,
        pos: ::std::os::raw::c_int,
        ks: *mut kstring_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove a line with given type / id from a header"]
    #[doc = "*!"]
    #[doc = "* @param type      Type of the searched line. Eg. \"SQ\""]
    #[doc = "* @param ID_key    Tag key defining the line. Eg. \"SN\""]
    #[doc = "* @param ID_value  Tag value associated with the key above. Eg. \"ref1\""]
    #[doc = "* @return          0 on success, -1 on error"]
    #[doc = "*"]
    #[doc = "* Remove a line from the header by specifying a tag:value that uniquely"]
    #[doc = "* identifies the line, i.e. the @SQ line containing \"SN:ref1\"."]
    #[doc = "*"]
    #[doc = "* \\@SQ line is uniquely identified by the SN tag."]
    #[doc = "* \\@RG line is uniquely identified by the ID tag."]
    #[doc = "* \\@PG line is uniquely identified by the ID tag."]
    #[doc = "* Eg. sam_hdr_remove_line_id(h, \"SQ\", \"SN\", \"ref1\")"]
    #[doc = "*"]
    #[doc = "* If no key:value pair is specified, the type MUST be followed by a NULL argument and"]
    #[doc = "* the first line of the type will be removed, if any."]
    #[doc = "* Eg. sam_hdr_remove_line_id(h, \"SQ\", NULL, NULL)"]
    #[doc = "*"]
    #[doc = "* @note Removing \\@PG lines is currently unsupported."]
    #[doc = "*/"]
    pub fn sam_hdr_remove_line_id(
        h: *mut sam_hdr_t,
        type_: *const ::std::os::raw::c_char,
        ID_key: *const ::std::os::raw::c_char,
        ID_value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove nth line of a given type from a header"]
    #[doc = "*!"]
    #[doc = "* @param type     Type of the searched line. Eg. \"SQ\""]
    #[doc = "* @param position Index in lines of this type (zero-based). E.g. 3"]
    #[doc = "* @return         0 on success, -1 on error"]
    #[doc = "*"]
    #[doc = "* Remove a line from the header by specifying the position in the type"]
    #[doc = "* group, i.e. 3rd @SQ line."]
    #[doc = "*/"]
    pub fn sam_hdr_remove_line_pos(
        h: *mut sam_hdr_t,
        type_: *const ::std::os::raw::c_char,
        position: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add or update tag key,value pairs in a header line."]
    #[doc = "*!"]
    #[doc = "* @param type      Type of the searched line. Eg. \"SQ\""]
    #[doc = "* @param ID_key    Tag key defining the line. Eg. \"SN\""]
    #[doc = "* @param ID_value  Tag value associated with the key above. Eg. \"ref1\""]
    #[doc = "* @return          0 on success, -1 on error"]
    #[doc = "*"]
    #[doc = "* Adds or updates tag key,value pairs in a header line."]
    #[doc = "* Eg. for adding M5 tags to @SQ lines or updating sort order for the"]
    #[doc = "* @HD line."]
    #[doc = "*"]
    #[doc = "* Specify multiple key,value pairs ending in NULL. Eg."]
    #[doc = "* sam_hdr_update_line(h, \"RG\", \"ID\", \"rg1\", \"DS\", \"description\", \"PG\", \"samtools\", NULL)"]
    #[doc = "*"]
    #[doc = "* Attempting to update the record name (i.e. @SQ SN or @RG ID) will"]
    #[doc = "* work as long as the new name is not already in use, however doing this"]
    #[doc = "* on a file opened for reading may produce unexpected results."]
    #[doc = "*"]
    #[doc = "* Renaming an @RG record in this way will only change the header.  Alignment"]
    #[doc = "* records written later will not be updated automatically even if they"]
    #[doc = "* reference the old read group name."]
    #[doc = "*"]
    #[doc = "* Attempting to change an @PG ID tag is not permitted."]
    #[doc = "*/"]
    pub fn sam_hdr_update_line(
        h: *mut sam_hdr_t,
        type_: *const ::std::os::raw::c_char,
        ID_key: *const ::std::os::raw::c_char,
        ID_value: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove all lines of a given type from a header, except the one matching an ID"]
    #[doc = "*!"]
    #[doc = "* @param type      Type of the searched line. Eg. \"SQ\""]
    #[doc = "* @param ID_key    Tag key defining the line. Eg. \"SN\""]
    #[doc = "* @param ID_value  Tag value associated with the key above. Eg. \"ref1\""]
    #[doc = "* @return          0 on success, -1 on failure"]
    #[doc = "*"]
    #[doc = "* Remove all lines of type <type> from the header, except the one"]
    #[doc = "* specified by tag:value, i.e. the @SQ line containing \"SN:ref1\"."]
    #[doc = "*"]
    #[doc = "* If no line matches the key:value ID, all lines of the given type are removed."]
    #[doc = "* To remove all lines of a given type, use NULL for both ID_key and ID_value."]
    #[doc = "*/"]
    pub fn sam_hdr_remove_except(
        h: *mut sam_hdr_t,
        type_: *const ::std::os::raw::c_char,
        ID_key: *const ::std::os::raw::c_char,
        ID_value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove header lines of a given type, except those in a given ID set"]
    #[doc = "*!"]
    #[doc = "* @param type  Type of the searched line. Eg. \"RG\""]
    #[doc = "* @param id    Tag key defining the line. Eg. \"ID\""]
    #[doc = "* @param rh    Hash set initialised by the caller with the values to be kept."]
    #[doc = "*              See description for how to create this. If @p rh is NULL, all"]
    #[doc = "*              lines of this type will be removed."]
    #[doc = "* @return      0 on success, -1 on failure"]
    #[doc = "*"]
    #[doc = "* Remove all lines of type @p type from the header, except the ones"]
    #[doc = "* specified in the hash set @p rh. If @p rh is NULL, all lines of"]
    #[doc = "* this type will be removed."]
    #[doc = "* Declaration of @p rh is done using KHASH_SET_INIT_STR macro. Eg."]
    #[doc = "* @code{.c}"]
    #[doc = "*              #include \"htslib/khash.h\""]
    #[doc = "*              KHASH_SET_INIT_STR(keep)"]
    #[doc = "*              typedef khash_t(keep) *keephash_t;"]
    #[doc = "*"]
    #[doc = "*              void your_method() {"]
    #[doc = "*                  samFile *sf = sam_open(\"alignment.bam\", \"r\");"]
    #[doc = "*                  sam_hdr_t *h = sam_hdr_read(sf);"]
    #[doc = "*                  keephash_t rh = kh_init(keep);"]
    #[doc = "*                  int ret = 0;"]
    #[doc = "*                  kh_put(keep, rh, strdup(\"chr2\"), &ret);"]
    #[doc = "*                  kh_put(keep, rh, strdup(\"chr3\"), &ret);"]
    #[doc = "*                  if (sam_hdr_remove_lines(h, \"SQ\", \"SN\", rh) == -1)"]
    #[doc = "*                      fprintf(stderr, \"Error removing lines\\n\");"]
    #[doc = "*                  khint_t k;"]
    #[doc = "*                  for (k = 0; k < kh_end(rh); ++k)"]
    #[doc = "*                     if (kh_exist(rh, k)) free((char*)kh_key(rh, k));"]
    #[doc = "*                  kh_destroy(keep, rh);"]
    #[doc = "*                  sam_hdr_destroy(h);"]
    #[doc = "*                  sam_close(sf);"]
    #[doc = "*              }"]
    #[doc = "* @endcode"]
    #[doc = "*"]
    #[doc = "*/"]
    pub fn sam_hdr_remove_lines(
        h: *mut sam_hdr_t,
        type_: *const ::std::os::raw::c_char,
        id: *const ::std::os::raw::c_char,
        rh: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Count the number of lines for a given header type"]
    #[doc = "*!"]
    #[doc = "* @param h     BAM header"]
    #[doc = "* @param type  Header type to count. Eg. \"RG\""]
    #[doc = "* @return  Number of lines of this type on success; -1 on failure"]
    #[doc = "*/"]
    pub fn sam_hdr_count_lines(
        h: *mut sam_hdr_t,
        type_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Index of the line for the types that have dedicated look-up tables (SQ, RG, PG)"]
    #[doc = "*!"]
    #[doc = "* @param h     BAM header"]
    #[doc = "* @param type  Type of the searched line. Eg. \"RG\""]
    #[doc = "* @param key   The value of the identifying key. Eg. \"rg1\""]
    #[doc = "* @return  0-based index on success; -1 if line does not exist; -2 on failure"]
    #[doc = "*/"]
    pub fn sam_hdr_line_index(
        bh: *mut sam_hdr_t,
        type_: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Id key of the line for the types that have dedicated look-up tables (SQ, RG, PG)"]
    #[doc = "*!"]
    #[doc = "* @param h     BAM header"]
    #[doc = "* @param type  Type of the searched line. Eg. \"RG\""]
    #[doc = "* @param pos   Zero-based index inside the type group. Eg. 2 (for the third RG line)"]
    #[doc = "* @return  Valid key string on success; NULL on failure"]
    #[doc = "*/"]
    pub fn sam_hdr_line_name(
        bh: *mut sam_hdr_t,
        type_: *const ::std::os::raw::c_char,
        pos: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the value associated with a key for a header line identified by ID_key:ID_val"]
    #[doc = "*!"]
    #[doc = "* @param type      Type of the line to which the tag belongs. Eg. \"SQ\""]
    #[doc = "* @param ID_key    Tag key defining the line. Eg. \"SN\". Can be NULL, if looking for the first line."]
    #[doc = "* @param ID_value  Tag value associated with the key above. Eg. \"ref1\". Can be NULL, if ID_key is NULL."]
    #[doc = "* @param key       Key of the searched tag. Eg. \"LN\""]
    #[doc = "* @param ks        kstring where the value will be written"]
    #[doc = "* @return          0 on success"]
    #[doc = "*                 -1 if the requested tag does not exist"]
    #[doc = "*                 -2 on other errors"]
    #[doc = "*"]
    #[doc = "* Looks for a specific key in a single SAM header line and writes the"]
    #[doc = "* associated value into @p ks.  The header line is selected using the ID_key"]
    #[doc = "* and ID_value parameters.  Any pre-existing content in @p ks will be"]
    #[doc = "* overwritten."]
    #[doc = "*/"]
    pub fn sam_hdr_find_tag_id(
        h: *mut sam_hdr_t,
        type_: *const ::std::os::raw::c_char,
        ID_key: *const ::std::os::raw::c_char,
        ID_value: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
        ks: *mut kstring_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the value associated with a key for a header line identified by position"]
    #[doc = "*!"]
    #[doc = "* @param type      Type of the line to which the tag belongs. Eg. \"SQ\""]
    #[doc = "* @param position  Index in lines of this type (zero-based). E.g. 3"]
    #[doc = "* @param key       Key of the searched tag. Eg. \"LN\""]
    #[doc = "* @param ks        kstring where the value will be written"]
    #[doc = "* @return          0 on success"]
    #[doc = "*                 -1 if the requested tag does not exist"]
    #[doc = "*                 -2 on other errors"]
    #[doc = "*"]
    #[doc = "* Looks for a specific key in a single SAM header line and writes the"]
    #[doc = "* associated value into @p ks.  The header line is selected using the @p type"]
    #[doc = "* and @p position parameters.  Any pre-existing content in @p ks will be"]
    #[doc = "* overwritten."]
    #[doc = "*/"]
    pub fn sam_hdr_find_tag_pos(
        h: *mut sam_hdr_t,
        type_: *const ::std::os::raw::c_char,
        pos: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
        ks: *mut kstring_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove the key from the line identified by type, ID_key and ID_value."]
    #[doc = "*!"]
    #[doc = "* @param type      Type of the line to which the tag belongs. Eg. \"SQ\""]
    #[doc = "* @param ID_key    Tag key defining the line. Eg. \"SN\""]
    #[doc = "* @param ID_value  Tag value associated with the key above. Eg. \"ref1\""]
    #[doc = "* @param key       Key of the targeted tag. Eg. \"M5\""]
    #[doc = "* @return          1 if the key was removed; 0 if it was not present; -1 on error"]
    #[doc = "*/"]
    pub fn sam_hdr_remove_tag_id(
        h: *mut sam_hdr_t,
        type_: *const ::std::os::raw::c_char,
        ID_key: *const ::std::os::raw::c_char,
        ID_value: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the target id for a given reference sequence name"]
    #[doc = "*!"]
    #[doc = "* @param ref  Reference name"]
    #[doc = "* @return     Positive value on success,"]
    #[doc = "*             -1 if unknown reference,"]
    #[doc = "*             -2 if the header could not be parsed"]
    #[doc = "*"]
    #[doc = "* Looks up a reference sequence by name in the reference hash table"]
    #[doc = "* and returns the numerical target id."]
    #[doc = "*/"]
    pub fn sam_hdr_name2tid(
        h: *mut sam_hdr_t,
        ref_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the reference sequence name from a target index"]
    #[doc = "*!"]
    #[doc = "* @param tid  Target index"]
    #[doc = "* @return     Valid reference name on success, NULL on failure"]
    #[doc = "*"]
    #[doc = "* Fetch the reference sequence name from the target name array,"]
    #[doc = "* using the numerical target id."]
    #[doc = "*/"]
    pub fn sam_hdr_tid2name(
        h: *const sam_hdr_t,
        tid: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the reference sequence length from a target index"]
    #[doc = "*!"]
    #[doc = "* @param tid  Target index"]
    #[doc = "* @return     Strictly positive value on success, 0 on failure"]
    #[doc = "*"]
    #[doc = "* Fetch the reference sequence length from the target length array,"]
    #[doc = "* using the numerical target id."]
    #[doc = "*/"]
    pub fn sam_hdr_tid2len(h: *const sam_hdr_t, tid: ::std::os::raw::c_int) -> hts_pos_t;
}
extern "C" {
    #[doc = " Generate a unique \\@PG ID: value"]
    #[doc = "*!"]
    #[doc = "* @param name  Name of the program. Eg. samtools"]
    #[doc = "* @return      Valid ID on success, NULL on failure"]
    #[doc = "*"]
    #[doc = "* Returns a unique ID from a base name.  The string returned will remain"]
    #[doc = "* valid until the next call to this function, or the header is destroyed."]
    #[doc = "* The caller should not attempt to free() or realloc() it."]
    #[doc = "*/"]
    pub fn sam_hdr_pg_id(
        h: *mut sam_hdr_t,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Add an \\@PG line."]
    #[doc = "*!"]
    #[doc = "* @param name  Name of the program. Eg. samtools"]
    #[doc = "* @return      0 on success, -1 on failure"]
    #[doc = "*"]
    #[doc = "* If we wish complete control over this use sam_hdr_add_line() directly. This"]
    #[doc = "* function uses that, but attempts to do a lot of tedious house work for"]
    #[doc = "* you too."]
    #[doc = "*"]
    #[doc = "* - It will generate a suitable ID if the supplied one clashes."]
    #[doc = "* - It will generate multiple \\@PG records if we have multiple PG chains."]
    #[doc = "*"]
    #[doc = "* Call it as per sam_hdr_add_line() with a series of key,value pairs ending"]
    #[doc = "* in NULL."]
    #[doc = "*/"]
    pub fn sam_hdr_add_pg(
        h: *mut sam_hdr_t,
        name: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A function to help with construction of CL tags in @PG records."]
    #[doc = " Takes an argc, argv pair and returns a single space-separated string."]
    #[doc = " This string should be deallocated by the calling function."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Returns malloced char * on success;"]
    #[doc = "         NULL on failure"]
    pub fn stringify_argv(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Increments the reference count on a header"]
    #[doc = "*!"]
    #[doc = "* This permits multiple files to share the same header, all calling"]
    #[doc = "* sam_hdr_destroy when done, without causing errors for other open files."]
    #[doc = "*/"]
    pub fn sam_hdr_incr_ref(h: *mut sam_hdr_t);
}
extern "C" {
    #[doc = " Create a new bam1_t alignment structure"]
    #[doc = "**"]
    #[doc = "@return An empty bam1_t structure on success, NULL on failure"]
    #[doc = ""]
    #[doc = "The bam1_t struct returned by a successful call should be freed"]
    #[doc = "via bam_destroy1() when it is no longer needed."]
    #[doc = "*/"]
    pub fn bam_init1() -> *mut bam1_t;
}
extern "C" {
    #[doc = " Destroy a bam1_t structure"]
    #[doc = "**"]
    #[doc = "@param b  structure to destroy"]
    #[doc = ""]
    #[doc = "Does nothing if @p b is NULL.  If not, all memory associated with @p b"]
    #[doc = "will be freed, along with the structure itself.  @p b should not be"]
    #[doc = "accessed after calling this function."]
    #[doc = "*/"]
    pub fn bam_destroy1(b: *mut bam1_t);
}
extern "C" {
    #[doc = " Read a BAM format alignment record"]
    #[doc = "**"]
    #[doc = "@param fp   BGZF file being read"]
    #[doc = "@param b    Destination for the alignment data"]
    #[doc = "@return number of bytes read on success"]
    #[doc = "-1 at end of file"]
    #[doc = "< -1 on failure"]
    #[doc = ""]
    #[doc = "This function can only read BAM format files.  Most code should use"]
    #[doc = "sam_read1() instead, which can be used with BAM, SAM and CRAM formats."]
    #[doc = "*/"]
    pub fn bam_read1(fp: *mut BGZF, b: *mut bam1_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write a BAM format alignment record"]
    #[doc = "**"]
    #[doc = "@param fp  BGZF file being written"]
    #[doc = "@param b   Alignment record to write"]
    #[doc = "@return number of bytes written on success"]
    #[doc = "-1 on error"]
    #[doc = ""]
    #[doc = "This function can only write BAM format files.  Most code should use"]
    #[doc = "sam_write1() instead, which can be used with BAM, SAM and CRAM formats."]
    #[doc = "*/"]
    pub fn bam_write1(fp: *mut BGZF, b: *const bam1_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy alignment record data"]
    #[doc = "**"]
    #[doc = "@param bdst  Destination alignment record"]
    #[doc = "@param bsrc  Source alignment record"]
    #[doc = "@return bdst on success; NULL on failure"]
    #[doc = "*/"]
    pub fn bam_copy1(bdst: *mut bam1_t, bsrc: *const bam1_t) -> *mut bam1_t;
}
extern "C" {
    #[doc = " Create a duplicate alignment record"]
    #[doc = "**"]
    #[doc = "@param bsrc  Source alignment record"]
    #[doc = "@return Pointer to a new alignment record on success; NULL on failure"]
    #[doc = ""]
    #[doc = "The bam1_t struct returned by a successful call should be freed"]
    #[doc = "via bam_destroy1() when it is no longer needed."]
    #[doc = "*/"]
    pub fn bam_dup1(bsrc: *const bam1_t) -> *mut bam1_t;
}
extern "C" {
    #[doc = " Sets all components of an alignment structure"]
    #[doc = "**"]
    #[doc = "@param bam      Target alignment structure. Must be initialized by a call to bam_init1()."]
    #[doc = "The data field will be reallocated automatically as needed."]
    #[doc = "@param l_qname  Length of the query name. If set to 0, the placeholder query name \"*\" will be used."]
    #[doc = "@param qname    Query name, may be NULL if l_qname = 0"]
    #[doc = "@param flag     Bitwise flag, a combination of the BAM_F* constants."]
    #[doc = "@param tid      Chromosome ID, defined by sam_hdr_t (a.k.a. RNAME)."]
    #[doc = "@param pos      0-based leftmost coordinate."]
    #[doc = "@param mapq     Mapping quality."]
    #[doc = "@param n_cigar  Number of CIGAR operations."]
    #[doc = "@param cigar    CIGAR data, may be NULL if n_cigar = 0."]
    #[doc = "@param mtid     Chromosome ID of next read in template, defined by sam_hdr_t (a.k.a. RNEXT)."]
    #[doc = "@param mpos     0-based leftmost coordinate of next read in template (a.k.a. PNEXT)."]
    #[doc = "@param isize    Observed template length (\"insert size\") (a.k.a. TLEN)."]
    #[doc = "@param l_seq    Length of the query sequence (read) and sequence quality string."]
    #[doc = "@param seq      Sequence, may be NULL if l_seq = 0."]
    #[doc = "@param qual     Sequence quality, may be NULL."]
    #[doc = "@param l_aux    Length to be reserved for auxiliary field data, may be 0."]
    #[doc = ""]
    #[doc = "@return >= 0 on success (number of bytes written to bam->data), negative (with errno set) on failure."]
    #[doc = "*/"]
    pub fn bam_set1(
        bam: *mut bam1_t,
        l_qname: size_t,
        qname: *const ::std::os::raw::c_char,
        flag: u16,
        tid: i32,
        pos: hts_pos_t,
        mapq: u8,
        n_cigar: size_t,
        cigar: *const u32,
        mtid: i32,
        mpos: hts_pos_t,
        isize_: hts_pos_t,
        l_seq: size_t,
        seq: *const ::std::os::raw::c_char,
        qual: *const ::std::os::raw::c_char,
        l_aux: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Calculate query length from CIGAR data"]
    #[doc = "**"]
    #[doc = "@param n_cigar   Number of items in @p cigar"]
    #[doc = "@param cigar     CIGAR data"]
    #[doc = "@return Query length"]
    #[doc = ""]
    #[doc = "CIGAR data is stored as in the BAM format, i.e. (op_len << 4) | op"]
    #[doc = "where op_len is the length in bases and op is a value between 0 and 8"]
    #[doc = "representing one of the operations \"MIDNSHP=X\" (M = 0; X = 8)"]
    #[doc = ""]
    #[doc = "This function returns the sum of the lengths of the M, I, S, = and X"]
    #[doc = "operations in @p cigar (these are the operations that \"consume\" query"]
    #[doc = "bases).  All other operations (including invalid ones) are ignored."]
    #[doc = ""]
    #[doc = "@note This return type of this function is hts_pos_t so that it can"]
    #[doc = "correctly return the length of CIGAR sequences including many long"]
    #[doc = "operations without overflow. However, other restrictions (notably the sizes"]
    #[doc = "of bam1_core_t::l_qseq and bam1_t::data) limit the maximum query sequence"]
    #[doc = "length supported by HTSlib to fewer than INT_MAX bases."]
    #[doc = "*/"]
    pub fn bam_cigar2qlen(n_cigar: ::std::os::raw::c_int, cigar: *const u32) -> hts_pos_t;
}
extern "C" {
    #[doc = " Calculate reference length from CIGAR data"]
    #[doc = "**"]
    #[doc = "@param n_cigar   Number of items in @p cigar"]
    #[doc = "@param cigar     CIGAR data"]
    #[doc = "@return Reference length"]
    #[doc = ""]
    #[doc = "CIGAR data is stored as in the BAM format, i.e. (op_len << 4) | op"]
    #[doc = "where op_len is the length in bases and op is a value between 0 and 8"]
    #[doc = "representing one of the operations \"MIDNSHP=X\" (M = 0; X = 8)"]
    #[doc = ""]
    #[doc = "This function returns the sum of the lengths of the M, D, N, = and X"]
    #[doc = "operations in @p cigar (these are the operations that \"consume\" reference"]
    #[doc = "bases).  All other operations (including invalid ones) are ignored."]
    #[doc = "*/"]
    pub fn bam_cigar2rlen(n_cigar: ::std::os::raw::c_int, cigar: *const u32) -> hts_pos_t;
}
extern "C" {
    #[doc = "@abstract Calculate the rightmost base position of an alignment on the"]
    #[doc = "reference genome."]
    #[doc = ""]
    #[doc = "@param  b  pointer to an alignment"]
    #[doc = "@return    the coordinate of the first base after the alignment, 0-based"]
    #[doc = ""]
    #[doc = "@discussion For a mapped read, this is just b->core.pos + bam_cigar2rlen."]
    #[doc = "For an unmapped read (either according to its flags or if it has no cigar"]
    #[doc = "string) or a read whose cigar string consumes no reference bases at all,"]
    #[doc = "we return b->core.pos + 1 by convention."]
    pub fn bam_endpos(b: *const bam1_t) -> hts_pos_t;
}
extern "C" {
    pub fn bam_str2flag(str_: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns negative value on error"]
    pub fn bam_flag2str(flag: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @function"]
    #[doc = "@abstract  Set the name of the query"]
    #[doc = "@param  b  pointer to an alignment"]
    #[doc = "@return    0 on success, -1 on failure"]
    pub fn bam_set_qname(
        b: *mut bam1_t,
        qname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @function"]
    #[doc = "@abstract  Parse a CIGAR string into a uint32_t array"]
    #[doc = "@param  in      [in]  pointer to the source string"]
    #[doc = "@param  end     [out] address of the pointer to the new end of the input string"]
    #[doc = "can be NULL"]
    #[doc = "@param  a_cigar [in/out]  address of the destination uint32_t buffer"]
    #[doc = "@param  a_mem   [in/out]  address of the allocated number of buffer elements"]
    #[doc = "@return         number of processed CIGAR operators; -1 on error"]
    pub fn sam_parse_cigar(
        in_: *const ::std::os::raw::c_char,
        end: *mut *mut ::std::os::raw::c_char,
        a_cigar: *mut *mut u32,
        a_mem: *mut size_t,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " @function"]
    #[doc = "@abstract  Parse a CIGAR string into a bam1_t struct"]
    #[doc = "@param  in      [in]  pointer to the source string"]
    #[doc = "@param  end     [out] address of the pointer to the new end of the input string"]
    #[doc = "can be NULL"]
    #[doc = "@param  b       [in/out]  address of the destination bam1_t struct"]
    #[doc = "@return         number of processed CIGAR operators; -1 on error"]
    pub fn bam_parse_cigar(
        in_: *const ::std::os::raw::c_char,
        end: *mut *mut ::std::os::raw::c_char,
        b: *mut bam1_t,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " Initialise fp->idx for the current format type for SAM, BAM and CRAM types ."]
    #[doc = "** @param fp        File handle for the data file being written."]
    #[doc = "@param h         Bam header structured (needed for BAI and CSI)."]
    #[doc = "@param min_shift 0 for BAI, or larger for CSI (CSI defaults to 14)."]
    #[doc = "@param fnidx     Filename to write index to.  This pointer must remain valid"]
    #[doc = "until after sam_idx_save is called."]
    #[doc = "@return          0 on success, <0 on failure."]
    #[doc = ""]
    #[doc = "@note This must be called after the header has been written, but before"]
    #[doc = "any other data."]
    #[doc = "*/"]
    pub fn sam_idx_init(
        fp: *mut htsFile,
        h: *mut sam_hdr_t,
        min_shift: ::std::os::raw::c_int,
        fnidx: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Writes the index initialised with sam_idx_init to disk."]
    #[doc = "** @param fp        File handle for the data file being written."]
    #[doc = "@return          0 on success, <0 on failure."]
    #[doc = "*/"]
    pub fn sam_idx_save(fp: *mut htsFile) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Load a BAM (.csi or .bai) or CRAM (.crai) index file"]
    #[doc = "** @param fp  File handle of the data file whose index is being opened"]
    #[doc = "@param fn  BAM/CRAM/etc filename to search alongside for the index file"]
    #[doc = "@return  The index, or NULL if an error occurred."]
    #[doc = ""]
    #[doc = "Equivalent to sam_index_load3(fp, fn, NULL, HTS_IDX_SAVE_REMOTE);"]
    #[doc = "*/"]
    pub fn sam_index_load(fp: *mut htsFile, fn_: *const ::std::os::raw::c_char) -> *mut hts_idx_t;
}
extern "C" {
    #[doc = " Load a specific BAM (.csi or .bai) or CRAM (.crai) index file"]
    #[doc = "** @param fp     File handle of the data file whose index is being opened"]
    #[doc = "@param fn     BAM/CRAM/etc data file filename"]
    #[doc = "@param fnidx  Index filename, or NULL to search alongside @a fn"]
    #[doc = "@return  The index, or NULL if an error occurred."]
    #[doc = ""]
    #[doc = "Equivalent to sam_index_load3(fp, fn, fnidx, HTS_IDX_SAVE_REMOTE);"]
    #[doc = "*/"]
    pub fn sam_index_load2(
        fp: *mut htsFile,
        fn_: *const ::std::os::raw::c_char,
        fnidx: *const ::std::os::raw::c_char,
    ) -> *mut hts_idx_t;
}
extern "C" {
    #[doc = " Load or stream a BAM (.csi or .bai) or CRAM (.crai) index file"]
    #[doc = "** @param fp     File handle of the data file whose index is being opened"]
    #[doc = "@param fn     BAM/CRAM/etc data file filename"]
    #[doc = "@param fnidx  Index filename, or NULL to search alongside @a fn"]
    #[doc = "@param flags  Flags to alter behaviour (see description)"]
    #[doc = "@return  The index, or NULL if an error occurred."]
    #[doc = ""]
    #[doc = "The @p flags parameter can be set to a combination of the following values:"]
    #[doc = ""]
    #[doc = "HTS_IDX_SAVE_REMOTE   Save a local copy of any remote indexes"]
    #[doc = "HTS_IDX_SILENT_FAIL   Fail silently if the index is not present"]
    #[doc = ""]
    #[doc = "Note that HTS_IDX_SAVE_REMOTE has no effect for remote CRAM indexes.  They"]
    #[doc = "are always downloaded and never cached locally."]
    #[doc = ""]
    #[doc = "The index struct returned by a successful call should be freed"]
    #[doc = "via hts_idx_destroy() when it is no longer needed."]
    #[doc = "*/"]
    pub fn sam_index_load3(
        fp: *mut htsFile,
        fn_: *const ::std::os::raw::c_char,
        fnidx: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> *mut hts_idx_t;
}
extern "C" {
    #[doc = " Generate and save an index file"]
    #[doc = "** @param fn        Input BAM/etc filename, to which .csi/etc will be added"]
    #[doc = "@param min_shift Positive to generate CSI, or 0 to generate BAI"]
    #[doc = "@return  0 if successful, or negative if an error occurred (usually -1; or"]
    #[doc = "-2: opening fn failed; -3: format not indexable; -4:"]
    #[doc = "failed to create and/or save the index)"]
    #[doc = "*/"]
    pub fn sam_index_build(
        fn_: *const ::std::os::raw::c_char,
        min_shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Generate and save an index to a specific file"]
    #[doc = "** @param fn        Input BAM/CRAM/etc filename"]
    #[doc = "@param fnidx     Output filename, or NULL to add .bai/.csi/etc to @a fn"]
    #[doc = "@param min_shift Positive to generate CSI, or 0 to generate BAI"]
    #[doc = "@return  0 if successful, or negative if an error occurred (see"]
    #[doc = "sam_index_build for error codes)"]
    #[doc = "*/"]
    pub fn sam_index_build2(
        fn_: *const ::std::os::raw::c_char,
        fnidx: *const ::std::os::raw::c_char,
        min_shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Generate and save an index to a specific file"]
    #[doc = "** @param fn        Input BAM/CRAM/etc filename"]
    #[doc = "@param fnidx     Output filename, or NULL to add .bai/.csi/etc to @a fn"]
    #[doc = "@param min_shift Positive to generate CSI, or 0 to generate BAI"]
    #[doc = "@param nthreads  Number of threads to use when building the index"]
    #[doc = "@return  0 if successful, or negative if an error occurred (see"]
    #[doc = "sam_index_build for error codes)"]
    #[doc = "*/"]
    pub fn sam_index_build3(
        fn_: *const ::std::os::raw::c_char,
        fnidx: *const ::std::os::raw::c_char,
        min_shift: ::std::os::raw::c_int,
        nthreads: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a BAM/CRAM iterator"]
    #[doc = "** @param idx     Index"]
    #[doc = "@param tid     Target id"]
    #[doc = "@param beg     Start position in target"]
    #[doc = "@param end     End position in target"]
    #[doc = "@return An iterator on success; NULL on failure"]
    #[doc = ""]
    #[doc = "The following special values (defined in htslib/hts.h)can be used for @p tid."]
    #[doc = "When using one of these values, @p beg and @p end are ignored."]
    #[doc = ""]
    #[doc = "HTS_IDX_NOCOOR iterates over unmapped reads sorted at the end of the file"]
    #[doc = "HTS_IDX_START  iterates over the entire file"]
    #[doc = "HTS_IDX_REST   iterates from the current position to the end of the file"]
    #[doc = "HTS_IDX_NONE   always returns \"no more alignment records\""]
    #[doc = ""]
    #[doc = "When using HTS_IDX_REST or HTS_IDX_NONE, NULL can be passed in to @p idx."]
    #[doc = "*/"]
    pub fn sam_itr_queryi(
        idx: *const hts_idx_t,
        tid: ::std::os::raw::c_int,
        beg: hts_pos_t,
        end: hts_pos_t,
    ) -> *mut hts_itr_t;
}
extern "C" {
    #[doc = " Create a SAM/BAM/CRAM iterator"]
    #[doc = "** @param idx     Index"]
    #[doc = "@param hdr     Header"]
    #[doc = "@param region  Region specification"]
    #[doc = "@return An iterator on success; NULL on failure"]
    #[doc = ""]
    #[doc = "Regions are parsed by hts_parse_reg(), and take one of the following forms:"]
    #[doc = ""]
    #[doc = "region          | Outputs"]
    #[doc = "--------------- | -------------"]
    #[doc = "REF             | All reads with RNAME REF"]
    #[doc = "REF:            | All reads with RNAME REF"]
    #[doc = "REF:START       | Reads with RNAME REF overlapping START to end of REF"]
    #[doc = "REF:-END        | Reads with RNAME REF overlapping start of REF to END"]
    #[doc = "REF:START-END   | Reads with RNAME REF overlapping START to END"]
    #[doc = ".               | All reads from the start of the file"]
    #[doc = "*               | Unmapped reads at the end of the file (RNAME '*' in SAM)"]
    #[doc = ""]
    #[doc = "The form `REF:` should be used when the reference name itself contains a colon."]
    #[doc = ""]
    #[doc = "Note that SAM files must be bgzf-compressed for iterators to work."]
    #[doc = "*/"]
    pub fn sam_itr_querys(
        idx: *const hts_idx_t,
        hdr: *mut sam_hdr_t,
        region: *const ::std::os::raw::c_char,
    ) -> *mut hts_itr_t;
}
extern "C" {
    #[doc = " Create a multi-region iterator"]
    #[doc = "** @param idx       Index"]
    #[doc = "@param hdr       Header"]
    #[doc = "@param reglist   Array of regions to iterate over"]
    #[doc = "@param regcount  Number of items in reglist"]
    #[doc = ""]
    #[doc = "Each @p reglist entry should have the reference name in the `reg` field, an"]
    #[doc = "array of regions for that reference in `intervals` and the number of items"]
    #[doc = "in `intervals` should be stored in `count`.  No other fields need to be filled"]
    #[doc = "in."]
    #[doc = ""]
    #[doc = "The iterator will return all reads overlapping the given regions.  If a read"]
    #[doc = "overlaps more than one region, it will only be returned once."]
    #[doc = "*/"]
    pub fn sam_itr_regions(
        idx: *const hts_idx_t,
        hdr: *mut sam_hdr_t,
        reglist: *mut hts_reglist_t,
        regcount: ::std::os::raw::c_uint,
    ) -> *mut hts_itr_t;
}
extern "C" {
    #[doc = " Create a multi-region iterator"]
    #[doc = "** @param idx       Index"]
    #[doc = "@param hdr       Header"]
    #[doc = "@param regarray  Array of ref:interval region specifiers"]
    #[doc = "@param regcount  Number of items in regarray"]
    #[doc = ""]
    #[doc = "Each @p regarray entry is parsed by hts_parse_reg(), and takes one of the"]
    #[doc = "following forms:"]
    #[doc = ""]
    #[doc = "region          | Outputs"]
    #[doc = "--------------- | -------------"]
    #[doc = "REF             | All reads with RNAME REF"]
    #[doc = "REF:            | All reads with RNAME REF"]
    #[doc = "REF:START       | Reads with RNAME REF overlapping START to end of REF"]
    #[doc = "REF:-END        | Reads with RNAME REF overlapping start of REF to END"]
    #[doc = "REF:START-END   | Reads with RNAME REF overlapping START to END"]
    #[doc = ".               | All reads from the start of the file"]
    #[doc = "*               | Unmapped reads at the end of the file (RNAME '*' in SAM)"]
    #[doc = ""]
    #[doc = "The form `REF:` should be used when the reference name itself contains a colon."]
    #[doc = ""]
    #[doc = "The iterator will return all reads overlapping the given regions.  If a read"]
    #[doc = "overlaps more than one region, it will only be returned once."]
    #[doc = "*/"]
    pub fn sam_itr_regarray(
        idx: *const hts_idx_t,
        hdr: *mut sam_hdr_t,
        regarray: *mut *mut ::std::os::raw::c_char,
        regcount: ::std::os::raw::c_uint,
    ) -> *mut hts_itr_t;
}
extern "C" {
    pub fn sam_parse_region(
        h: *mut sam_hdr_t,
        s: *const ::std::os::raw::c_char,
        tid: *mut ::std::os::raw::c_int,
        beg: *mut hts_pos_t,
        end: *mut hts_pos_t,
        flags: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sam_open_mode(
        mode: *mut ::std::os::raw::c_char,
        fn_: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sam_open_mode_opts(
        fn_: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sam_hdr_change_HD(
        h: *mut sam_hdr_t,
        key: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sam_parse1(
        s: *mut kstring_t,
        h: *mut sam_hdr_t,
        b: *mut bam1_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sam_format1(
        h: *const sam_hdr_t,
        b: *const bam1_t,
        str_: *mut kstring_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sam_read1 - Read a record from a file"]
    #[doc = "** @param fp   Pointer to the source file"]
    #[doc = "*  @param h    Pointer to the header previously read (fully or partially)"]
    #[doc = "*  @param b    Pointer to the record placeholder"]
    #[doc = "*  @return >= 0 on successfully reading a new record, -1 on end of stream, < -1 on error"]
    #[doc = "*/"]
    pub fn sam_read1(fp: *mut samFile, h: *mut sam_hdr_t, b: *mut bam1_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sam_write1 - Write a record to a file"]
    #[doc = "** @param fp    Pointer to the destination file"]
    #[doc = "*  @param h     Pointer to the header structure previously read"]
    #[doc = "*  @param b     Pointer to the record to be written"]
    #[doc = "*  @return >= 0 on successfully writing the record, -1 on error"]
    #[doc = "*/"]
    pub fn sam_write1(
        fp: *mut samFile,
        h: *const sam_hdr_t,
        b: *const bam1_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sam_passes_filter - Checks whether a record passes an hts_filter."]
    #[doc = "** @param h      Pointer to the header structure previously read"]
    #[doc = "*  @param b      Pointer to the BAM record to be checked"]
    #[doc = "*  @param filt   Pointer to the filter, created from hts_filter_init."]
    #[doc = "*  @return       1 if passes, 0 if not, and <0 on error."]
    #[doc = "*/"]
    pub fn sam_passes_filter(
        h: *const sam_hdr_t,
        b: *const bam1_t,
        filt: *mut hts_filter_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a pointer to an aux record"]
    #[doc = "** @param b   Pointer to the bam record"]
    #[doc = "@param tag Desired aux tag"]
    #[doc = "@return Pointer to the tag data, or NULL if tag is not present or on error"]
    #[doc = "If the tag is not present, this function returns NULL and sets errno to"]
    #[doc = "ENOENT.  If the bam record's aux data is corrupt (either a tag has an"]
    #[doc = "invalid type, or the last record is incomplete) then errno is set to"]
    #[doc = "EINVAL and NULL is returned."]
    #[doc = "*/"]
    pub fn bam_aux_get(b: *const bam1_t, tag: *const ::std::os::raw::c_char) -> *mut u8;
}
extern "C" {
    #[doc = " Get an integer aux value"]
    #[doc = "** @param s Pointer to the tag data, as returned by bam_aux_get()"]
    #[doc = "@return The value, or 0 if the tag was not an integer type"]
    #[doc = "If the tag is not an integer type, errno is set to EINVAL.  This function"]
    #[doc = "will not return the value of floating-point tags."]
    #[doc = "*/"]
    pub fn bam_aux2i(s: *const u8) -> i64;
}
extern "C" {
    #[doc = " Get an integer aux value"]
    #[doc = "** @param s Pointer to the tag data, as returned by bam_aux_get()"]
    #[doc = "@return The value, or 0 if the tag was not an integer type"]
    #[doc = "If the tag is not an numeric type, errno is set to EINVAL.  The value of"]
    #[doc = "integer flags will be returned cast to a double."]
    #[doc = "*/"]
    pub fn bam_aux2f(s: *const u8) -> f64;
}
extern "C" {
    #[doc = " Get a character aux value"]
    #[doc = "** @param s Pointer to the tag data, as returned by bam_aux_get()."]
    #[doc = "@return The value, or 0 if the tag was not a character ('A') type"]
    #[doc = "If the tag is not a character type, errno is set to EINVAL."]
    #[doc = "*/"]
    pub fn bam_aux2A(s: *const u8) -> ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get a string aux value"]
    #[doc = "** @param s Pointer to the tag data, as returned by bam_aux_get()."]
    #[doc = "@return Pointer to the string, or NULL if the tag was not a string type"]
    #[doc = "If the tag is not a string type ('Z' or 'H'), errno is set to EINVAL."]
    #[doc = "*/"]
    pub fn bam_aux2Z(s: *const u8) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the length of an array-type ('B') tag"]
    #[doc = "** @param s Pointer to the tag data, as returned by bam_aux_get()."]
    #[doc = "@return The length of the array, or 0 if the tag is not an array type."]
    #[doc = "If the tag is not an array type, errno is set to EINVAL."]
    #[doc = "*/"]
    pub fn bam_auxB_len(s: *const u8) -> u32;
}
extern "C" {
    #[doc = " Get an integer value from an array-type tag"]
    #[doc = "** @param s   Pointer to the tag data, as returned by bam_aux_get()."]
    #[doc = "@param idx 0-based Index into the array"]
    #[doc = "@return The idx'th value, or 0 on error."]
    #[doc = "If the array is not an integer type, errno is set to EINVAL.  If idx"]
    #[doc = "is greater than or equal to  the value returned by bam_auxB_len(s),"]
    #[doc = "errno is set to ERANGE.  In both cases, 0 will be returned."]
    #[doc = "*/"]
    pub fn bam_auxB2i(s: *const u8, idx: u32) -> i64;
}
extern "C" {
    #[doc = " Get a floating-point value from an array-type tag"]
    #[doc = "** @param s   Pointer to the tag data, as returned by bam_aux_get()."]
    #[doc = "@param idx 0-based Index into the array"]
    #[doc = "@return The idx'th value, or 0.0 on error."]
    #[doc = "If the array is not a numeric type, errno is set to EINVAL.  This can"]
    #[doc = "only actually happen if the input record has an invalid type field.  If"]
    #[doc = "idx is greater than or equal to  the value returned by bam_auxB_len(s),"]
    #[doc = "errno is set to ERANGE.  In both cases, 0.0 will be returned."]
    #[doc = "*/"]
    pub fn bam_auxB2f(s: *const u8, idx: u32) -> f64;
}
extern "C" {
    pub fn bam_aux_append(
        b: *mut bam1_t,
        tag: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        data: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bam_aux_del(b: *mut bam1_t, s: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bam_aux_update_str(
        b: *mut bam1_t,
        tag: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        data: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bam_aux_update_int(
        b: *mut bam1_t,
        tag: *const ::std::os::raw::c_char,
        val: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bam_aux_update_float(
        b: *mut bam1_t,
        tag: *const ::std::os::raw::c_char,
        val: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bam_aux_update_array(
        b: *mut bam1_t,
        tag: *const ::std::os::raw::c_char,
        type_: u8,
        items: u32,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @typedef"]
#[doc = "@abstract Generic pileup 'client data'."]
#[doc = ""]
#[doc = "@discussion The pileup iterator allows setting a constructor and"]
#[doc = "destructor function, which will be called every time a sequence is"]
#[doc = "fetched and discarded.  This permits caching of per-sequence data in"]
#[doc = "a tidy manner during the pileup process.  This union is the cached"]
#[doc = "data to be manipulated by the \"client\" (the caller of pileup)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union bam_pileup_cd {
    pub p: *mut ::std::os::raw::c_void,
    pub i: i64,
    pub f: f64,
}
#[test]
fn bindgen_test_layout_bam_pileup_cd() {
    assert_eq!(
        ::std::mem::size_of::<bam_pileup_cd>(),
        8usize,
        concat!("Size of: ", stringify!(bam_pileup_cd))
    );
    assert_eq!(
        ::std::mem::align_of::<bam_pileup_cd>(),
        8usize,
        concat!("Alignment of ", stringify!(bam_pileup_cd))
    );
    fn test_field_p() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bam_pileup_cd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bam_pileup_cd),
                "::",
                stringify!(p)
            )
        );
    }
    test_field_p();
    fn test_field_i() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bam_pileup_cd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bam_pileup_cd),
                "::",
                stringify!(i)
            )
        );
    }
    test_field_i();
    fn test_field_f() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bam_pileup_cd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bam_pileup_cd),
                "::",
                stringify!(f)
            )
        );
    }
    test_field_f();
}
#[doc = " @typedef"]
#[doc = "@abstract Structure for one alignment covering the pileup position."]
#[doc = "@field  b          pointer to the alignment"]
#[doc = "@field  qpos       position of the read base at the pileup site, 0-based"]
#[doc = "@field  indel      indel length; 0 for no indel, positive for ins and negative for del"]
#[doc = "@field  level      the level of the read in the \"viewer\" mode"]
#[doc = "@field  is_del     1 iff the base on the padded read is a deletion"]
#[doc = "@field  is_head    1 iff this is the first base in the query sequence"]
#[doc = "@field  is_tail    1 iff this is the last base in the query sequence"]
#[doc = "@field  is_refskip 1 iff the base on the padded read is part of CIGAR N op"]
#[doc = "@field  aux        (used by bcf_call_gap_prep())"]
#[doc = "@field  cigar_ind  index of the CIGAR operator that has just been processed"]
#[doc = ""]
#[doc = "@discussion See also bam_plbuf_push() and bam_lplbuf_push(). The"]
#[doc = "difference between the two functions is that the former does not"]
#[doc = "set bam_pileup1_t::level, while the later does. Level helps the"]
#[doc = "implementation of alignment viewers, but calculating this has some"]
#[doc = "overhead."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bam_pileup1_t {
    pub b: *mut bam1_t,
    pub qpos: i32,
    pub indel: ::std::os::raw::c_int,
    pub level: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub cd: bam_pileup_cd,
    pub cigar_ind: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_bam_pileup1_t() {
    assert_eq!(
        ::std::mem::size_of::<bam_pileup1_t>(),
        40usize,
        concat!("Size of: ", stringify!(bam_pileup1_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bam_pileup1_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bam_pileup1_t))
    );
    fn test_field_b() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bam_pileup1_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bam_pileup1_t),
                "::",
                stringify!(b)
            )
        );
    }
    test_field_b();
    fn test_field_qpos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bam_pileup1_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).qpos) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bam_pileup1_t),
                "::",
                stringify!(qpos)
            )
        );
    }
    test_field_qpos();
    fn test_field_indel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bam_pileup1_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).indel) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(bam_pileup1_t),
                "::",
                stringify!(indel)
            )
        );
    }
    test_field_indel();
    fn test_field_level() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bam_pileup1_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bam_pileup1_t),
                "::",
                stringify!(level)
            )
        );
    }
    test_field_level();
    fn test_field_cd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bam_pileup1_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cd) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bam_pileup1_t),
                "::",
                stringify!(cd)
            )
        );
    }
    test_field_cd();
    fn test_field_cigar_ind() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bam_pileup1_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cigar_ind) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(bam_pileup1_t),
                "::",
                stringify!(cigar_ind)
            )
        );
    }
    test_field_cigar_ind();
}
impl bam_pileup1_t {
    #[inline]
    pub fn is_del(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_del(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_head(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_head(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_tail(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_tail(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_refskip(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_refskip(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aux(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_aux(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_del: u32,
        is_head: u32,
        is_tail: u32,
        is_refskip: u32,
        aux: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_del: u32 = unsafe { ::std::mem::transmute(is_del) };
            is_del as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_head: u32 = unsafe { ::std::mem::transmute(is_head) };
            is_head as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let is_tail: u32 = unsafe { ::std::mem::transmute(is_tail) };
            is_tail as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_refskip: u32 = unsafe { ::std::mem::transmute(is_refskip) };
            is_refskip as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let aux: u32 = unsafe { ::std::mem::transmute(aux) };
            aux as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type bam_plp_auto_f = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        b: *mut bam1_t,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bam_plp_s {
    _unused: [u8; 0],
}
pub type bam_plp_t = *mut bam_plp_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bam_mplp_s {
    _unused: [u8; 0],
}
pub type bam_mplp_t = *mut bam_mplp_s;
extern "C" {
    #[doc = "  bam_plp_init() - sets an iterator over multiple"]
    #[doc = "  @func:      see mplp_func in bam_plcmd.c in samtools for an example. Expected return"]
    #[doc = "              status: 0 on success, -1 on end, < -1 on non-recoverable errors"]
    #[doc = "  @data:      user data to pass to @func"]
    #[doc = ""]
    #[doc = "  The struct returned by a successful call should be freed"]
    #[doc = "  via bam_plp_destroy() when it is no longer needed."]
    pub fn bam_plp_init(func: bam_plp_auto_f, data: *mut ::std::os::raw::c_void) -> bam_plp_t;
}
extern "C" {
    pub fn bam_plp_destroy(iter: bam_plp_t);
}
extern "C" {
    pub fn bam_plp_push(iter: bam_plp_t, b: *const bam1_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bam_plp_next(
        iter: bam_plp_t,
        _tid: *mut ::std::os::raw::c_int,
        _pos: *mut ::std::os::raw::c_int,
        _n_plp: *mut ::std::os::raw::c_int,
    ) -> *const bam_pileup1_t;
}
extern "C" {
    pub fn bam_plp_auto(
        iter: bam_plp_t,
        _tid: *mut ::std::os::raw::c_int,
        _pos: *mut ::std::os::raw::c_int,
        _n_plp: *mut ::std::os::raw::c_int,
    ) -> *const bam_pileup1_t;
}
extern "C" {
    pub fn bam_plp64_next(
        iter: bam_plp_t,
        _tid: *mut ::std::os::raw::c_int,
        _pos: *mut hts_pos_t,
        _n_plp: *mut ::std::os::raw::c_int,
    ) -> *const bam_pileup1_t;
}
extern "C" {
    pub fn bam_plp64_auto(
        iter: bam_plp_t,
        _tid: *mut ::std::os::raw::c_int,
        _pos: *mut hts_pos_t,
        _n_plp: *mut ::std::os::raw::c_int,
    ) -> *const bam_pileup1_t;
}
extern "C" {
    pub fn bam_plp_set_maxcnt(iter: bam_plp_t, maxcnt: ::std::os::raw::c_int);
}
extern "C" {
    pub fn bam_plp_reset(iter: bam_plp_t);
}
extern "C" {
    #[doc = "  bam_plp_constructor() - sets a callback to initialise any per-pileup1_t fields."]
    #[doc = "  @plp:       The bam_plp_t initialised using bam_plp_init."]
    #[doc = "  @func:      The callback function itself.  When called, it is given"]
    #[doc = "              the data argument (specified in bam_plp_init), the bam"]
    #[doc = "              structure and a pointer to a locally allocated"]
    #[doc = "              bam_pileup_cd union.  This union will also be present in"]
    #[doc = "              each bam_pileup1_t created."]
    #[doc = "              The callback function should have a negative return"]
    #[doc = "              value to indicate an error. (Similarly for destructor.)"]
    pub fn bam_plp_constructor(
        plp: bam_plp_t,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                b: *const bam1_t,
                cd: *mut bam_pileup_cd,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn bam_plp_destructor(
        plp: bam_plp_t,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                b: *const bam1_t,
                cd: *mut bam_pileup_cd,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[doc = " Get pileup padded insertion sequence"]
    #[doc = "**"]
    #[doc = "* @param p       pileup data"]
    #[doc = "* @param ins     the kstring where the insertion sequence will be written"]
    #[doc = "* @param del_len location for deletion length"]
    #[doc = "* @return the length of insertion string on success; -1 on failure."]
    #[doc = "*"]
    #[doc = "* Fills out the kstring with the padded insertion sequence for the current"]
    #[doc = "* location in 'p'.  If this is not an insertion site, the string is blank."]
    #[doc = "*"]
    #[doc = "* If del_len is not NULL, the location pointed to is set to the length of"]
    #[doc = "* any deletion immediately following the insertion, or zero if none."]
    #[doc = "*/"]
    pub fn bam_plp_insertion(
        p: *const bam_pileup1_t,
        ins: *mut kstring_t,
        del_len: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hts_base_mod_state {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get pileup padded insertion sequence, including base modifications"]
    #[doc = "**"]
    #[doc = "* @param p       pileup data"]
    #[doc = "* @param m       state data for the base modification finder"]
    #[doc = "* @param ins     the kstring where the insertion sequence will be written"]
    #[doc = "* @param del_len location for deletion length"]
    #[doc = "* @return the number of insertion string on success, with string length"]
    #[doc = "*         being accessable via ins->l; -1 on failure."]
    #[doc = "*"]
    #[doc = "* Fills out the kstring with the padded insertion sequence for the current"]
    #[doc = "* location in 'p'.  If this is not an insertion site, the string is blank."]
    #[doc = "*"]
    #[doc = "* The modification state needs to have been previously initialised using"]
    #[doc = "* bam_parse_basemod.  It is permitted to be passed in as NULL, in which"]
    #[doc = "* case this function outputs identically to bam_plp_insertion."]
    #[doc = "*"]
    #[doc = "* If del_len is not NULL, the location pointed to is set to the length of"]
    #[doc = "* any deletion immediately following the insertion, or zero if none."]
    #[doc = "*/"]
    pub fn bam_plp_insertion_mod(
        p: *const bam_pileup1_t,
        m: *mut hts_base_mod_state,
        ins: *mut kstring_t,
        del_len: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new bam_mplp_t structure"]
    #[doc = "** The struct returned by a successful call should be freed"]
    #[doc = "*  via bam_mplp_destroy() when it is no longer needed."]
    #[doc = "*/"]
    pub fn bam_mplp_init(
        n: ::std::os::raw::c_int,
        func: bam_plp_auto_f,
        data: *mut *mut ::std::os::raw::c_void,
    ) -> bam_mplp_t;
}
extern "C" {
    #[doc = " Set up mpileup overlap detection"]
    #[doc = "**"]
    #[doc = "* @param iter    mpileup iterator"]
    #[doc = "* @return 0 on success; a negative value on error"]
    #[doc = "*"]
    #[doc = "*  If called, mpileup will detect overlapping"]
    #[doc = "*  read pairs and for each base pair set the base quality of the"]
    #[doc = "*  lower-quality base to zero, thus effectively discarding it from"]
    #[doc = "*  calling. If the two bases are identical, the quality of the other base"]
    #[doc = "*  is increased to the sum of their qualities (capped at 200), otherwise"]
    #[doc = "*  it is multiplied by 0.8."]
    #[doc = "*/"]
    pub fn bam_mplp_init_overlaps(iter: bam_mplp_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bam_mplp_destroy(iter: bam_mplp_t);
}
extern "C" {
    pub fn bam_mplp_set_maxcnt(iter: bam_mplp_t, maxcnt: ::std::os::raw::c_int);
}
extern "C" {
    pub fn bam_mplp_auto(
        iter: bam_mplp_t,
        _tid: *mut ::std::os::raw::c_int,
        _pos: *mut ::std::os::raw::c_int,
        n_plp: *mut ::std::os::raw::c_int,
        plp: *mut *const bam_pileup1_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bam_mplp64_auto(
        iter: bam_mplp_t,
        _tid: *mut ::std::os::raw::c_int,
        _pos: *mut hts_pos_t,
        n_plp: *mut ::std::os::raw::c_int,
        plp: *mut *const bam_pileup1_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bam_mplp_reset(iter: bam_mplp_t);
}
extern "C" {
    pub fn bam_mplp_constructor(
        iter: bam_mplp_t,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                b: *const bam1_t,
                cd: *mut bam_pileup_cd,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn bam_mplp_destructor(
        iter: bam_mplp_t,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                b: *const bam1_t,
                cd: *mut bam_pileup_cd,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[doc = " BAQ calculation and realignment *"]
    pub fn sam_cap_mapq(
        b: *mut bam1_t,
        ref_: *const ::std::os::raw::c_char,
        ref_len: hts_pos_t,
        thres: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const htsRealnFlags_BAQ_APPLY: htsRealnFlags = 1;
pub const htsRealnFlags_BAQ_EXTEND: htsRealnFlags = 2;
pub const htsRealnFlags_BAQ_REDO: htsRealnFlags = 4;
pub const htsRealnFlags_BAQ_AUTO: htsRealnFlags = 0;
pub const htsRealnFlags_BAQ_ILLUMINA: htsRealnFlags = 8;
pub const htsRealnFlags_BAQ_PACBIOCCS: htsRealnFlags = 16;
pub const htsRealnFlags_BAQ_PACBIO: htsRealnFlags = 24;
pub const htsRealnFlags_BAQ_ONT: htsRealnFlags = 32;
pub const htsRealnFlags_BAQ_GENAPSYS: htsRealnFlags = 40;
pub type htsRealnFlags = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Calculate BAQ scores"]
    #[doc = "** @param b   BAM record"]
    #[doc = "@param ref     Reference sequence"]
    #[doc = "@param ref_len Reference sequence length"]
    #[doc = "@param flag    Flags, see description"]
    #[doc = "@return 0 on success \\n"]
    #[doc = "-1 if the read was unmapped, zero length, had no quality values, did not have at least one M, X or = CIGAR operator, or included a reference skip. \\n"]
    #[doc = "-3 if BAQ alignment has already been done and does not need to be applied, or has already been applied. \\n"]
    #[doc = "-4 if alignment failed (most likely due to running out of memory)"]
    #[doc = ""]
    #[doc = "This function calculates base alignment quality (BAQ) values using the method"]
    #[doc = "described in \"Improving SNP discovery by base alignment quality\", Heng Li,"]
    #[doc = "Bioinformatics, Volume 27, Issue 8 (https://doi.org/10.1093/bioinformatics/btr076)."]
    #[doc = ""]
    #[doc = "The @param flag value can be generated using the htsRealnFlags enum, but for"]
    #[doc = "backwards compatibilty reasons is retained as an \"int\".  An example usage"]
    #[doc = "of the enum could be this, equivalent to flag 19:"]
    #[doc = ""]
    #[doc = "sam_prob_realn(b, ref, len, BAQ_APPLY | BAQ_EXTEND | BAQ_PACBIOCCS);"]
    #[doc = ""]
    #[doc = "The following @param flag bits can be used:"]
    #[doc = ""]
    #[doc = "Bit 0 (BAQ_APPLY): Adjust the quality values using the BAQ values"]
    #[doc = ""]
    #[doc = "If set, the data in the BQ:Z tag is used to adjust the quality values, and"]
    #[doc = "the BQ:Z tag is renamed to ZQ:Z."]
    #[doc = ""]
    #[doc = "If clear, and a ZQ:Z tag is present, the quality values are reverted using"]
    #[doc = "the data in the tag, and the tag is renamed to BQ:Z."]
    #[doc = ""]
    #[doc = "Bit 1 (BAQ_EXTEND): Use \"extended\" BAQ."]
    #[doc = ""]
    #[doc = "Changes the BAQ calculation to increase sensitivity at the expense of"]
    #[doc = "reduced specificity."]
    #[doc = ""]
    #[doc = "Bit 2 (BAQ_REDO): Recalculate BAQ, even if a BQ tag is present."]
    #[doc = ""]
    #[doc = "Force BAQ to be recalculated.  Note that a ZQ:Z tag will always disable"]
    #[doc = "recalculation."]
    #[doc = ""]
    #[doc = "Bits 3-10: Choose parameters tailored to a specific instrument type."]
    #[doc = ""]
    #[doc = "One of BAQ_AUTO, BAQ_ILLUMINA, BAQ_PACBIOCCS, BAQ_PACBIO, BAQ_ONT and"]
    #[doc = "BAQ_GENAPSYS.  The BAQ parameter tuning are still a work in progress and"]
    #[doc = "at the time of writing mainly consist of Illumina vs long-read technology"]
    #[doc = "adjustments."]
    #[doc = ""]
    #[doc = "@bug"]
    #[doc = "If the input read has both BQ:Z and ZQ:Z tags, the ZQ:Z one will be removed."]
    #[doc = "Depending on what previous processing happened, this may or may not be the"]
    #[doc = "correct thing to do.  It would be wise to avoid this situation if possible."]
    #[doc = "*/"]
    pub fn sam_prob_realn(
        b: *mut bam1_t,
        ref_: *const ::std::os::raw::c_char,
        ref_len: hts_pos_t,
        flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @typedef"]
#[doc = "@abstract Holds a single base modification."]
#[doc = "@field modified_base     The short base code (m, h, etc) or -ChEBI (negative)"]
#[doc = "@field canonical_base    The canonical base referred to in the MM tag."]
#[doc = "One of A, C, G, T or N.  Note this may not be the"]
#[doc = "explicit base recorded in the SEQ column (esp. if N)."]
#[doc = "@field stran             0 or 1, indicating + or - strand from MM tag."]
#[doc = "@field qual              Quality code (256*probability), or -1 if unknown"]
#[doc = ""]
#[doc = "@discussion"]
#[doc = "Note this doesn't hold any location data or information on which other"]
#[doc = "modifications may be possible at this site."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hts_base_mod {
    pub modified_base: ::std::os::raw::c_int,
    pub canonical_base: ::std::os::raw::c_int,
    pub strand: ::std::os::raw::c_int,
    pub qual: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_hts_base_mod() {
    assert_eq!(
        ::std::mem::size_of::<hts_base_mod>(),
        16usize,
        concat!("Size of: ", stringify!(hts_base_mod))
    );
    assert_eq!(
        ::std::mem::align_of::<hts_base_mod>(),
        4usize,
        concat!("Alignment of ", stringify!(hts_base_mod))
    );
    fn test_field_modified_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_base_mod>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).modified_base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_base_mod),
                "::",
                stringify!(modified_base)
            )
        );
    }
    test_field_modified_base();
    fn test_field_canonical_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_base_mod>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).canonical_base) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_base_mod),
                "::",
                stringify!(canonical_base)
            )
        );
    }
    test_field_canonical_base();
    fn test_field_strand() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_base_mod>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).strand) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_base_mod),
                "::",
                stringify!(strand)
            )
        );
    }
    test_field_strand();
    fn test_field_qual() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hts_base_mod>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).qual) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(hts_base_mod),
                "::",
                stringify!(qual)
            )
        );
    }
    test_field_qual();
}
extern "C" {
    #[doc = " Allocates an hts_base_mode_state."]
    #[doc = "**"]
    #[doc = "* @return An hts_base_mode_state pointer on success,"]
    #[doc = "*         NULL on failure."]
    #[doc = "*"]
    #[doc = "* This just allocates the memory.  The initialisation of the contents is"]
    #[doc = "* done using bam_parse_basemod.  Successive calls may be made to that"]
    #[doc = "* without the need to free and allocate a new state."]
    #[doc = "*"]
    #[doc = "* The state be destroyed using the hts_base_mode_state_free function."]
    #[doc = "*/"]
    pub fn hts_base_mod_state_alloc() -> *mut hts_base_mod_state;
}
extern "C" {
    #[doc = " Destroys an  hts_base_mode_state."]
    #[doc = "**"]
    #[doc = "* @param state    The base modification state pointer."]
    #[doc = "*"]
    #[doc = "* The should have previously been created by hts_base_mode_state_alloc."]
    #[doc = "*/"]
    pub fn hts_base_mod_state_free(state: *mut hts_base_mod_state);
}
extern "C" {
    #[doc = " Parses the Mm and Ml tags out of a bam record."]
    #[doc = "**"]
    #[doc = "* @param b        BAM alignment record"]
    #[doc = "* @param state    The base modification state pointer."]
    #[doc = "* @return 0 on success,"]
    #[doc = "*         -1 on failure."]
    #[doc = "*"]
    #[doc = "* This fills out the contents of the modification state, resetting the"]
    #[doc = "* iterator location to the first sequence base."]
    #[doc = "*/"]
    pub fn bam_parse_basemod(
        b: *const bam1_t,
        state: *mut hts_base_mod_state,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns modification status for the next base position in the query seq."]
    #[doc = "**"]
    #[doc = "* @param b        BAM alignment record"]
    #[doc = "* @param state    The base modification state pointer."]
    #[doc = "* @param mods     A supplied array for returning base modifications"]
    #[doc = "* @param n_mods   The size of the mods array"]
    #[doc = "* @return The number of modifications found on success,"]
    #[doc = "*         -1 on failure."]
    #[doc = "*"]
    #[doc = "* This is intended to be used as an iterator, with one call per location"]
    #[doc = "* along the query sequence."]
    #[doc = "*"]
    #[doc = "* If no modifications are found, the returned value is zero."]
    #[doc = "* If more than n_mods modifications are found, the total found is returned."]
    #[doc = "* Note this means the caller needs to check whether this is higher than"]
    #[doc = "* n_mods."]
    #[doc = "*/"]
    pub fn bam_mods_at_next_pos(
        b: *const bam1_t,
        state: *mut hts_base_mod_state,
        mods: *mut hts_base_mod,
        n_mods: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Finds the next location containing base modifications and returns them"]
    #[doc = "**"]
    #[doc = "* @param b        BAM alignment record"]
    #[doc = "* @param state    The base modification state pointer."]
    #[doc = "* @param mods     A supplied array for returning base modifications"]
    #[doc = "* @param n_mods   The size of the mods array"]
    #[doc = "* @return The number of modifications found on success,"]
    #[doc = "*         0 if no more modifications are present,"]
    #[doc = "*         -1 on failure."]
    #[doc = "*"]
    #[doc = "* Unlike bam_mods_at_next_pos this skips ahead to the next site"]
    #[doc = "* with modifications."]
    #[doc = "*"]
    #[doc = "* If more than n_mods modifications are found, the total found is returned."]
    #[doc = "* Note this means the caller needs to check whether this is higher than"]
    #[doc = "* n_mods."]
    #[doc = "*/"]
    pub fn bam_next_basemod(
        b: *const bam1_t,
        state: *mut hts_base_mod_state,
        mods: *mut hts_base_mod,
        n_mods: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns modification status for a specific query position."]
    #[doc = "**"]
    #[doc = "* @param b        BAM alignment record"]
    #[doc = "* @param state    The base modification state pointer."]
    #[doc = "* @param mods     A supplied array for returning base modifications"]
    #[doc = "* @param n_mods   The size of the mods array"]
    #[doc = "* @return The number of modifications found on success,"]
    #[doc = "*         -1 on failure."]
    #[doc = "*"]
    #[doc = "* Note if called multipled times, qpos must be higher than the previous call."]
    #[doc = "* Hence this is suitable for use from a pileup iterator.  If more random"]
    #[doc = "* access is required, bam_parse_basemod must be called each time to reset"]
    #[doc = "* the state although this has an efficiency cost."]
    #[doc = "*"]
    #[doc = "* If no modifications are found, the returned value is zero."]
    #[doc = "* If more than n_mods modifications are found, the total found is returned."]
    #[doc = "* Note this means the caller needs to check whether this is higher than"]
    #[doc = "* n_mods."]
    #[doc = "*/"]
    pub fn bam_mods_at_qpos(
        b: *const bam1_t,
        qpos: ::std::os::raw::c_int,
        state: *mut hts_base_mod_state,
        mods: *mut hts_base_mod,
        n_mods: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns data about a specific modification type for the alignment record."]
    #[doc = "**"]
    #[doc = "* @param b          BAM alignment record"]
    #[doc = "* @param state      The base modification state pointer."]
    #[doc = "* @param code       Modification code.  If positive this is a character code,"]
    #[doc = "*                   if negative it is a -ChEBI code."]
    #[doc = "*"]
    #[doc = "* @param strand     Boolean for top (0) or bottom (1) strand"]
    #[doc = "* @param implicit   Boolean for whether unlisted positions should be"]
    #[doc = "*                   implicitly assumed to be unmodified, or require an"]
    #[doc = "*                   explicit score and should be considered as unknown."]
    #[doc = "*                   Returned."]
    #[doc = "* @param canonical  Canonical base type associated with this modification"]
    #[doc = "*                   Returned."]
    #[doc = "*"]
    #[doc = "* @return 0 on success or -1 if not found.  The strand, implicit and canonical"]
    #[doc = "* fields are filled out if passed in as non-NULL pointers."]
    #[doc = "*/"]
    pub fn bam_mods_query_type(
        state: *mut hts_base_mod_state,
        code: ::std::os::raw::c_int,
        strand: *mut ::std::os::raw::c_int,
        implicit: *mut ::std::os::raw::c_int,
        canonical: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bam_mods_recorded(
        state: *mut hts_base_mod_state,
        ntype: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
pub const cram_content_type_CT_ERROR: cram_content_type = -1;
pub const cram_content_type_FILE_HEADER: cram_content_type = 0;
pub const cram_content_type_COMPRESSION_HEADER: cram_content_type = 1;
pub const cram_content_type_MAPPED_SLICE: cram_content_type = 2;
pub const cram_content_type_UNMAPPED_SLICE: cram_content_type = 3;
pub const cram_content_type_EXTERNAL: cram_content_type = 4;
pub const cram_content_type_CORE: cram_content_type = 5;
pub type cram_content_type = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cram_file_def {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cram_container {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cram_block {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cram_slice {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cram_metrics {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cram_block_slice_hdr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cram_block_compression_hdr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct refs_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn cram_fd_get_header(fd: *mut cram_fd) -> *mut sam_hdr_t;
}
extern "C" {
    pub fn cram_fd_set_header(fd: *mut cram_fd, hdr: *mut sam_hdr_t);
}
extern "C" {
    pub fn cram_fd_get_version(fd: *mut cram_fd) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cram_fd_set_version(fd: *mut cram_fd, vers: ::std::os::raw::c_int);
}
extern "C" {
    pub fn cram_major_vers(fd: *mut cram_fd) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cram_minor_vers(fd: *mut cram_fd) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cram_fd_get_fp(fd: *mut cram_fd) -> *mut hFILE;
}
extern "C" {
    pub fn cram_fd_set_fp(fd: *mut cram_fd, fp: *mut hFILE);
}
extern "C" {
    pub fn cram_container_get_length(c: *mut cram_container) -> i32;
}
extern "C" {
    pub fn cram_container_set_length(c: *mut cram_container, length: i32);
}
extern "C" {
    pub fn cram_container_get_num_blocks(c: *mut cram_container) -> i32;
}
extern "C" {
    pub fn cram_container_set_num_blocks(c: *mut cram_container, num_blocks: i32);
}
extern "C" {
    pub fn cram_container_get_landmarks(
        c: *mut cram_container,
        num_landmarks: *mut i32,
    ) -> *mut i32;
}
extern "C" {
    pub fn cram_container_set_landmarks(
        c: *mut cram_container,
        num_landmarks: i32,
        landmarks: *mut i32,
    );
}
extern "C" {
    pub fn cram_container_is_empty(fd: *mut cram_fd) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cram_block_get_content_id(b: *mut cram_block) -> i32;
}
extern "C" {
    pub fn cram_block_get_comp_size(b: *mut cram_block) -> i32;
}
extern "C" {
    pub fn cram_block_get_uncomp_size(b: *mut cram_block) -> i32;
}
extern "C" {
    pub fn cram_block_get_crc32(b: *mut cram_block) -> i32;
}
extern "C" {
    pub fn cram_block_get_data(b: *mut cram_block) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cram_block_get_content_type(b: *mut cram_block) -> cram_content_type;
}
extern "C" {
    pub fn cram_block_set_content_id(b: *mut cram_block, id: i32);
}
extern "C" {
    pub fn cram_block_set_comp_size(b: *mut cram_block, size: i32);
}
extern "C" {
    pub fn cram_block_set_uncomp_size(b: *mut cram_block, size: i32);
}
extern "C" {
    pub fn cram_block_set_crc32(b: *mut cram_block, crc: i32);
}
extern "C" {
    pub fn cram_block_set_data(b: *mut cram_block, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn cram_block_append(
        b: *mut cram_block,
        data: *const ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cram_block_update_size(b: *mut cram_block);
}
extern "C" {
    pub fn cram_block_get_offset(b: *mut cram_block) -> size_t;
}
extern "C" {
    pub fn cram_block_set_offset(b: *mut cram_block, offset: size_t);
}
extern "C" {
    pub fn cram_block_size(b: *mut cram_block) -> u32;
}
extern "C" {
    pub fn cram_transcode_rg(
        in_: *mut cram_fd,
        out: *mut cram_fd,
        c: *mut cram_container,
        nrg: ::std::os::raw::c_int,
        in_rg: *mut ::std::os::raw::c_int,
        out_rg: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cram_copy_slice(
        in_: *mut cram_fd,
        out: *mut cram_fd,
        num_slice: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cram_slice_hdr_get_num_blocks(hdr: *mut cram_block_slice_hdr) -> i32;
}
extern "C" {
    pub fn cram_slice_hdr_get_embed_ref_id(h: *mut cram_block_slice_hdr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cram_slice_hdr_get_coords(
        h: *mut cram_block_slice_hdr,
        refid: *mut ::std::os::raw::c_int,
        start: *mut hts_pos_t,
        span: *mut hts_pos_t,
    );
}
extern "C" {
    pub fn cram_decode_slice_header(
        fd: *mut cram_fd,
        b: *mut cram_block,
    ) -> *mut cram_block_slice_hdr;
}
extern "C" {
    pub fn cram_free_slice_header(hdr: *mut cram_block_slice_hdr);
}
extern "C" {
    #[doc = " Allocates a new cram_block structure with a specified content_type and"]
    #[doc = " id."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Returns block pointer on success;"]
    #[doc = "         NULL on failure"]
    #[doc = ""]
    #[doc = " The cram_block struct returned by a successful call should be freed"]
    #[doc = " via cram_free_block() when it is no longer needed."]
    pub fn cram_new_block(
        content_type: cram_content_type,
        content_id: ::std::os::raw::c_int,
    ) -> *mut cram_block;
}
extern "C" {
    #[doc = " Reads a block from a cram file."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Returns cram_block pointer on success;"]
    #[doc = "         NULL on failure"]
    #[doc = ""]
    #[doc = " The cram_block struct returned by a successful call should be freed"]
    #[doc = " via cram_free_block() when it is no longer needed."]
    pub fn cram_read_block(fd: *mut cram_fd) -> *mut cram_block;
}
extern "C" {
    #[doc = " Writes a CRAM block."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Returns 0 on success;"]
    #[doc = "        -1 on failure"]
    pub fn cram_write_block(fd: *mut cram_fd, b: *mut cram_block) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Frees a CRAM block, deallocating internal data too."]
    pub fn cram_free_block(b: *mut cram_block);
}
extern "C" {
    #[doc = " Uncompresses a CRAM block, if compressed."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Returns 0 on success;"]
    #[doc = "        -1 on failure"]
    pub fn cram_uncompress_block(b: *mut cram_block) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compresses a block."]
    #[doc = ""]
    #[doc = " Compresses a block using one of two different zlib strategies. If we only"]
    #[doc = " want one choice set strat2 to be -1."]
    #[doc = ""]
    #[doc = " The logic here is that sometimes Z_RLE does a better job than Z_FILTERED"]
    #[doc = " or Z_DEFAULT_STRATEGY on quality data. If so, we'd rather use it as it is"]
    #[doc = " significantly faster."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Returns 0 on success;"]
    #[doc = "        -1 on failure"]
    pub fn cram_compress_block(
        fd: *mut cram_fd,
        b: *mut cram_block,
        metrics: *mut cram_metrics,
        method: ::std::os::raw::c_int,
        level: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cram_compress_block2(
        fd: *mut cram_fd,
        s: *mut cram_slice,
        b: *mut cram_block,
        metrics: *mut cram_metrics,
        method: ::std::os::raw::c_int,
        level: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a new container, specifying the maximum number of slices"]
    #[doc = " and records permitted."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Returns cram_container ptr on success;"]
    #[doc = "         NULL on failure"]
    #[doc = ""]
    #[doc = " The cram_container struct returned by a successful call should be freed"]
    #[doc = " via cram_free_container() when it is no longer needed."]
    pub fn cram_new_container(
        nrec: ::std::os::raw::c_int,
        nslice: ::std::os::raw::c_int,
    ) -> *mut cram_container;
}
extern "C" {
    pub fn cram_free_container(c: *mut cram_container);
}
extern "C" {
    #[doc = " Reads a container header."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Returns cram_container on success;"]
    #[doc = "         NULL on failure or no container left (fd->err == 0)."]
    #[doc = ""]
    #[doc = " The cram_container struct returned by a successful call should be freed"]
    #[doc = " via cram_free_container() when it is no longer needed."]
    pub fn cram_read_container(fd: *mut cram_fd) -> *mut cram_container;
}
extern "C" {
    #[doc = " Writes a container structure."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Returns 0 on success;"]
    #[doc = "        -1 on failure"]
    pub fn cram_write_container(fd: *mut cram_fd, h: *mut cram_container) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cram_store_container(
        fd: *mut cram_fd,
        c: *mut cram_container,
        dat: *mut ::std::os::raw::c_char,
        size: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cram_container_size(c: *mut cram_container) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Opens a CRAM file for read (mode \"rb\") or write (\"wb\")."]
    #[doc = ""]
    #[doc = " The filename may be \"-\" to indicate stdin or stdout."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Returns file handle on success;"]
    #[doc = "         NULL on failure."]
    pub fn cram_open(
        filename: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut cram_fd;
}
extern "C" {
    #[doc = " Opens an existing stream for reading or writing."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Returns file handle on success;"]
    #[doc = "         NULL on failure."]
    pub fn cram_dopen(
        fp: *mut hFILE,
        filename: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut cram_fd;
}
extern "C" {
    #[doc = " Closes a CRAM file."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Returns 0 on success;"]
    #[doc = "        -1 on failure"]
    pub fn cram_close(fd: *mut cram_fd) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cram_seek(
        fd: *mut cram_fd,
        offset: off_t,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cram_flush(fd: *mut cram_fd) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Checks for end of file on a cram_fd stream."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Returns 0 if not at end of file"]
    #[doc = "         1 if we hit an expected EOF (end of range or EOF block)"]
    #[doc = "         2 for other EOF (end of stream without EOF block)"]
    pub fn cram_eof(fd: *mut cram_fd) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets options on the cram_fd."]
    #[doc = ""]
    #[doc = " See CRAM_OPT_* definitions in hts.h."]
    #[doc = " Use this immediately after opening."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Returns 0 on success;"]
    #[doc = "        -1 on failure"]
    pub fn cram_set_option(fd: *mut cram_fd, opt: hts_fmt_option, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets options on the cram_fd."]
    #[doc = ""]
    #[doc = " See CRAM_OPT_* definitions in hts.h."]
    #[doc = " Use this immediately after opening."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Returns 0 on success;"]
    #[doc = "        -1 on failure"]
    pub fn cram_set_voption(
        fd: *mut cram_fd,
        opt: hts_fmt_option,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Attaches a header to a cram_fd."]
    #[doc = ""]
    #[doc = " This should be used when creating a new cram_fd for writing where"]
    #[doc = " we have an SAM_hdr already constructed (eg from a file we've read"]
    #[doc = " in)."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Returns 0 on success;"]
    #[doc = "        -1 on failure"]
    pub fn cram_set_header(fd: *mut cram_fd, hdr: *mut sam_hdr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if this file has a proper EOF block"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Returns 3 if the file is a version of CRAM that does not contain EOF blocks"]
    #[doc = "         2 if the file is a stream and thus unseekable"]
    #[doc = "         1 if the file contains an EOF block"]
    #[doc = "         0 if the file does not contain an EOF block"]
    #[doc = "        -1 if an error occurred whilst reading the file or we could not seek back to where we were"]
    #[doc = ""]
    pub fn cram_check_EOF(fd: *mut cram_fd) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn int32_put_blk(b: *mut cram_block, val: i32) -> ::std::os::raw::c_int;
}
#[doc = " @typedef"]
#[doc = "@abstract Structure for the alignment header."]
#[doc = "@field n_targets   number of reference sequences"]
#[doc = "@field l_text      length of the plain text in the header (may be zero if"]
#[doc = "the header has been edited)"]
#[doc = "@field target_len  lengths of the reference sequences"]
#[doc = "@field target_name names of the reference sequences"]
#[doc = "@field text        plain text (may be NULL if the header has been edited)"]
#[doc = "@field sdict       header dictionary"]
#[doc = "@field hrecs       pointer to the extended header struct (internal use only)"]
#[doc = "@field ref_count   reference count"]
#[doc = ""]
#[doc = "@note The text and l_text fields are included for backwards compatibility."]
#[doc = "These fields may be set to NULL and zero respectively as a side-effect"]
#[doc = "of calling some header API functions.  New code that needs to access the"]
#[doc = "header text should use the sam_hdr_str() and sam_hdr_length() functions"]
#[doc = "instead of these fields."]
pub type SAM_hdr = sam_hdr_t;
extern "C" {
    #[doc = " Returns the refs_t structure used by a cram file handle."]
    #[doc = ""]
    #[doc = " This may be used in conjunction with option CRAM_OPT_SHARED_REF to"]
    #[doc = " share reference memory between multiple file handles."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Returns NULL if none exists or the file handle is not a CRAM file."]
    pub fn cram_get_refs(fd: *mut htsFile) -> *mut refs_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgzf_mtaux_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgzidx_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgzf_cache_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_stream_s {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BGZF {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub cache_size: ::std::os::raw::c_int,
    pub block_length: ::std::os::raw::c_int,
    pub block_clength: ::std::os::raw::c_int,
    pub block_offset: ::std::os::raw::c_int,
    pub block_address: i64,
    pub uncompressed_address: i64,
    pub uncompressed_block: *mut ::std::os::raw::c_void,
    pub compressed_block: *mut ::std::os::raw::c_void,
    pub cache: *mut bgzf_cache_t,
    pub fp: *mut hFILE,
    pub mt: *mut bgzf_mtaux_t,
    pub idx: *mut bgzidx_t,
    pub idx_build_otf: ::std::os::raw::c_int,
    pub gz_stream: *mut z_stream_s,
    pub seeked: i64,
}
#[test]
fn bindgen_test_layout_BGZF() {
    assert_eq!(
        ::std::mem::size_of::<BGZF>(),
        112usize,
        concat!("Size of: ", stringify!(BGZF))
    );
    assert_eq!(
        ::std::mem::align_of::<BGZF>(),
        8usize,
        concat!("Alignment of ", stringify!(BGZF))
    );
    fn test_field_cache_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<BGZF>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cache_size) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(BGZF),
                "::",
                stringify!(cache_size)
            )
        );
    }
    test_field_cache_size();
    fn test_field_block_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<BGZF>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).block_length) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(BGZF),
                "::",
                stringify!(block_length)
            )
        );
    }
    test_field_block_length();
    fn test_field_block_clength() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<BGZF>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).block_clength) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(BGZF),
                "::",
                stringify!(block_clength)
            )
        );
    }
    test_field_block_clength();
    fn test_field_block_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<BGZF>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).block_offset) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(BGZF),
                "::",
                stringify!(block_offset)
            )
        );
    }
    test_field_block_offset();
    fn test_field_block_address() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<BGZF>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).block_address) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(BGZF),
                "::",
                stringify!(block_address)
            )
        );
    }
    test_field_block_address();
    fn test_field_uncompressed_address() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<BGZF>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uncompressed_address) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(BGZF),
                "::",
                stringify!(uncompressed_address)
            )
        );
    }
    test_field_uncompressed_address();
    fn test_field_uncompressed_block() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<BGZF>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uncompressed_block) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(BGZF),
                "::",
                stringify!(uncompressed_block)
            )
        );
    }
    test_field_uncompressed_block();
    fn test_field_compressed_block() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<BGZF>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compressed_block) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(BGZF),
                "::",
                stringify!(compressed_block)
            )
        );
    }
    test_field_compressed_block();
    fn test_field_cache() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<BGZF>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cache) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(BGZF),
                "::",
                stringify!(cache)
            )
        );
    }
    test_field_cache();
    fn test_field_fp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<BGZF>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fp) as usize - ptr as usize
            },
            64usize,
            concat!("Offset of field: ", stringify!(BGZF), "::", stringify!(fp))
        );
    }
    test_field_fp();
    fn test_field_mt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<BGZF>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mt) as usize - ptr as usize
            },
            72usize,
            concat!("Offset of field: ", stringify!(BGZF), "::", stringify!(mt))
        );
    }
    test_field_mt();
    fn test_field_idx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<BGZF>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).idx) as usize - ptr as usize
            },
            80usize,
            concat!("Offset of field: ", stringify!(BGZF), "::", stringify!(idx))
        );
    }
    test_field_idx();
    fn test_field_idx_build_otf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<BGZF>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).idx_build_otf) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(BGZF),
                "::",
                stringify!(idx_build_otf)
            )
        );
    }
    test_field_idx_build_otf();
    fn test_field_gz_stream() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<BGZF>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gz_stream) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(BGZF),
                "::",
                stringify!(gz_stream)
            )
        );
    }
    test_field_gz_stream();
    fn test_field_seeked() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<BGZF>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).seeked) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(BGZF),
                "::",
                stringify!(seeked)
            )
        );
    }
    test_field_seeked();
}
impl BGZF {
    #[inline]
    pub fn errcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_errcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_write(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_write(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_eof_block(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_eof_block(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_be(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_be(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn compress_level(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_compress_level(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn last_block_eof(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_block_eof(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_compressed(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_compressed(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_gzip(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_gzip(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        errcode: ::std::os::raw::c_uint,
        reserved: ::std::os::raw::c_uint,
        is_write: ::std::os::raw::c_uint,
        no_eof_block: ::std::os::raw::c_uint,
        is_be: ::std::os::raw::c_uint,
        compress_level: ::std::os::raw::c_int,
        last_block_eof: ::std::os::raw::c_uint,
        is_compressed: ::std::os::raw::c_uint,
        is_gzip: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let errcode: u32 = unsafe { ::std::mem::transmute(errcode) };
            errcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let is_write: u32 = unsafe { ::std::mem::transmute(is_write) };
            is_write as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let no_eof_block: u32 = unsafe { ::std::mem::transmute(no_eof_block) };
            no_eof_block as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let is_be: u32 = unsafe { ::std::mem::transmute(is_be) };
            is_be as u64
        });
        __bindgen_bitfield_unit.set(20usize, 9u8, {
            let compress_level: u32 = unsafe { ::std::mem::transmute(compress_level) };
            compress_level as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let last_block_eof: u32 = unsafe { ::std::mem::transmute(last_block_eof) };
            last_block_eof as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let is_compressed: u32 = unsafe { ::std::mem::transmute(is_compressed) };
            is_compressed as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let is_gzip: u32 = unsafe { ::std::mem::transmute(is_gzip) };
            is_gzip as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " Open an existing file descriptor for reading or writing."]
    #[doc = ""]
    #[doc = " @param fd    file descriptor"]
    #[doc = "              Note that the file must be opened in binary mode, or else"]
    #[doc = "              there will be problems on platforms that make a difference"]
    #[doc = "              between text and binary mode."]
    #[doc = " @param mode  mode matching /[rwag][u0-9]+/: 'r' for reading, 'w' for"]
    #[doc = "              writing, 'a' for appending, 'g' for gzip rather than BGZF"]
    #[doc = "              compression (with 'w' only), and digit specifies the zlib"]
    #[doc = "              compression level."]
    #[doc = "              Note that there is a distinction between 'u' and '0': the"]
    #[doc = "              first yields plain uncompressed output whereas the latter"]
    #[doc = "              outputs uncompressed data wrapped in the zlib format."]
    #[doc = " @return      BGZF file handler; 0 on error"]
    pub fn bgzf_dopen(fd: ::std::os::raw::c_int, mode: *const ::std::os::raw::c_char) -> *mut BGZF;
}
extern "C" {
    #[doc = " Open the specified file for reading or writing."]
    pub fn bgzf_open(
        path: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut BGZF;
}
extern "C" {
    #[doc = " Open an existing hFILE stream for reading or writing."]
    pub fn bgzf_hopen(fp: *mut hFILE, mode: *const ::std::os::raw::c_char) -> *mut BGZF;
}
extern "C" {
    #[doc = " Close the BGZF and free all associated resources."]
    #[doc = ""]
    #[doc = " @param fp    BGZF file handler"]
    #[doc = " @return      0 on success and -1 on error"]
    pub fn bgzf_close(fp: *mut BGZF) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read up to _length_ bytes from the file storing into _data_."]
    #[doc = ""]
    #[doc = " @param fp     BGZF file handler"]
    #[doc = " @param data   data array to read into"]
    #[doc = " @param length size of data to read"]
    #[doc = " @return       number of bytes actually read; 0 on end-of-file and -1 on error"]
    pub fn bgzf_read(fp: *mut BGZF, data: *mut ::std::os::raw::c_void, length: size_t) -> ssize_t;
}
extern "C" {
    #[doc = " Write _length_ bytes from _data_ to the file.  If no I/O errors occur,"]
    #[doc = " the complete _length_ bytes will be written (or queued for writing)."]
    #[doc = ""]
    #[doc = " @param fp     BGZF file handler"]
    #[doc = " @param data   data array to write"]
    #[doc = " @param length size of data to write"]
    #[doc = " @return       number of bytes written (i.e., _length_); negative on error"]
    pub fn bgzf_write(
        fp: *mut BGZF,
        data: *const ::std::os::raw::c_void,
        length: size_t,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " Write _length_ bytes from _data_ to the file, the index will be used to"]
    #[doc = " decide the amount of uncompressed data to be written to each bgzip block."]
    #[doc = " If no I/O errors occur, the complete _length_ bytes will be written (or"]
    #[doc = " queued for writing)."]
    #[doc = " @param fp     BGZF file handler"]
    #[doc = " @param data   data array to write"]
    #[doc = " @param length size of data to write"]
    #[doc = " @return       number of bytes written (i.e., _length_); negative on error"]
    pub fn bgzf_block_write(
        fp: *mut BGZF,
        data: *const ::std::os::raw::c_void,
        length: size_t,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " Returns the next byte in the file without consuming it."]
    #[doc = " @param fp     BGZF file handler"]
    #[doc = " @return       -1 on EOF,"]
    #[doc = "               -2 on error,"]
    #[doc = "               otherwise the unsigned byte value."]
    pub fn bgzf_peek(fp: *mut BGZF) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read up to _length_ bytes directly from the underlying stream without"]
    #[doc = " decompressing.  Bypasses BGZF blocking, so must be used with care in"]
    #[doc = " specialised circumstances only."]
    #[doc = ""]
    #[doc = " @param fp     BGZF file handler"]
    #[doc = " @param data   data array to read into"]
    #[doc = " @param length number of raw bytes to read"]
    #[doc = " @return       number of bytes actually read; 0 on end-of-file and -1 on error"]
    pub fn bgzf_raw_read(
        fp: *mut BGZF,
        data: *mut ::std::os::raw::c_void,
        length: size_t,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " Write _length_ bytes directly to the underlying stream without"]
    #[doc = " compressing.  Bypasses BGZF blocking, so must be used with care"]
    #[doc = " in specialised circumstances only."]
    #[doc = ""]
    #[doc = " @param fp     BGZF file handler"]
    #[doc = " @param data   data array to write"]
    #[doc = " @param length number of raw bytes to write"]
    #[doc = " @return       number of bytes actually written; -1 on error"]
    pub fn bgzf_raw_write(
        fp: *mut BGZF,
        data: *const ::std::os::raw::c_void,
        length: size_t,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " Write the data in the buffer to the file."]
    #[doc = ""]
    #[doc = " @param fp     BGZF file handle"]
    #[doc = " @return       0 on success and -1 on error"]
    pub fn bgzf_flush(fp: *mut BGZF) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the file to read from the location specified by _pos_."]
    #[doc = ""]
    #[doc = " @param fp     BGZF file handler"]
    #[doc = " @param pos    virtual file offset returned by bgzf_tell()"]
    #[doc = " @param whence must be SEEK_SET"]
    #[doc = " @return       0 on success and -1 on error"]
    #[doc = ""]
    #[doc = " @note It is not permitted to seek on files open for writing,"]
    #[doc = " or files compressed with gzip (as opposed to bgzip)."]
    pub fn bgzf_seek(fp: *mut BGZF, pos: i64, whence: ::std::os::raw::c_int) -> i64;
}
extern "C" {
    #[doc = " Check if the BGZF end-of-file (EOF) marker is present"]
    #[doc = ""]
    #[doc = " @param fp    BGZF file handler opened for reading"]
    #[doc = " @return      1 if the EOF marker is present and correct;"]
    #[doc = "              2 if it can't be checked, e.g., because fp isn't seekable;"]
    #[doc = "              0 if the EOF marker is absent;"]
    #[doc = "              -1 (with errno set) on error"]
    pub fn bgzf_check_EOF(fp: *mut BGZF) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the file's compression format"]
    #[doc = ""]
    #[doc = " @param fp  BGZF file handle"]
    #[doc = " @return    A small integer matching the corresponding"]
    #[doc = "            `enum htsCompression` value:"]
    #[doc = "   - 0 / `no_compression` if the file is uncompressed"]
    #[doc = "   - 1 / `gzip` if the file is plain GZIP-compressed"]
    #[doc = "   - 2 / `bgzf` if the file is BGZF-compressed"]
    #[doc = " @since 1.4"]
    pub fn bgzf_compression(fp: *mut BGZF) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if a file is in the BGZF format"]
    #[doc = ""]
    #[doc = " @param fn    file name"]
    #[doc = " @return      1 if _fn_ is BGZF; 0 if not or on I/O error"]
    pub fn bgzf_is_bgzf(fn_: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the cache size. Only effective when compiled with -DBGZF_CACHE."]
    #[doc = ""]
    #[doc = " @param fp    BGZF file handler"]
    #[doc = " @param size  size of cache in bytes; 0 to disable caching (default)"]
    pub fn bgzf_set_cache_size(fp: *mut BGZF, size: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Flush the file if the remaining buffer size is smaller than _size_"]
    #[doc = " @return      0 if flushing succeeded or was not needed; negative on error"]
    pub fn bgzf_flush_try(fp: *mut BGZF, size: ssize_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read one byte from a BGZF file. It is faster than bgzf_read()"]
    #[doc = " @param fp     BGZF file handler"]
    #[doc = " @return       byte read; -1 on end-of-file or error"]
    pub fn bgzf_getc(fp: *mut BGZF) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read one line from a BGZF file. It is faster than bgzf_getc()"]
    #[doc = ""]
    #[doc = " @param fp     BGZF file handler"]
    #[doc = " @param delim  delimiter"]
    #[doc = " @param str    string to write to; must be initialized"]
    #[doc = " @return       length of the string; -1 on end-of-file; <= -2 on error"]
    pub fn bgzf_getline(
        fp: *mut BGZF,
        delim: ::std::os::raw::c_int,
        str_: *mut kstring_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read the next BGZF block."]
    pub fn bgzf_read_block(fp: *mut BGZF) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable multi-threading (when compiled with -DBGZF_MT) via a shared"]
    #[doc = " thread pool.  This means both encoder and decoder can balance"]
    #[doc = " usage across a single pool of worker jobs."]
    #[doc = ""]
    #[doc = " @param fp          BGZF file handler; must be opened for writing"]
    #[doc = " @param pool        The thread pool (see hts_create_threads)"]
    pub fn bgzf_thread_pool(
        fp: *mut BGZF,
        pool: *mut hts_tpool,
        qsize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable multi-threading (only effective when the library was compiled"]
    #[doc = " with -DBGZF_MT)"]
    #[doc = ""]
    #[doc = " @param fp          BGZF file handler; must be opened for writing"]
    #[doc = " @param n_threads   #threads used for writing"]
    #[doc = " @param n_sub_blks  #blocks processed by each thread; a value 64-256 is recommended"]
    pub fn bgzf_mt(
        fp: *mut BGZF,
        n_threads: ::std::os::raw::c_int,
        n_sub_blks: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compress a single BGZF block."]
    #[doc = ""]
    #[doc = " @param dst    output buffer (must have size >= BGZF_MAX_BLOCK_SIZE)"]
    #[doc = " @param dlen   size of output buffer; updated on return to the number"]
    #[doc = "               of bytes actually written to dst"]
    #[doc = " @param src    buffer to be compressed"]
    #[doc = " @param slen   size of data to compress (must be <= BGZF_BLOCK_SIZE)"]
    #[doc = " @param level  compression level"]
    #[doc = " @return       0 on success and negative on error"]
    pub fn bgzf_compress(
        dst: *mut ::std::os::raw::c_void,
        dlen: *mut size_t,
        src: *const ::std::os::raw::c_void,
        slen: size_t,
        level: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Position BGZF at the uncompressed offset"]
    #[doc = ""]
    #[doc = "  @param fp           BGZF file handler; must be opened for reading"]
    #[doc = "  @param uoffset      file offset in the uncompressed data"]
    #[doc = "  @param where        must be SEEK_SET"]
    #[doc = ""]
    #[doc = "  Returns 0 on success and -1 on error."]
    #[doc = ""]
    #[doc = "  @note It is not permitted to seek on files open for writing,"]
    #[doc = "  or files compressed with gzip (as opposed to bgzip)."]
    pub fn bgzf_useek(
        fp: *mut BGZF,
        uoffset: off_t,
        where_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Position in uncompressed BGZF"]
    #[doc = ""]
    #[doc = "  @param fp           BGZF file handler; must be opened for reading"]
    #[doc = ""]
    #[doc = "  Returns the current offset on success and -1 on error."]
    pub fn bgzf_utell(fp: *mut BGZF) -> off_t;
}
extern "C" {
    #[doc = " Tell BGZF to build index while compressing."]
    #[doc = ""]
    #[doc = " @param fp          BGZF file handler; can be opened for reading or writing."]
    #[doc = ""]
    #[doc = " Returns 0 on success and -1 on error."]
    #[doc = ""]
    #[doc = " @note This function must be called before any data has been read or"]
    #[doc = " written, and in particular before calling bgzf_mt() on the same"]
    #[doc = " file handle (as threads may start reading data before the index"]
    #[doc = " has been set up)."]
    pub fn bgzf_index_build_init(fp: *mut BGZF) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Load BGZF index"]
    #[doc = "**"]
    #[doc = "* @param fp          BGZF file handler"]
    #[doc = "* @param bname       base name"]
    #[doc = "* @param suffix      suffix to add to bname (can be NULL)"]
    #[doc = "* @return 0 on success and -1 on error."]
    #[doc = "*/"]
    pub fn bgzf_index_load(
        fp: *mut BGZF,
        bname: *const ::std::os::raw::c_char,
        suffix: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Load BGZF index from an hFILE"]
    #[doc = "**"]
    #[doc = "* @param fp   BGZF file handle"]
    #[doc = "* @param idx  hFILE to read from"]
    #[doc = "* @param name file name (for error reporting only; can be NULL)"]
    #[doc = "* @return 0 on success and -1 on error."]
    #[doc = "*"]
    #[doc = "* Populates @p fp with index data read from the hFILE handle @p idx."]
    #[doc = "* The file pointer to @idx should point to the start of the index"]
    #[doc = "* data when this function is called."]
    #[doc = "*"]
    #[doc = "* The file name can optionally be passed in the @p name parameter.  This"]
    #[doc = "* is only used for printing error messages; if NULL the word \"index\" is"]
    #[doc = "* used instead."]
    #[doc = "*/"]
    pub fn bgzf_index_load_hfile(
        fp: *mut BGZF,
        idx: *mut hFILE,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Save BGZF index"]
    #[doc = "**"]
    #[doc = "* @param fp          BGZF file handler"]
    #[doc = "* @param bname       base name"]
    #[doc = "* @param suffix      suffix to add to bname (can be NULL)"]
    #[doc = "* @return 0 on success and -1 on error."]
    #[doc = "*/"]
    pub fn bgzf_index_dump(
        fp: *mut BGZF,
        bname: *const ::std::os::raw::c_char,
        suffix: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write a BGZF index to an hFILE"]
    #[doc = "**"]
    #[doc = "* @param fp     BGZF file handle"]
    #[doc = "* @param idx    hFILE to write to"]
    #[doc = "* @param name   file name (for error reporting only, can be NULL)"]
    #[doc = "* @return 0 on success and -1 on error."]
    #[doc = "*"]
    #[doc = "* Write index data from @p fp to the file @p idx."]
    #[doc = "*"]
    #[doc = "* The file name can optionally be passed in the @p name parameter.  This"]
    #[doc = "* is only used for printing error messages; if NULL the word \"index\" is"]
    #[doc = "* used instead."]
    #[doc = "*/"]
    pub fn bgzf_index_dump_hfile(
        fp: *mut BGZF,
        idx: *mut hFILE,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  bcf_trim_alleles() - remove ALT alleles unused in genotype fields"]
    #[doc = "  @header:  for access to BCF_DT_ID dictionary"]
    #[doc = "  @line:    VCF line obtain from vcf_parse1"]
    #[doc = ""]
    #[doc = "  Returns the number of removed alleles on success or negative"]
    #[doc = "  on error:"]
    #[doc = "      -1 .. some allele index is out of bounds"]
    #[doc = "      -2 .. could not remove alleles"]
    pub fn bcf_trim_alleles(header: *const bcf_hdr_t, line: *mut bcf1_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  bcf_remove_alleles() - remove ALT alleles according to bitmask @mask"]
    #[doc = "  @header:  for access to BCF_DT_ID dictionary"]
    #[doc = "  @line:    VCF line obtained from vcf_parse1"]
    #[doc = "  @mask:    alleles to remove"]
    #[doc = ""]
    #[doc = "  If you have more than 31 alleles, then the integer bit mask will"]
    #[doc = "  overflow, so use bcf_remove_allele_set instead"]
    #[doc = "  Returns 0 on success, <0 on error"]
    pub fn bcf_remove_alleles(
        header: *const bcf_hdr_t,
        line: *mut bcf1_t,
        mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  bcf_remove_allele_set() - remove ALT alleles according to bitset @rm_set"]
    #[doc = "  @header:  for access to BCF_DT_ID dictionary"]
    #[doc = "  @line:    VCF line obtained from vcf_parse1"]
    #[doc = "  @rm_set:  pointer to kbitset_t object with bits set for allele"]
    #[doc = "            indexes to remove"]
    #[doc = ""]
    #[doc = "  Returns 0 on success or -1 on failure"]
    #[doc = ""]
    #[doc = "  Number=A,R,G INFO and FORMAT fields will be updated accordingly."]
    pub fn bcf_remove_allele_set(
        header: *const bcf_hdr_t,
        line: *mut bcf1_t,
        rm_set: *const kbitset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  bcf_calc_ac() - calculate the number of REF and ALT alleles"]
    #[doc = "  @header:  for access to BCF_DT_ID dictionary"]
    #[doc = "  @line:    VCF line obtained from vcf_parse1"]
    #[doc = "  @ac:      array of length line->n_allele"]
    #[doc = "  @which:   determine if INFO/AN,AC and indv fields be used"]
    #[doc = ""]
    #[doc = "  Returns 1 if the call succeeded, or 0 if the value could not"]
    #[doc = "  be determined."]
    #[doc = ""]
    #[doc = "  The value of @which determines if existing INFO/AC,AN can be"]
    #[doc = "  used (BCF_UN_INFO) and and if indv fields can be split (BCF_UN_FMT)."]
    pub fn bcf_calc_ac(
        header: *const bcf_hdr_t,
        line: *mut bcf1_t,
        ac: *mut ::std::os::raw::c_int,
        which: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcf_gt_type(
        fmt_ptr: *mut bcf_fmt_t,
        isample: ::std::os::raw::c_int,
        ial: *mut ::std::os::raw::c_int,
        jal: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tbx_conf_t {
    pub preset: i32,
    pub sc: i32,
    pub bc: i32,
    pub ec: i32,
    pub meta_char: i32,
    pub line_skip: i32,
}
#[test]
fn bindgen_test_layout_tbx_conf_t() {
    assert_eq!(
        ::std::mem::size_of::<tbx_conf_t>(),
        24usize,
        concat!("Size of: ", stringify!(tbx_conf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tbx_conf_t>(),
        4usize,
        concat!("Alignment of ", stringify!(tbx_conf_t))
    );
    fn test_field_preset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tbx_conf_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).preset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tbx_conf_t),
                "::",
                stringify!(preset)
            )
        );
    }
    test_field_preset();
    fn test_field_sc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tbx_conf_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sc) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(tbx_conf_t),
                "::",
                stringify!(sc)
            )
        );
    }
    test_field_sc();
    fn test_field_bc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tbx_conf_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bc) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(tbx_conf_t),
                "::",
                stringify!(bc)
            )
        );
    }
    test_field_bc();
    fn test_field_ec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tbx_conf_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ec) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(tbx_conf_t),
                "::",
                stringify!(ec)
            )
        );
    }
    test_field_ec();
    fn test_field_meta_char() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tbx_conf_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).meta_char) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(tbx_conf_t),
                "::",
                stringify!(meta_char)
            )
        );
    }
    test_field_meta_char();
    fn test_field_line_skip() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tbx_conf_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).line_skip) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(tbx_conf_t),
                "::",
                stringify!(line_skip)
            )
        );
    }
    test_field_line_skip();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tbx_t {
    pub conf: tbx_conf_t,
    pub idx: *mut hts_idx_t,
    pub dict: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_tbx_t() {
    assert_eq!(
        ::std::mem::size_of::<tbx_t>(),
        40usize,
        concat!("Size of: ", stringify!(tbx_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tbx_t>(),
        8usize,
        concat!("Alignment of ", stringify!(tbx_t))
    );
    fn test_field_conf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tbx_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).conf) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tbx_t),
                "::",
                stringify!(conf)
            )
        );
    }
    test_field_conf();
    fn test_field_idx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tbx_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).idx) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(tbx_t),
                "::",
                stringify!(idx)
            )
        );
    }
    test_field_idx();
    fn test_field_dict() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tbx_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dict) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(tbx_t),
                "::",
                stringify!(dict)
            )
        );
    }
    test_field_dict();
}
extern "C" {
    pub static tbx_conf_gff: tbx_conf_t;
}
extern "C" {
    pub static tbx_conf_bed: tbx_conf_t;
}
extern "C" {
    pub static tbx_conf_psltbl: tbx_conf_t;
}
extern "C" {
    pub static tbx_conf_sam: tbx_conf_t;
}
extern "C" {
    pub static tbx_conf_vcf: tbx_conf_t;
}
extern "C" {
    pub fn tbx_name2id(tbx: *mut tbx_t, ss: *const ::std::os::raw::c_char)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hts_get_bgzfp(fp: *mut htsFile) -> *mut BGZF;
}
extern "C" {
    pub fn tbx_readrec(
        fp: *mut BGZF,
        tbxv: *mut ::std::os::raw::c_void,
        sv: *mut ::std::os::raw::c_void,
        tid: *mut ::std::os::raw::c_int,
        beg: *mut hts_pos_t,
        end: *mut hts_pos_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Build an index of the lines in a BGZF-compressed file"]
    #[doc = "** The index struct returned by a successful call should be freed"]
    #[doc = "via tbx_destroy() when it is no longer needed."]
    #[doc = "*/"]
    pub fn tbx_index(
        fp: *mut BGZF,
        min_shift: ::std::os::raw::c_int,
        conf: *const tbx_conf_t,
    ) -> *mut tbx_t;
}
extern "C" {
    pub fn tbx_index_build(
        fn_: *const ::std::os::raw::c_char,
        min_shift: ::std::os::raw::c_int,
        conf: *const tbx_conf_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tbx_index_build2(
        fn_: *const ::std::os::raw::c_char,
        fnidx: *const ::std::os::raw::c_char,
        min_shift: ::std::os::raw::c_int,
        conf: *const tbx_conf_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tbx_index_build3(
        fn_: *const ::std::os::raw::c_char,
        fnidx: *const ::std::os::raw::c_char,
        min_shift: ::std::os::raw::c_int,
        n_threads: ::std::os::raw::c_int,
        conf: *const tbx_conf_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Load or stream a .tbi or .csi index"]
    #[doc = "** @param fn     Name of the data file corresponding to the index"]
    #[doc = ""]
    #[doc = "Equivalent to tbx_index_load3(fn, NULL, HTS_IDX_SAVE_REMOTE);"]
    #[doc = "*/"]
    pub fn tbx_index_load(fn_: *const ::std::os::raw::c_char) -> *mut tbx_t;
}
extern "C" {
    #[doc = " Load or stream a .tbi or .csi index"]
    #[doc = "** @param fn     Name of the data file corresponding to the index"]
    #[doc = "@param fnidx  Name of the indexed file"]
    #[doc = "@return The index, or NULL if an error occurred"]
    #[doc = ""]
    #[doc = "If @p fnidx is NULL, the index name will be derived from @p fn."]
    #[doc = ""]
    #[doc = "Equivalent to tbx_index_load3(fn, fnidx, HTS_IDX_SAVE_REMOTE);"]
    #[doc = "*/"]
    pub fn tbx_index_load2(
        fn_: *const ::std::os::raw::c_char,
        fnidx: *const ::std::os::raw::c_char,
    ) -> *mut tbx_t;
}
extern "C" {
    #[doc = " Load or stream a .tbi or .csi index"]
    #[doc = "** @param fn     Name of the data file corresponding to the index"]
    #[doc = "@param fnidx  Name of the indexed file"]
    #[doc = "@param flags  Flags to alter behaviour (see description)"]
    #[doc = "@return The index, or NULL if an error occurred"]
    #[doc = ""]
    #[doc = "If @p fnidx is NULL, the index name will be derived from @p fn."]
    #[doc = ""]
    #[doc = "The @p flags parameter can be set to a combination of the following"]
    #[doc = "values:"]
    #[doc = ""]
    #[doc = "HTS_IDX_SAVE_REMOTE   Save a local copy of any remote indexes"]
    #[doc = "HTS_IDX_SILENT_FAIL   Fail silently if the index is not present"]
    #[doc = ""]
    #[doc = "The index struct returned by a successful call should be freed"]
    #[doc = "via tbx_destroy() when it is no longer needed."]
    #[doc = "*/"]
    pub fn tbx_index_load3(
        fn_: *const ::std::os::raw::c_char,
        fnidx: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> *mut tbx_t;
}
extern "C" {
    pub fn tbx_seqnames(
        tbx: *mut tbx_t,
        n: *mut ::std::os::raw::c_int,
    ) -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn tbx_destroy(tbx: *mut tbx_t);
}
pub const bcf_sr_opt_t_BCF_SR_REQUIRE_IDX: bcf_sr_opt_t = 0;
pub const bcf_sr_opt_t_BCF_SR_PAIR_LOGIC: bcf_sr_opt_t = 1;
pub const bcf_sr_opt_t_BCF_SR_ALLOW_NO_IDX: bcf_sr_opt_t = 2;
pub const bcf_sr_opt_t_BCF_SR_REGIONS_OVERLAP: bcf_sr_opt_t = 3;
pub const bcf_sr_opt_t_BCF_SR_TARGETS_OVERLAP: bcf_sr_opt_t = 4;
pub type bcf_sr_opt_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bcf_sr_region_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bcf_sr_regions_t {
    pub tbx: *mut tbx_t,
    pub itr: *mut hts_itr_t,
    pub line: kstring_t,
    pub file: *mut htsFile,
    pub fname: *mut ::std::os::raw::c_char,
    pub is_bin: ::std::os::raw::c_int,
    pub als: *mut *mut ::std::os::raw::c_char,
    pub als_str: kstring_t,
    pub nals: ::std::os::raw::c_int,
    pub mals: ::std::os::raw::c_int,
    pub als_type: ::std::os::raw::c_int,
    pub missed_reg_handler: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut bcf_sr_regions_t, arg2: *mut ::std::os::raw::c_void),
    >,
    pub missed_reg_data: *mut ::std::os::raw::c_void,
    pub regs: *mut bcf_sr_region_t,
    pub seq_hash: *mut ::std::os::raw::c_void,
    pub seq_names: *mut *mut ::std::os::raw::c_char,
    pub nseqs: ::std::os::raw::c_int,
    pub iseq: ::std::os::raw::c_int,
    pub start: hts_pos_t,
    pub end: hts_pos_t,
    pub prev_seq: ::std::os::raw::c_int,
    pub prev_start: hts_pos_t,
    pub prev_end: hts_pos_t,
    pub overlap: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_bcf_sr_regions_t() {
    assert_eq!(
        ::std::mem::size_of::<bcf_sr_regions_t>(),
        208usize,
        concat!("Size of: ", stringify!(bcf_sr_regions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bcf_sr_regions_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bcf_sr_regions_t))
    );
    fn test_field_tbx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_regions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tbx) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_regions_t),
                "::",
                stringify!(tbx)
            )
        );
    }
    test_field_tbx();
    fn test_field_itr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_regions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).itr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_regions_t),
                "::",
                stringify!(itr)
            )
        );
    }
    test_field_itr();
    fn test_field_line() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_regions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).line) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_regions_t),
                "::",
                stringify!(line)
            )
        );
    }
    test_field_line();
    fn test_field_file() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_regions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).file) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_regions_t),
                "::",
                stringify!(file)
            )
        );
    }
    test_field_file();
    fn test_field_fname() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_regions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fname) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_regions_t),
                "::",
                stringify!(fname)
            )
        );
    }
    test_field_fname();
    fn test_field_is_bin() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_regions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_bin) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_regions_t),
                "::",
                stringify!(is_bin)
            )
        );
    }
    test_field_is_bin();
    fn test_field_als() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_regions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).als) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_regions_t),
                "::",
                stringify!(als)
            )
        );
    }
    test_field_als();
    fn test_field_als_str() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_regions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).als_str) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_regions_t),
                "::",
                stringify!(als_str)
            )
        );
    }
    test_field_als_str();
    fn test_field_nals() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_regions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nals) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_regions_t),
                "::",
                stringify!(nals)
            )
        );
    }
    test_field_nals();
    fn test_field_mals() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_regions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mals) as usize - ptr as usize
            },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_regions_t),
                "::",
                stringify!(mals)
            )
        );
    }
    test_field_mals();
    fn test_field_als_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_regions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).als_type) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_regions_t),
                "::",
                stringify!(als_type)
            )
        );
    }
    test_field_als_type();
    fn test_field_missed_reg_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_regions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).missed_reg_handler) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_regions_t),
                "::",
                stringify!(missed_reg_handler)
            )
        );
    }
    test_field_missed_reg_handler();
    fn test_field_missed_reg_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_regions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).missed_reg_data) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_regions_t),
                "::",
                stringify!(missed_reg_data)
            )
        );
    }
    test_field_missed_reg_data();
    fn test_field_regs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_regions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).regs) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_regions_t),
                "::",
                stringify!(regs)
            )
        );
    }
    test_field_regs();
    fn test_field_seq_hash() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_regions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).seq_hash) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_regions_t),
                "::",
                stringify!(seq_hash)
            )
        );
    }
    test_field_seq_hash();
    fn test_field_seq_names() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_regions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).seq_names) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_regions_t),
                "::",
                stringify!(seq_names)
            )
        );
    }
    test_field_seq_names();
    fn test_field_nseqs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_regions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nseqs) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_regions_t),
                "::",
                stringify!(nseqs)
            )
        );
    }
    test_field_nseqs();
    fn test_field_iseq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_regions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iseq) as usize - ptr as usize
            },
            156usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_regions_t),
                "::",
                stringify!(iseq)
            )
        );
    }
    test_field_iseq();
    fn test_field_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_regions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_regions_t),
                "::",
                stringify!(start)
            )
        );
    }
    test_field_start();
    fn test_field_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_regions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_regions_t),
                "::",
                stringify!(end)
            )
        );
    }
    test_field_end();
    fn test_field_prev_seq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_regions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev_seq) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_regions_t),
                "::",
                stringify!(prev_seq)
            )
        );
    }
    test_field_prev_seq();
    fn test_field_prev_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_regions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev_start) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_regions_t),
                "::",
                stringify!(prev_start)
            )
        );
    }
    test_field_prev_start();
    fn test_field_prev_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_regions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev_end) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_regions_t),
                "::",
                stringify!(prev_end)
            )
        );
    }
    test_field_prev_end();
    fn test_field_overlap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_regions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).overlap) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_regions_t),
                "::",
                stringify!(overlap)
            )
        );
    }
    test_field_overlap();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bcf_sr_t {
    pub file: *mut htsFile,
    pub tbx_idx: *mut tbx_t,
    pub bcf_idx: *mut hts_idx_t,
    pub header: *mut bcf_hdr_t,
    pub itr: *mut hts_itr_t,
    pub fname: *mut ::std::os::raw::c_char,
    pub buffer: *mut *mut bcf1_t,
    pub nbuffer: ::std::os::raw::c_int,
    pub mbuffer: ::std::os::raw::c_int,
    pub nfilter_ids: ::std::os::raw::c_int,
    pub filter_ids: *mut ::std::os::raw::c_int,
    pub samples: *mut ::std::os::raw::c_int,
    pub n_smpl: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_bcf_sr_t() {
    assert_eq!(
        ::std::mem::size_of::<bcf_sr_t>(),
        96usize,
        concat!("Size of: ", stringify!(bcf_sr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bcf_sr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bcf_sr_t))
    );
    fn test_field_file() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).file) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_t),
                "::",
                stringify!(file)
            )
        );
    }
    test_field_file();
    fn test_field_tbx_idx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tbx_idx) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_t),
                "::",
                stringify!(tbx_idx)
            )
        );
    }
    test_field_tbx_idx();
    fn test_field_bcf_idx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bcf_idx) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_t),
                "::",
                stringify!(bcf_idx)
            )
        );
    }
    test_field_bcf_idx();
    fn test_field_header() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_t),
                "::",
                stringify!(header)
            )
        );
    }
    test_field_header();
    fn test_field_itr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).itr) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_t),
                "::",
                stringify!(itr)
            )
        );
    }
    test_field_itr();
    fn test_field_fname() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fname) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_t),
                "::",
                stringify!(fname)
            )
        );
    }
    test_field_fname();
    fn test_field_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_t),
                "::",
                stringify!(buffer)
            )
        );
    }
    test_field_buffer();
    fn test_field_nbuffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nbuffer) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_t),
                "::",
                stringify!(nbuffer)
            )
        );
    }
    test_field_nbuffer();
    fn test_field_mbuffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mbuffer) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_t),
                "::",
                stringify!(mbuffer)
            )
        );
    }
    test_field_mbuffer();
    fn test_field_nfilter_ids() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nfilter_ids) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_t),
                "::",
                stringify!(nfilter_ids)
            )
        );
    }
    test_field_nfilter_ids();
    fn test_field_filter_ids() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filter_ids) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_t),
                "::",
                stringify!(filter_ids)
            )
        );
    }
    test_field_filter_ids();
    fn test_field_samples() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).samples) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_t),
                "::",
                stringify!(samples)
            )
        );
    }
    test_field_samples();
    fn test_field_n_smpl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_sr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n_smpl) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_sr_t),
                "::",
                stringify!(n_smpl)
            )
        );
    }
    test_field_n_smpl();
}
pub const bcf_sr_error_open_failed: bcf_sr_error = 0;
pub const bcf_sr_error_not_bgzf: bcf_sr_error = 1;
pub const bcf_sr_error_idx_load_failed: bcf_sr_error = 2;
pub const bcf_sr_error_file_type_error: bcf_sr_error = 3;
pub const bcf_sr_error_api_usage_error: bcf_sr_error = 4;
pub const bcf_sr_error_header_error: bcf_sr_error = 5;
pub const bcf_sr_error_no_eof: bcf_sr_error = 6;
pub const bcf_sr_error_no_memory: bcf_sr_error = 7;
pub const bcf_sr_error_vcf_parse_error: bcf_sr_error = 8;
pub const bcf_sr_error_bcf_read_error: bcf_sr_error = 9;
pub const bcf_sr_error_noidx_error: bcf_sr_error = 10;
pub type bcf_sr_error = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bcf_srs_t {
    pub collapse: ::std::os::raw::c_int,
    pub apply_filters: *mut ::std::os::raw::c_char,
    pub require_index: ::std::os::raw::c_int,
    pub max_unpack: ::std::os::raw::c_int,
    pub has_line: *mut ::std::os::raw::c_int,
    pub errnum: bcf_sr_error,
    pub readers: *mut bcf_sr_t,
    pub nreaders: ::std::os::raw::c_int,
    pub streaming: ::std::os::raw::c_int,
    pub explicit_regs: ::std::os::raw::c_int,
    pub samples: *mut *mut ::std::os::raw::c_char,
    pub regions: *mut bcf_sr_regions_t,
    pub targets: *mut bcf_sr_regions_t,
    pub targets_als: ::std::os::raw::c_int,
    pub targets_exclude: ::std::os::raw::c_int,
    pub tmps: kstring_t,
    pub n_smpl: ::std::os::raw::c_int,
    pub n_threads: ::std::os::raw::c_int,
    pub p: *mut htsThreadPool,
    pub aux: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_bcf_srs_t() {
    assert_eq!(
        ::std::mem::size_of::<bcf_srs_t>(),
        144usize,
        concat!("Size of: ", stringify!(bcf_srs_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bcf_srs_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bcf_srs_t))
    );
    fn test_field_collapse() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_srs_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).collapse) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_srs_t),
                "::",
                stringify!(collapse)
            )
        );
    }
    test_field_collapse();
    fn test_field_apply_filters() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_srs_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).apply_filters) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_srs_t),
                "::",
                stringify!(apply_filters)
            )
        );
    }
    test_field_apply_filters();
    fn test_field_require_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_srs_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).require_index) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_srs_t),
                "::",
                stringify!(require_index)
            )
        );
    }
    test_field_require_index();
    fn test_field_max_unpack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_srs_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_unpack) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_srs_t),
                "::",
                stringify!(max_unpack)
            )
        );
    }
    test_field_max_unpack();
    fn test_field_has_line() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_srs_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_line) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_srs_t),
                "::",
                stringify!(has_line)
            )
        );
    }
    test_field_has_line();
    fn test_field_errnum() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_srs_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).errnum) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_srs_t),
                "::",
                stringify!(errnum)
            )
        );
    }
    test_field_errnum();
    fn test_field_readers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_srs_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).readers) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_srs_t),
                "::",
                stringify!(readers)
            )
        );
    }
    test_field_readers();
    fn test_field_nreaders() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_srs_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nreaders) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_srs_t),
                "::",
                stringify!(nreaders)
            )
        );
    }
    test_field_nreaders();
    fn test_field_streaming() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_srs_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).streaming) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_srs_t),
                "::",
                stringify!(streaming)
            )
        );
    }
    test_field_streaming();
    fn test_field_explicit_regs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_srs_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).explicit_regs) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_srs_t),
                "::",
                stringify!(explicit_regs)
            )
        );
    }
    test_field_explicit_regs();
    fn test_field_samples() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_srs_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).samples) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_srs_t),
                "::",
                stringify!(samples)
            )
        );
    }
    test_field_samples();
    fn test_field_regions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_srs_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).regions) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_srs_t),
                "::",
                stringify!(regions)
            )
        );
    }
    test_field_regions();
    fn test_field_targets() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_srs_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).targets) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_srs_t),
                "::",
                stringify!(targets)
            )
        );
    }
    test_field_targets();
    fn test_field_targets_als() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_srs_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).targets_als) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_srs_t),
                "::",
                stringify!(targets_als)
            )
        );
    }
    test_field_targets_als();
    fn test_field_targets_exclude() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_srs_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).targets_exclude) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_srs_t),
                "::",
                stringify!(targets_exclude)
            )
        );
    }
    test_field_targets_exclude();
    fn test_field_tmps() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_srs_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tmps) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_srs_t),
                "::",
                stringify!(tmps)
            )
        );
    }
    test_field_tmps();
    fn test_field_n_smpl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_srs_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n_smpl) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_srs_t),
                "::",
                stringify!(n_smpl)
            )
        );
    }
    test_field_n_smpl();
    fn test_field_n_threads() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_srs_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n_threads) as usize - ptr as usize
            },
            124usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_srs_t),
                "::",
                stringify!(n_threads)
            )
        );
    }
    test_field_n_threads();
    fn test_field_p() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_srs_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_srs_t),
                "::",
                stringify!(p)
            )
        );
    }
    test_field_p();
    fn test_field_aux() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<bcf_srs_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aux) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(bcf_srs_t),
                "::",
                stringify!(aux)
            )
        );
    }
    test_field_aux();
}
extern "C" {
    #[doc = " Allocate and initialize a bcf_srs_t struct."]
    #[doc = ""]
    #[doc = "  The bcf_srs_t struct returned by a successful call should be freed"]
    #[doc = "  via bcf_sr_destroy() when it is no longer needed."]
    pub fn bcf_sr_init() -> *mut bcf_srs_t;
}
extern "C" {
    #[doc = " Destroy a bcf_srs_t struct"]
    pub fn bcf_sr_destroy(readers: *mut bcf_srs_t);
}
extern "C" {
    pub fn bcf_sr_strerror(errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcf_sr_set_opt(readers: *mut bcf_srs_t, opt: bcf_sr_opt_t, ...)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " bcf_sr_set_threads() - allocates a thread-pool for use by the synced reader."]
    #[doc = " @n_threads: size of thread pool"]
    #[doc = ""]
    #[doc = " Returns 0 if the call succeeded, or <0 on error."]
    pub fn bcf_sr_set_threads(
        files: *mut bcf_srs_t,
        n_threads: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Deallocates thread memory, if owned by us."]
    pub fn bcf_sr_destroy_threads(files: *mut bcf_srs_t);
}
extern "C" {
    #[doc = "  bcf_sr_add_reader() - open new reader"]
    #[doc = "  @readers: holder of the open readers"]
    #[doc = "  @fname:   the VCF file"]
    #[doc = ""]
    #[doc = "  Returns 1 if the call succeeded, or 0 on error."]
    #[doc = ""]
    #[doc = "  See also the bcf_srs_t data structure for parameters controlling"]
    #[doc = "  the reader's logic."]
    pub fn bcf_sr_add_reader(
        readers: *mut bcf_srs_t,
        fname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcf_sr_remove_reader(files: *mut bcf_srs_t, i: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " bcf_sr_next_line() - the iterator"]
    #[doc = " @readers:    holder of the open readers"]
    #[doc = ""]
    #[doc = " Returns the number of readers which have the current line"]
    #[doc = " (bcf_sr_t.buffer[0]) set at this position. Use the bcf_sr_has_line macro to"]
    #[doc = " determine which of the readers are set."]
    pub fn bcf_sr_next_line(readers: *mut bcf_srs_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  bcf_sr_seek() - set all readers to selected position"]
    #[doc = "  @seq:  sequence name; NULL to seek to start"]
    #[doc = "  @pos:  0-based coordinate"]
    pub fn bcf_sr_seek(
        readers: *mut bcf_srs_t,
        seq: *const ::std::os::raw::c_char,
        pos: hts_pos_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " bcf_sr_set_samples() - sets active samples"]
    #[doc = " @readers: holder of the open readers"]
    #[doc = " @samples: this can be one of: file name with one sample per line;"]
    #[doc = "           or column-separated list of samples; or '-' for a list of"]
    #[doc = "           samples shared by all files. If first character is the"]
    #[doc = "           exclamation mark, all but the listed samples are included."]
    #[doc = " @is_file: 0: list of samples; 1: file with sample names"]
    #[doc = ""]
    #[doc = " Returns 1 if the call succeeded, or 0 on error."]
    pub fn bcf_sr_set_samples(
        readers: *mut bcf_srs_t,
        samples: *const ::std::os::raw::c_char,
        is_file: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  bcf_sr_set_targets(), bcf_sr_set_regions() - init targets/regions"]
    #[doc = "  @readers:   holder of the open readers"]
    #[doc = "  @targets:   list of regions, one-based and inclusive."]
    #[doc = "  @is_fname:  0: targets is a comma-separated list of regions (chr,chr:from-to)"]
    #[doc = "              1: targets is a tabix indexed file with a list of regions"]
    #[doc = "              (<chr,pos> or <chr,from,to>)"]
    #[doc = ""]
    #[doc = "  Returns 0 if the call succeeded, or -1 on error."]
    #[doc = ""]
    #[doc = "  Both functions behave the same way, unlisted positions will be skipped by"]
    #[doc = "  bcf_sr_next_line(). However, there is an important difference: regions use"]
    #[doc = "  index to jump to desired positions while targets streams the whole files"]
    #[doc = "  and merely skip unlisted positions."]
    #[doc = ""]
    #[doc = "  Moreover, bcf_sr_set_targets() accepts an optional parameter $alleles which"]
    #[doc = "  is interpreted as a 1-based column index in the tab-delimited file where"]
    #[doc = "  alleles are listed. This in principle enables to perform the COLLAPSE_*"]
    #[doc = "  logic also with tab-delimited files. However, the current implementation"]
    #[doc = "  considers the alleles merely as a suggestion for prioritizing one of possibly"]
    #[doc = "  duplicate VCF lines. It is up to the caller to examine targets->als if"]
    #[doc = "  perfect match is sought after. Note that the duplicate positions in targets"]
    #[doc = "  file are currently not supported."]
    #[doc = "  Targets (but not regions) can be prefixed with \"^\" to request logical complement,"]
    #[doc = "  for example \"^X,Y,MT\" indicates that sequences X, Y and MT should be skipped."]
    #[doc = ""]
    #[doc = "  API note: bcf_sr_set_regions/bcf_sr_set_targets MUST be called before the"]
    #[doc = "  first call to bcf_sr_add_reader()."]
    pub fn bcf_sr_set_targets(
        readers: *mut bcf_srs_t,
        targets: *const ::std::os::raw::c_char,
        is_file: ::std::os::raw::c_int,
        alleles: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcf_sr_set_regions(
        readers: *mut bcf_srs_t,
        regions: *const ::std::os::raw::c_char,
        is_file: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcf_sr_regions_init(
        regions: *const ::std::os::raw::c_char,
        is_file: ::std::os::raw::c_int,
        chr: ::std::os::raw::c_int,
        from: ::std::os::raw::c_int,
        to: ::std::os::raw::c_int,
    ) -> *mut bcf_sr_regions_t;
}
extern "C" {
    pub fn bcf_sr_regions_destroy(regions: *mut bcf_sr_regions_t);
}
extern "C" {
    pub fn bcf_sr_regions_seek(
        regions: *mut bcf_sr_regions_t,
        chr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcf_sr_regions_next(reg: *mut bcf_sr_regions_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcf_sr_regions_overlap(
        reg: *mut bcf_sr_regions_t,
        seq: *const ::std::os::raw::c_char,
        start: hts_pos_t,
        end: hts_pos_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcf_sr_regions_flush(regs: *mut bcf_sr_regions_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kbitset_t {
    pub n: size_t,
    pub n_max: size_t,
    pub b: [::std::os::raw::c_ulong; 1usize],
}
#[test]
fn bindgen_test_layout_kbitset_t() {
    assert_eq!(
        ::std::mem::size_of::<kbitset_t>(),
        24usize,
        concat!("Size of: ", stringify!(kbitset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<kbitset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(kbitset_t))
    );
    fn test_field_n() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kbitset_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kbitset_t),
                "::",
                stringify!(n)
            )
        );
    }
    test_field_n();
    fn test_field_n_max() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kbitset_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n_max) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(kbitset_t),
                "::",
                stringify!(n_max)
            )
        );
    }
    test_field_n_max();
    fn test_field_b() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kbitset_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(kbitset_t),
                "::",
                stringify!(b)
            )
        );
    }
    test_field_b();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kbitset_iter_t {
    pub mask: ::std::os::raw::c_ulong,
    pub elt: size_t,
    pub i: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_kbitset_iter_t() {
    assert_eq!(
        ::std::mem::size_of::<kbitset_iter_t>(),
        24usize,
        concat!("Size of: ", stringify!(kbitset_iter_t))
    );
    assert_eq!(
        ::std::mem::align_of::<kbitset_iter_t>(),
        8usize,
        concat!("Alignment of ", stringify!(kbitset_iter_t))
    );
    fn test_field_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kbitset_iter_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mask) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kbitset_iter_t),
                "::",
                stringify!(mask)
            )
        );
    }
    test_field_mask();
    fn test_field_elt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kbitset_iter_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).elt) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(kbitset_iter_t),
                "::",
                stringify!(elt)
            )
        );
    }
    test_field_elt();
    fn test_field_i() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kbitset_iter_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(kbitset_iter_t),
                "::",
                stringify!(i)
            )
        );
    }
    test_field_i();
}
#[doc = " @file"]
#[doc = ""]
#[doc = "Index FASTA or FASTQ files and extract subsequence."]
#[doc = ""]
#[doc = "The fai file index columns for FASTA are:"]
#[doc = "- chromosome name"]
#[doc = "- chromosome length: number of bases"]
#[doc = "- offset: number of bytes to skip to get to the first base"]
#[doc = "from the beginning of the file, including the length"]
#[doc = "of the sequence description string (`>chr ..\\n`)"]
#[doc = "- line length: number of bases per line (excluding `\\n`)"]
#[doc = "- binary line length: number of bytes, including `\\n`"]
#[doc = ""]
#[doc = "The index for FASTQ is similar to above:"]
#[doc = "- chromosome name"]
#[doc = "- chromosome length: number of bases"]
#[doc = "- sequence offset: number of bytes to skip to get to the first base"]
#[doc = "from the beginning of the file, including the length"]
#[doc = "of the sequence description string (`@chr ..\\n`)"]
#[doc = "- line length: number of bases per line (excluding `\\n`)"]
#[doc = "- binary line length: number of bytes, including `\\n`"]
#[doc = "- quality offset: number of bytes to skip from the beginning of the file"]
#[doc = "to get to the first quality value in the indexed entry."]
#[doc = ""]
#[doc = "The FASTQ version of the index uses line length and binary line length"]
#[doc = "for both the sequence and the quality values, so they must be line"]
#[doc = "wrapped in the same way."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct faidx_t {
    _unused: [u8; 0],
}
pub const fai_format_options_FAI_NONE: fai_format_options = 0;
pub const fai_format_options_FAI_FASTA: fai_format_options = 1;
pub const fai_format_options_FAI_FASTQ: fai_format_options = 2;
#[doc = " File format to be dealing with."]
pub type fai_format_options = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Build index for a FASTA or FASTQ or bgzip-compressed FASTA or FASTQ file."]
    #[doc = "**  @param  fn  FASTA/FASTQ file name"]
    #[doc = "@param  fnfai Name of .fai file to build."]
    #[doc = "@param  fngzi Name of .gzi file to build (if fn is bgzip-compressed)."]
    #[doc = "@return     0 on success; or -1 on failure"]
    #[doc = ""]
    #[doc = "If fnfai is NULL, \".fai\" will be appended to fn to make the FAI file name."]
    #[doc = "If fngzi is NULL, \".gzi\" will be appended to fn for the GZI file.  The GZI"]
    #[doc = "file will only be built if fn is bgzip-compressed."]
    #[doc = "*/"]
    pub fn fai_build3(
        fn_: *const ::std::os::raw::c_char,
        fnfai: *const ::std::os::raw::c_char,
        fngzi: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Build index for a FASTA or FASTQ or bgzip-compressed FASTA or FASTQ file."]
    #[doc = "** @param  fn  FASTA/FASTQ file name"]
    #[doc = "@return     0 on success; or -1 on failure"]
    #[doc = ""]
    #[doc = "File \"fn.fai\" will be generated.  This function is equivalent to"]
    #[doc = "fai_build3(fn, NULL, NULL);"]
    #[doc = "*/"]
    pub fn fai_build(fn_: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy a faidx_t struct"]
    pub fn fai_destroy(fai: *mut faidx_t);
}
pub const fai_load_options_FAI_CREATE: fai_load_options = 1;
pub type fai_load_options = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Load FASTA indexes."]
    #[doc = "** @param  fn  File name of the FASTA file (can be compressed with bgzip)."]
    #[doc = "@param  fnfai File name of the FASTA index."]
    #[doc = "@param  fngzi File name of the bgzip index."]
    #[doc = "@param  flags Option flags to control index file caching and creation."]
    #[doc = "@return Pointer to a faidx_t struct on success, NULL on failure."]
    #[doc = ""]
    #[doc = "If fnfai is NULL, \".fai\" will be appended to fn to make the FAI file name."]
    #[doc = "If fngzi is NULL, \".gzi\" will be appended to fn for the bgzip index name."]
    #[doc = "The bgzip index is only needed if fn is compressed."]
    #[doc = ""]
    #[doc = "If (flags & FAI_CREATE) is true, the index files will be built using"]
    #[doc = "fai_build3() if they are not already present."]
    #[doc = ""]
    #[doc = "The struct returned by a successful call should be freed via fai_destroy()"]
    #[doc = "when it is no longer needed."]
    #[doc = "*/"]
    pub fn fai_load3(
        fn_: *const ::std::os::raw::c_char,
        fnfai: *const ::std::os::raw::c_char,
        fngzi: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> *mut faidx_t;
}
extern "C" {
    #[doc = " Load index from \"fn.fai\"."]
    #[doc = "** @param  fn  File name of the FASTA file"]
    #[doc = "@return Pointer to a faidx_t struct on success, NULL on failure."]
    #[doc = ""]
    #[doc = "This function is equivalent to fai_load3(fn, NULL, NULL, FAI_CREATE|FAI_CACHE);"]
    #[doc = "*/"]
    pub fn fai_load(fn_: *const ::std::os::raw::c_char) -> *mut faidx_t;
}
extern "C" {
    #[doc = " Load FASTA or FASTQ indexes."]
    #[doc = "** @param  fn  File name of the FASTA/FASTQ file (can be compressed with bgzip)."]
    #[doc = "@param  fnfai File name of the FASTA/FASTQ index."]
    #[doc = "@param  fngzi File name of the bgzip index."]
    #[doc = "@param  flags Option flags to control index file caching and creation."]
    #[doc = "@param  format FASTA or FASTQ file format"]
    #[doc = "@return Pointer to a faidx_t struct on success, NULL on failure."]
    #[doc = ""]
    #[doc = "If fnfai is NULL, \".fai\" will be appended to fn to make the FAI file name."]
    #[doc = "If fngzi is NULL, \".gzi\" will be appended to fn for the bgzip index name."]
    #[doc = "The bgzip index is only needed if fn is compressed."]
    #[doc = ""]
    #[doc = "If (flags & FAI_CREATE) is true, the index files will be built using"]
    #[doc = "fai_build3() if they are not already present."]
    #[doc = ""]
    #[doc = "The struct returned by a successful call should be freed via fai_destroy()"]
    #[doc = "when it is no longer needed."]
    #[doc = "*/"]
    pub fn fai_load3_format(
        fn_: *const ::std::os::raw::c_char,
        fnfai: *const ::std::os::raw::c_char,
        fngzi: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        format: fai_format_options,
    ) -> *mut faidx_t;
}
extern "C" {
    #[doc = " Load index from \"fn.fai\"."]
    #[doc = "** @param  fn  File name of the FASTA/FASTQ file"]
    #[doc = "@param  format FASTA or FASTQ file format"]
    #[doc = "@return Pointer to a faidx_t struct on success, NULL on failure."]
    #[doc = ""]
    #[doc = "This function is equivalent to fai_load3_format(fn, NULL, NULL, FAI_CREATE|FAI_CACHE, format);"]
    #[doc = "*/"]
    pub fn fai_load_format(
        fn_: *const ::std::os::raw::c_char,
        format: fai_format_options,
    ) -> *mut faidx_t;
}
extern "C" {
    #[doc = " Fetch the sequence in a region"]
    #[doc = "** @param  fai  Pointer to the faidx_t struct"]
    #[doc = "@param  reg  Region in the format \"chr2:20,000-30,000\""]
    #[doc = "@param  len  Length of the region; -2 if seq not present, -1 general error"]
    #[doc = "@return      Pointer to the sequence; `NULL` on failure"]
    #[doc = ""]
    #[doc = "The returned sequence is allocated by `malloc()` family and should be destroyed"]
    #[doc = "by end users by calling `free()` on it."]
    #[doc = ""]
    #[doc = "To work around ambiguous parsing issues, eg both \"chr1\" and \"chr1:100-200\""]
    #[doc = "are reference names, quote using curly braces."]
    #[doc = "Thus \"{chr1}:100-200\" and \"{chr1:100-200}\" disambiguate the above example."]
    #[doc = "*/"]
    pub fn fai_fetch(
        fai: *const faidx_t,
        reg: *const ::std::os::raw::c_char,
        len: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fai_fetch64(
        fai: *const faidx_t,
        reg: *const ::std::os::raw::c_char,
        len: *mut hts_pos_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Fetch the quality string for a region for FASTQ files"]
    #[doc = "** @param  fai  Pointer to the faidx_t struct"]
    #[doc = "@param  reg  Region in the format \"chr2:20,000-30,000\""]
    #[doc = "@param  len  Length of the region; -2 if seq not present, -1 general error"]
    #[doc = "@return      Pointer to the quality string; null on failure"]
    #[doc = ""]
    #[doc = "The returned quality string is allocated by `malloc()` family and should be"]
    #[doc = "destroyed by end users by calling `free()` on it."]
    #[doc = ""]
    #[doc = "Region names can be quoted with curly braces, as for fai_fetch()."]
    #[doc = "*/"]
    pub fn fai_fetchqual(
        fai: *const faidx_t,
        reg: *const ::std::os::raw::c_char,
        len: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fai_fetchqual64(
        fai: *const faidx_t,
        reg: *const ::std::os::raw::c_char,
        len: *mut hts_pos_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Fetch the number of sequences"]
    #[doc = "** @param  fai  Pointer to the faidx_t struct"]
    #[doc = "@return      The number of sequences"]
    #[doc = "*/"]
    pub fn faidx_fetch_nseq(fai: *const faidx_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Fetch the sequence in a region"]
    #[doc = "** @param  fai  Pointer to the faidx_t struct"]
    #[doc = "@param  c_name Region name"]
    #[doc = "@param  p_beg_i  Beginning position number (zero-based)"]
    #[doc = "@param  p_end_i  End position number (zero-based)"]
    #[doc = "@param  len  Length of the region; -2 if c_name not present, -1 general error"]
    #[doc = "@return      Pointer to the sequence; null on failure"]
    #[doc = ""]
    #[doc = "The returned sequence is allocated by `malloc()` family and should be destroyed"]
    #[doc = "by end users by calling `free()` on it."]
    #[doc = "*/"]
    pub fn faidx_fetch_seq(
        fai: *const faidx_t,
        c_name: *const ::std::os::raw::c_char,
        p_beg_i: ::std::os::raw::c_int,
        p_end_i: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Fetch the sequence in a region"]
    #[doc = "** @param  fai  Pointer to the faidx_t struct"]
    #[doc = "@param  c_name Region name"]
    #[doc = "@param  p_beg_i  Beginning position number (zero-based)"]
    #[doc = "@param  p_end_i  End position number (zero-based)"]
    #[doc = "@param  len  Length of the region; -2 if c_name not present, -1 general error"]
    #[doc = "@return      Pointer to the sequence; null on failure"]
    #[doc = ""]
    #[doc = "The returned sequence is allocated by `malloc()` family and should be destroyed"]
    #[doc = "by end users by calling `free()` on it."]
    #[doc = "*/"]
    pub fn faidx_fetch_seq64(
        fai: *const faidx_t,
        c_name: *const ::std::os::raw::c_char,
        p_beg_i: hts_pos_t,
        p_end_i: hts_pos_t,
        len: *mut hts_pos_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Fetch the quality string in a region for FASTQ files"]
    #[doc = "** @param  fai  Pointer to the faidx_t struct"]
    #[doc = "@param  c_name Region name"]
    #[doc = "@param  p_beg_i  Beginning position number (zero-based)"]
    #[doc = "@param  p_end_i  End position number (zero-based)"]
    #[doc = "@param  len  Length of the region; -2 if c_name not present, -1 general error"]
    #[doc = "@return      Pointer to the sequence; null on failure"]
    #[doc = ""]
    #[doc = "The returned sequence is allocated by `malloc()` family and should be destroyed"]
    #[doc = "by end users by calling `free()` on it."]
    #[doc = "*/"]
    pub fn faidx_fetch_qual(
        fai: *const faidx_t,
        c_name: *const ::std::os::raw::c_char,
        p_beg_i: ::std::os::raw::c_int,
        p_end_i: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Fetch the quality string in a region for FASTQ files"]
    #[doc = "** @param  fai  Pointer to the faidx_t struct"]
    #[doc = "@param  c_name Region name"]
    #[doc = "@param  p_beg_i  Beginning position number (zero-based)"]
    #[doc = "@param  p_end_i  End position number (zero-based)"]
    #[doc = "@param  len  Length of the region; -2 if c_name not present, -1 general error"]
    #[doc = "@return      Pointer to the sequence; null on failure"]
    #[doc = ""]
    #[doc = "The returned sequence is allocated by `malloc()` family and should be destroyed"]
    #[doc = "by end users by calling `free()` on it."]
    #[doc = "*/"]
    pub fn faidx_fetch_qual64(
        fai: *const faidx_t,
        c_name: *const ::std::os::raw::c_char,
        p_beg_i: hts_pos_t,
        p_end_i: hts_pos_t,
        len: *mut hts_pos_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Query if sequence is present"]
    #[doc = "**   @param  fai  Pointer to the faidx_t struct"]
    #[doc = "@param  seq  Sequence name"]
    #[doc = "@return      1 if present or 0 if absent"]
    #[doc = "*/"]
    pub fn faidx_has_seq(
        fai: *const faidx_t,
        seq: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return number of sequences in fai index"]
    pub fn faidx_nseq(fai: *const faidx_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return name of i-th sequence"]
    pub fn faidx_iseq(
        fai: *const faidx_t,
        i: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return sequence length, -1 if not present"]
    pub fn faidx_seq_len(
        fai: *const faidx_t,
        seq: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parses a region string."]
    #[doc = "** @param  fai   Pointer to the faidx_t struct"]
    #[doc = "@param  s     Region string"]
    #[doc = "@param  tid   Returns which i-th sequence is described in the region."]
    #[doc = "@param  beg   Returns the start of the region (0 based)"]
    #[doc = "@param  end   Returns the one past last of the region (0 based)"]
    #[doc = "@param  flags Parsing method, see HTS_PARSE_* in hts.h."]
    #[doc = "@return       Pointer to end of parsed s if successful, NULL if not."]
    #[doc = ""]
    #[doc = "To work around ambiguous parsing issues, eg both \"chr1\" and \"chr1:100-200\""]
    #[doc = "are reference names, quote using curly braces."]
    #[doc = "Thus \"{chr1}:100-200\" and \"{chr1:100-200}\" disambiguate the above example."]
    #[doc = "*/"]
    pub fn fai_parse_region(
        fai: *const faidx_t,
        s: *const ::std::os::raw::c_char,
        tid: *mut ::std::os::raw::c_int,
        beg: *mut hts_pos_t,
        end: *mut hts_pos_t,
        flags: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Sets the cache size of the underlying BGZF compressed file"]
    #[doc = "** @param  fai         Pointer to the faidx_t struct"]
    #[doc = "*  @param  cache_size  Selected cache size in bytes"]
    #[doc = "*/"]
    pub fn fai_set_cache_size(fai: *mut faidx_t, cache_size: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Determines the path to the reference index file"]
    #[doc = "** @param  fa    String with the path to the reference file"]
    #[doc = "*  @return       String with the path to the reference index file, or NULL on failure"]
    #[doc = ""]
    #[doc = "If the reference path has the format reference.fa##idx##index.fa.fai,"]
    #[doc = "the index path is taken directly from it as index.fa.fai."]
    #[doc = "If the reference file is local and the index file cannot be found, it"]
    #[doc = "will be created alongside the reference file."]
    #[doc = "If the reference file is remote and the index file cannot be found,"]
    #[doc = "the method returns NULL."]
    #[doc = ""]
    #[doc = "The returned string has to be freed by the user at the end of its scope."]
    #[doc = "*/"]
    pub fn fai_path(fa: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hts_tpool_process {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hts_tpool_result {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hts_tpool_init(n: ::std::os::raw::c_int) -> *mut hts_tpool;
}
extern "C" {
    pub fn hts_tpool_size(p: *mut hts_tpool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add an item to the work pool."]
    #[doc = "**"]
    #[doc = "* @param p     Thread pool"]
    #[doc = "* @param q     Process queue"]
    #[doc = "* @param func  Function run by the thread pool"]
    #[doc = "* @param arg   Data for use by func()"]
    #[doc = "* @return 0 on success"]
    #[doc = "*        -1 on failure"]
    #[doc = "*/"]
    pub fn hts_tpool_dispatch(
        p: *mut hts_tpool,
        q: *mut hts_tpool_process,
        func: ::std::option::Option<
            unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add an item to the work pool, with nonblocking option."]
    #[doc = "**"]
    #[doc = "* @param p         Thread pool"]
    #[doc = "* @param q         Process queue"]
    #[doc = "* @param func      Function run by the thread pool"]
    #[doc = "* @param arg       Data for use by func()"]
    #[doc = "* @param nonblock  Non-blocking flag (see description)"]
    #[doc = "* @return 0 on success"]
    #[doc = "*        -1 on failure"]
    #[doc = "*"]
    #[doc = "* The @p nonblock parameter can take one of the following values:"]
    #[doc = "*      0 => block if input queue is full"]
    #[doc = "*     +1 => don't block if input queue is full, but do not add task"]
    #[doc = "*     -1 => add task regardless of whether queue is full (over-size)"]
    #[doc = "*"]
    #[doc = "* If @p nonblock is +1 and the queue is full, -1 will be returned and"]
    #[doc = "* `errno` is set to `EAGAIN`."]
    #[doc = "*/"]
    pub fn hts_tpool_dispatch2(
        p: *mut hts_tpool,
        q: *mut hts_tpool_process,
        func: ::std::option::Option<
            unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg: *mut ::std::os::raw::c_void,
        nonblock: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add an item to the work pool, with nonblocking and cleanup callbacks."]
    #[doc = "**"]
    #[doc = "* @param p               Thread pool"]
    #[doc = "* @param q               Process queue"]
    #[doc = "* @param exec_func       Function run by the thread pool"]
    #[doc = "* @param arg             Data for use by func()"]
    #[doc = "* @param job_cleanup     Callback to clean up when discarding jobs"]
    #[doc = "* @param result_cleanup  Callback to clean up when discarding result data"]
    #[doc = "* @param nonblock        Non-blocking flag (see description)"]
    #[doc = "* @return 0 on success"]
    #[doc = "*        -1 on failure"]
    #[doc = "*"]
    #[doc = "* The @p nonblock parameter can take one of the following values:"]
    #[doc = "*      0 => block if input queue is full"]
    #[doc = "*     +1 => don't block if input queue is full, but do not add task"]
    #[doc = "*     -1 => add task regardless of whether queue is full (over-size)"]
    #[doc = "*"]
    #[doc = "* If @p nonblock is +1 and the queue is full, -1 will be returned and"]
    #[doc = "* `errno` is set to `EAGAIN`."]
    #[doc = "*"]
    #[doc = "* The job_cleanup() and result_cleanup() callbacks are used when discarding"]
    #[doc = "* data from a queue, for example when calling hts_tpool_process_reset()"]
    #[doc = "* or hts_tpool_process_destroy()."]
    #[doc = "*"]
    #[doc = "* If not NULL, job_cleanup() will be called for each pending job with the"]
    #[doc = "* value of @p arg that was set for that job.  This can be used to free"]
    #[doc = "* any data associated with @p arg, and also @p arg itself."]
    #[doc = "*"]
    #[doc = "* Similarly, result_cleanup() can be used to free any results left by"]
    #[doc = "* jobs that had started before hts_tpool_process_reset() was called."]
    #[doc = "* The argument passed to result_cleanup() is the pointer that would"]
    #[doc = "* have been returned by calling hts_tpool_result_data() on the result"]
    #[doc = "* when pulled from the queue."]
    #[doc = "*"]
    #[doc = "* job_cleanup() and result_cleanup() are only called when discarding jobs."]
    #[doc = "* For jobs that are processed normally, it is the responsibility of"]
    #[doc = "* exec_func() and / or consumers of any results to do any cleaning up"]
    #[doc = "* necessary."]
    #[doc = "*/"]
    pub fn hts_tpool_dispatch3(
        p: *mut hts_tpool,
        q: *mut hts_tpool_process,
        exec_func: ::std::option::Option<
            unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg: *mut ::std::os::raw::c_void,
        job_cleanup: ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void)>,
        result_cleanup: ::std::option::Option<
            unsafe extern "C" fn(data: *mut ::std::os::raw::c_void),
        >,
        nonblock: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hts_tpool_wake_dispatch(q: *mut hts_tpool_process);
}
extern "C" {
    pub fn hts_tpool_process_flush(q: *mut hts_tpool_process) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hts_tpool_process_reset(
        q: *mut hts_tpool_process,
        free_results: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hts_tpool_process_qsize(q: *mut hts_tpool_process) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hts_tpool_destroy(p: *mut hts_tpool);
}
extern "C" {
    pub fn hts_tpool_kill(p: *mut hts_tpool);
}
extern "C" {
    pub fn hts_tpool_next_result(q: *mut hts_tpool_process) -> *mut hts_tpool_result;
}
extern "C" {
    pub fn hts_tpool_next_result_wait(q: *mut hts_tpool_process) -> *mut hts_tpool_result;
}
extern "C" {
    pub fn hts_tpool_delete_result(r: *mut hts_tpool_result, free_data: ::std::os::raw::c_int);
}
extern "C" {
    pub fn hts_tpool_result_data(r: *mut hts_tpool_result) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hts_tpool_process_init(
        p: *mut hts_tpool,
        qsize: ::std::os::raw::c_int,
        in_only: ::std::os::raw::c_int,
    ) -> *mut hts_tpool_process;
}
extern "C" {
    pub fn hts_tpool_process_destroy(q: *mut hts_tpool_process);
}
extern "C" {
    pub fn hts_tpool_process_empty(q: *mut hts_tpool_process) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hts_tpool_process_len(q: *mut hts_tpool_process) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hts_tpool_process_sz(q: *mut hts_tpool_process) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hts_tpool_process_shutdown(q: *mut hts_tpool_process);
}
extern "C" {
    pub fn hts_tpool_process_is_shutdown(q: *mut hts_tpool_process) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hts_tpool_process_attach(p: *mut hts_tpool, q: *mut hts_tpool_process);
}
extern "C" {
    pub fn hts_tpool_process_detach(p: *mut hts_tpool, q: *mut hts_tpool_process);
}
extern "C" {
    pub fn hts_tpool_process_ref_incr(q: *mut hts_tpool_process);
}
extern "C" {
    pub fn hts_tpool_process_ref_decr(q: *mut hts_tpool_process);
}
extern "C" {
    #[doc = " <div rustbindgen replaces=\"kbs_init2\"></div>"]
    #[link_name = "\u{1}wrap_kbs_init2"]
    pub fn kbs_init2(ni: size_t, fill: ::std::os::raw::c_int) -> *mut kbitset_t;
}
extern "C" {
    #[doc = " <div rustbindgen replaces=\"kbs_init\"></div>"]
    #[link_name = "\u{1}wrap_kbs_init"]
    pub fn kbs_init(ni: size_t) -> *mut kbitset_t;
}
extern "C" {
    #[doc = " <div rustbindgen replaces=\"kbs_insert\"></div>"]
    #[link_name = "\u{1}wrap_kbs_insert"]
    pub fn kbs_insert(bs: *mut kbitset_t, i: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " <div rustbindgen replaces=\"kbs_destroy\"></div>"]
    #[link_name = "\u{1}wrap_kbs_destroy"]
    pub fn kbs_destroy(bs: *mut kbitset_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    fn test_field_gp_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(gp_offset)
            )
        );
    }
    test_field_gp_offset();
    fn test_field_fp_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(fp_offset)
            )
        );
    }
    test_field_fp_offset();
    fn test_field_overflow_arg_area() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(overflow_arg_area)
            )
        );
    }
    test_field_overflow_arg_area();
    fn test_field_reg_save_area() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(reg_save_area)
            )
        );
    }
    test_field_reg_save_area();
}
